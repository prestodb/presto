// DO NOT EDIT : This file is generated by chevron
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// presto_protocol.prolog.cpp
//

// This file is generated DO NOT EDIT @generated

#include <iostream>

#include "presto_cpp/presto_protocol/connector/hive/presto_protocol_hive.h"
using namespace std::string_literals;

namespace facebook::presto::protocol::hive {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<ColumnType, json> ColumnType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {ColumnType::PARTITION_KEY, "PARTITION_KEY"},
        {ColumnType::REGULAR, "REGULAR"},
        {ColumnType::SYNTHESIZED, "SYNTHESIZED"},
        {ColumnType::AGGREGATED, "AGGREGATED"}};
void to_json(json& j, const ColumnType& e) {
  static_assert(std::is_enum<ColumnType>::value, "ColumnType must be an enum!");
  const auto* it = std::find_if(
      std::begin(ColumnType_enum_table),
      std::end(ColumnType_enum_table),
      [e](const std::pair<ColumnType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(ColumnType_enum_table))
           ? it
           : std::begin(ColumnType_enum_table))
          ->second;
}
void from_json(const json& j, ColumnType& e) {
  static_assert(std::is_enum<ColumnType>::value, "ColumnType must be an enum!");
  const auto* it = std::find_if(
      std::begin(ColumnType_enum_table),
      std::end(ColumnType_enum_table),
      [&j](const std::pair<ColumnType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(ColumnType_enum_table))
           ? it
           : std::begin(ColumnType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
HiveColumnHandle::HiveColumnHandle() noexcept {
  _type = "hive";
}

void to_json(json& j, const HiveColumnHandle& p) {
  j = json::object();
  j["@type"] = "hive";
  to_json_key(j, "name", p.name, "HiveColumnHandle", "String", "name");
  to_json_key(
      j, "hiveType", p.hiveType, "HiveColumnHandle", "HiveType", "hiveType");
  to_json_key(
      j,
      "typeSignature",
      p.typeSignature,
      "HiveColumnHandle",
      "TypeSignature",
      "typeSignature");
  to_json_key(
      j,
      "hiveColumnIndex",
      p.hiveColumnIndex,
      "HiveColumnHandle",
      "int",
      "hiveColumnIndex");
  to_json_key(
      j,
      "columnType",
      p.columnType,
      "HiveColumnHandle",
      "ColumnType",
      "columnType");
  to_json_key(j, "comment", p.comment, "HiveColumnHandle", "String", "comment");
  to_json_key(
      j,
      "requiredSubfields",
      p.requiredSubfields,
      "HiveColumnHandle",
      "List<Subfield>",
      "requiredSubfields");
  to_json_key(
      j,
      "partialAggregation",
      p.partialAggregation,
      "HiveColumnHandle",
      "Aggregation",
      "partialAggregation");
}

void from_json(const json& j, HiveColumnHandle& p) {
  p._type = j["@type"];
  from_json_key(j, "name", p.name, "HiveColumnHandle", "String", "name");
  from_json_key(
      j, "hiveType", p.hiveType, "HiveColumnHandle", "HiveType", "hiveType");
  from_json_key(
      j,
      "typeSignature",
      p.typeSignature,
      "HiveColumnHandle",
      "TypeSignature",
      "typeSignature");
  from_json_key(
      j,
      "hiveColumnIndex",
      p.hiveColumnIndex,
      "HiveColumnHandle",
      "int",
      "hiveColumnIndex");
  from_json_key(
      j,
      "columnType",
      p.columnType,
      "HiveColumnHandle",
      "ColumnType",
      "columnType");
  from_json_key(
      j, "comment", p.comment, "HiveColumnHandle", "String", "comment");
  from_json_key(
      j,
      "requiredSubfields",
      p.requiredSubfields,
      "HiveColumnHandle",
      "List<Subfield>",
      "requiredSubfields");
  from_json_key(
      j,
      "partialAggregation",
      p.partialAggregation,
      "HiveColumnHandle",
      "Aggregation",
      "partialAggregation");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const BucketConversion& p) {
  j = json::object();
  to_json_key(
      j,
      "tableBucketCount",
      p.tableBucketCount,
      "BucketConversion",
      "int",
      "tableBucketCount");
  to_json_key(
      j,
      "partitionBucketCount",
      p.partitionBucketCount,
      "BucketConversion",
      "int",
      "partitionBucketCount");
  to_json_key(
      j,
      "bucketColumnHandles",
      p.bucketColumnHandles,
      "BucketConversion",
      "List<HiveColumnHandle>",
      "bucketColumnHandles");
}

void from_json(const json& j, BucketConversion& p) {
  from_json_key(
      j,
      "tableBucketCount",
      p.tableBucketCount,
      "BucketConversion",
      "int",
      "tableBucketCount");
  from_json_key(
      j,
      "partitionBucketCount",
      p.partitionBucketCount,
      "BucketConversion",
      "int",
      "partitionBucketCount");
  from_json_key(
      j,
      "bucketColumnHandles",
      p.bucketColumnHandles,
      "BucketConversion",
      "List<HiveColumnHandle>",
      "bucketColumnHandles");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const DwrfEncryptionMetadata& p) {
  j = json::object();
  to_json_key(
      j,
      "fieldToKeyData",
      p.fieldToKeyData,
      "DwrfEncryptionMetadata",
      "Map<String, String>",
      "fieldToKeyData");
  to_json_key(
      j,
      "extraMetadata",
      p.extraMetadata,
      "DwrfEncryptionMetadata",
      "Map<String, String>",
      "extraMetadata");
  to_json_key(
      j,
      "encryptionAlgorithm",
      p.encryptionAlgorithm,
      "DwrfEncryptionMetadata",
      "String",
      "encryptionAlgorithm");
  to_json_key(
      j,
      "encryptionProvider",
      p.encryptionProvider,
      "DwrfEncryptionMetadata",
      "String",
      "encryptionProvider");
}

void from_json(const json& j, DwrfEncryptionMetadata& p) {
  from_json_key(
      j,
      "fieldToKeyData",
      p.fieldToKeyData,
      "DwrfEncryptionMetadata",
      "Map<String, String>",
      "fieldToKeyData");
  from_json_key(
      j,
      "extraMetadata",
      p.extraMetadata,
      "DwrfEncryptionMetadata",
      "Map<String, String>",
      "extraMetadata");
  from_json_key(
      j,
      "encryptionAlgorithm",
      p.encryptionAlgorithm,
      "DwrfEncryptionMetadata",
      "String",
      "encryptionAlgorithm");
  from_json_key(
      j,
      "encryptionProvider",
      p.encryptionProvider,
      "DwrfEncryptionMetadata",
      "String",
      "encryptionProvider");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const EncryptionInformation& p) {
  j = json::object();
  to_json_key(
      j,
      "dwrfEncryptionMetadata",
      p.dwrfEncryptionMetadata,
      "EncryptionInformation",
      "DwrfEncryptionMetadata",
      "dwrfEncryptionMetadata");
}

void from_json(const json& j, EncryptionInformation& p) {
  from_json_key(
      j,
      "dwrfEncryptionMetadata",
      p.dwrfEncryptionMetadata,
      "EncryptionInformation",
      "DwrfEncryptionMetadata",
      "dwrfEncryptionMetadata");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const HiveBucketFilter& p) {
  j = json::object();
  to_json_key(
      j,
      "bucketsToKeep",
      p.bucketsToKeep,
      "HiveBucketFilter",
      "List<Integer>",
      "bucketsToKeep");
}

void from_json(const json& j, HiveBucketFilter& p) {
  from_json_key(
      j,
      "bucketsToKeep",
      p.bucketsToKeep,
      "HiveBucketFilter",
      "List<Integer>",
      "bucketsToKeep");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const HiveBucketHandle& p) {
  j = json::object();
  to_json_key(
      j,
      "columns",
      p.columns,
      "HiveBucketHandle",
      "List<HiveColumnHandle>",
      "columns");
  to_json_key(
      j,
      "tableBucketCount",
      p.tableBucketCount,
      "HiveBucketHandle",
      "int",
      "tableBucketCount");
  to_json_key(
      j,
      "readBucketCount",
      p.readBucketCount,
      "HiveBucketHandle",
      "int",
      "readBucketCount");
}

void from_json(const json& j, HiveBucketHandle& p) {
  from_json_key(
      j,
      "columns",
      p.columns,
      "HiveBucketHandle",
      "List<HiveColumnHandle>",
      "columns");
  from_json_key(
      j,
      "tableBucketCount",
      p.tableBucketCount,
      "HiveBucketHandle",
      "int",
      "tableBucketCount");
  from_json_key(
      j,
      "readBucketCount",
      p.readBucketCount,
      "HiveBucketHandle",
      "int",
      "readBucketCount");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<BucketFunctionType, json>
    BucketFunctionType_enum_table[] = { // NOLINT: cert-err58-cpp
        {BucketFunctionType::HIVE_COMPATIBLE, "HIVE_COMPATIBLE"},
        {BucketFunctionType::PRESTO_NATIVE, "PRESTO_NATIVE"}};
void to_json(json& j, const BucketFunctionType& e) {
  static_assert(
      std::is_enum<BucketFunctionType>::value,
      "BucketFunctionType must be an enum!");
  const auto* it = std::find_if(
      std::begin(BucketFunctionType_enum_table),
      std::end(BucketFunctionType_enum_table),
      [e](const std::pair<BucketFunctionType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(BucketFunctionType_enum_table))
           ? it
           : std::begin(BucketFunctionType_enum_table))
          ->second;
}
void from_json(const json& j, BucketFunctionType& e) {
  static_assert(
      std::is_enum<BucketFunctionType>::value,
      "BucketFunctionType must be an enum!");
  const auto* it = std::find_if(
      std::begin(BucketFunctionType_enum_table),
      std::end(BucketFunctionType_enum_table),
      [&j](const std::pair<BucketFunctionType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(BucketFunctionType_enum_table))
           ? it
           : std::begin(BucketFunctionType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<Order, json> Order_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {Order::ASCENDING, "ASCENDING"},
        {Order::DESCENDING, "DESCENDING"}};
void to_json(json& j, const Order& e) {
  static_assert(std::is_enum<Order>::value, "Order must be an enum!");
  const auto* it = std::find_if(
      std::begin(Order_enum_table),
      std::end(Order_enum_table),
      [e](const std::pair<Order, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(Order_enum_table)) ? it : std::begin(Order_enum_table))
          ->second;
}
void from_json(const json& j, Order& e) {
  static_assert(std::is_enum<Order>::value, "Order must be an enum!");
  const auto* it = std::find_if(
      std::begin(Order_enum_table),
      std::end(Order_enum_table),
      [&j](const std::pair<Order, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(Order_enum_table)) ? it : std::begin(Order_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const SortingColumn& p) {
  j = json::object();
  to_json_key(
      j, "columnName", p.columnName, "SortingColumn", "String", "columnName");
  to_json_key(j, "order", p.order, "SortingColumn", "Order", "order");
}

void from_json(const json& j, SortingColumn& p) {
  from_json_key(
      j, "columnName", p.columnName, "SortingColumn", "String", "columnName");
  from_json_key(j, "order", p.order, "SortingColumn", "Order", "order");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const HiveBucketProperty& p) {
  j = json::object();
  to_json_key(
      j,
      "bucketedBy",
      p.bucketedBy,
      "HiveBucketProperty",
      "List<String>",
      "bucketedBy");
  to_json_key(
      j,
      "bucketCount",
      p.bucketCount,
      "HiveBucketProperty",
      "int",
      "bucketCount");
  to_json_key(
      j,
      "sortedBy",
      p.sortedBy,
      "HiveBucketProperty",
      "List<SortingColumn>",
      "sortedBy");
  to_json_key(
      j,
      "bucketFunctionType",
      p.bucketFunctionType,
      "HiveBucketProperty",
      "BucketFunctionType",
      "bucketFunctionType");
  to_json_key(j, "types", p.types, "HiveBucketProperty", "List<Type>", "types");
}

void from_json(const json& j, HiveBucketProperty& p) {
  from_json_key(
      j,
      "bucketedBy",
      p.bucketedBy,
      "HiveBucketProperty",
      "List<String>",
      "bucketedBy");
  from_json_key(
      j,
      "bucketCount",
      p.bucketCount,
      "HiveBucketProperty",
      "int",
      "bucketCount");
  from_json_key(
      j,
      "sortedBy",
      p.sortedBy,
      "HiveBucketProperty",
      "List<SortingColumn>",
      "sortedBy");
  from_json_key(
      j,
      "bucketFunctionType",
      p.bucketFunctionType,
      "HiveBucketProperty",
      "BucketFunctionType",
      "bucketFunctionType");
  from_json_key(
      j, "types", p.types, "HiveBucketProperty", "List<Type>", "types");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const HiveFileSplit& p) {
  j = json::object();
  to_json_key(j, "path", p.path, "HiveFileSplit", "String", "path");
  to_json_key(j, "start", p.start, "HiveFileSplit", "int64_t", "start");
  to_json_key(j, "length", p.length, "HiveFileSplit", "int64_t", "length");
  to_json_key(
      j, "fileSize", p.fileSize, "HiveFileSplit", "int64_t", "fileSize");
  to_json_key(
      j,
      "fileModifiedTime",
      p.fileModifiedTime,
      "HiveFileSplit",
      "int64_t",
      "fileModifiedTime");
  to_json_key(
      j,
      "extraFileInfo",
      p.extraFileInfo,
      "HiveFileSplit",
      "String",
      "extraFileInfo");
  to_json_key(
      j,
      "customSplitInfo",
      p.customSplitInfo,
      "HiveFileSplit",
      "Map<String, String>",
      "customSplitInfo");
  to_json_key(
      j,
      "affinitySchedulingFileSectionIndex",
      p.affinitySchedulingFileSectionIndex,
      "HiveFileSplit",
      "int64_t",
      "affinitySchedulingFileSectionIndex");
}

void from_json(const json& j, HiveFileSplit& p) {
  from_json_key(j, "path", p.path, "HiveFileSplit", "String", "path");
  from_json_key(j, "start", p.start, "HiveFileSplit", "int64_t", "start");
  from_json_key(j, "length", p.length, "HiveFileSplit", "int64_t", "length");
  from_json_key(
      j, "fileSize", p.fileSize, "HiveFileSplit", "int64_t", "fileSize");
  from_json_key(
      j,
      "fileModifiedTime",
      p.fileModifiedTime,
      "HiveFileSplit",
      "int64_t",
      "fileModifiedTime");
  from_json_key(
      j,
      "extraFileInfo",
      p.extraFileInfo,
      "HiveFileSplit",
      "String",
      "extraFileInfo");
  from_json_key(
      j,
      "customSplitInfo",
      p.customSplitInfo,
      "HiveFileSplit",
      "Map<String, String>",
      "customSplitInfo");
  from_json_key(
      j,
      "affinitySchedulingFileSectionIndex",
      p.affinitySchedulingFileSectionIndex,
      "HiveFileSplit",
      "int64_t",
      "affinitySchedulingFileSectionIndex");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<HiveCompressionCodec, json>
    HiveCompressionCodec_enum_table[] = { // NOLINT: cert-err58-cpp
        {HiveCompressionCodec::NONE, "NONE"},
        {HiveCompressionCodec::SNAPPY, "SNAPPY"},
        {HiveCompressionCodec::GZIP, "GZIP"},
        {HiveCompressionCodec::LZ4, "LZ4"},
        {HiveCompressionCodec::ZSTD, "ZSTD"}};
void to_json(json& j, const HiveCompressionCodec& e) {
  static_assert(
      std::is_enum<HiveCompressionCodec>::value,
      "HiveCompressionCodec must be an enum!");
  const auto* it = std::find_if(
      std::begin(HiveCompressionCodec_enum_table),
      std::end(HiveCompressionCodec_enum_table),
      [e](const std::pair<HiveCompressionCodec, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(HiveCompressionCodec_enum_table))
           ? it
           : std::begin(HiveCompressionCodec_enum_table))
          ->second;
}
void from_json(const json& j, HiveCompressionCodec& e) {
  static_assert(
      std::is_enum<HiveCompressionCodec>::value,
      "HiveCompressionCodec must be an enum!");
  const auto* it = std::find_if(
      std::begin(HiveCompressionCodec_enum_table),
      std::end(HiveCompressionCodec_enum_table),
      [&j](const std::pair<HiveCompressionCodec, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(HiveCompressionCodec_enum_table))
           ? it
           : std::begin(HiveCompressionCodec_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<PrestoTableType, json> PrestoTableType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {PrestoTableType::MANAGED_TABLE, "MANAGED_TABLE"},
        {PrestoTableType::EXTERNAL_TABLE, "EXTERNAL_TABLE"},
        {PrestoTableType::VIRTUAL_VIEW, "VIRTUAL_VIEW"},
        {PrestoTableType::MATERIALIZED_VIEW, "MATERIALIZED_VIEW"},
        {PrestoTableType::TEMPORARY_TABLE, "TEMPORARY_TABLE"},
        {PrestoTableType::OTHER, "OTHER"}};
void to_json(json& j, const PrestoTableType& e) {
  static_assert(
      std::is_enum<PrestoTableType>::value, "PrestoTableType must be an enum!");
  const auto* it = std::find_if(
      std::begin(PrestoTableType_enum_table),
      std::end(PrestoTableType_enum_table),
      [e](const std::pair<PrestoTableType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(PrestoTableType_enum_table))
           ? it
           : std::begin(PrestoTableType_enum_table))
          ->second;
}
void from_json(const json& j, PrestoTableType& e) {
  static_assert(
      std::is_enum<PrestoTableType>::value, "PrestoTableType must be an enum!");
  const auto* it = std::find_if(
      std::begin(PrestoTableType_enum_table),
      std::end(PrestoTableType_enum_table),
      [&j](const std::pair<PrestoTableType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(PrestoTableType_enum_table))
           ? it
           : std::begin(PrestoTableType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const StorageFormat& p) {
  j = json::object();
  to_json_key(j, "serDe", p.serDe, "StorageFormat", "String", "serDe");
  to_json_key(
      j,
      "inputFormat",
      p.inputFormat,
      "StorageFormat",
      "String",
      "inputFormat");
  to_json_key(
      j,
      "outputFormat",
      p.outputFormat,
      "StorageFormat",
      "String",
      "outputFormat");
}

void from_json(const json& j, StorageFormat& p) {
  from_json_key(j, "serDe", p.serDe, "StorageFormat", "String", "serDe");
  from_json_key(
      j,
      "inputFormat",
      p.inputFormat,
      "StorageFormat",
      "String",
      "inputFormat");
  from_json_key(
      j,
      "outputFormat",
      p.outputFormat,
      "StorageFormat",
      "String",
      "outputFormat");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const Storage& p) {
  j = json::object();
  to_json_key(
      j,
      "storageFormat",
      p.storageFormat,
      "Storage",
      "StorageFormat",
      "storageFormat");
  to_json_key(j, "location", p.location, "Storage", "String", "location");
  to_json_key(
      j,
      "bucketProperty",
      p.bucketProperty,
      "Storage",
      "HiveBucketProperty",
      "bucketProperty");
  to_json_key(j, "skewed", p.skewed, "Storage", "bool", "skewed");
  to_json_key(
      j,
      "serdeParameters",
      p.serdeParameters,
      "Storage",
      "Map<String, String>",
      "serdeParameters");
  to_json_key(
      j,
      "parameters",
      p.parameters,
      "Storage",
      "Map<String, String>",
      "parameters");
}

void from_json(const json& j, Storage& p) {
  from_json_key(
      j,
      "storageFormat",
      p.storageFormat,
      "Storage",
      "StorageFormat",
      "storageFormat");
  from_json_key(j, "location", p.location, "Storage", "String", "location");
  from_json_key(
      j,
      "bucketProperty",
      p.bucketProperty,
      "Storage",
      "HiveBucketProperty",
      "bucketProperty");
  from_json_key(j, "skewed", p.skewed, "Storage", "bool", "skewed");
  from_json_key(
      j,
      "serdeParameters",
      p.serdeParameters,
      "Storage",
      "Map<String, String>",
      "serdeParameters");
  from_json_key(
      j,
      "parameters",
      p.parameters,
      "Storage",
      "Map<String, String>",
      "parameters");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const Table& p) {
  j = json::object();
  to_json_key(
      j, "catalogName", p.catalogName, "Table", "String", "catalogName");
  to_json_key(
      j, "databaseName", p.databaseName, "Table", "String", "databaseName");
  to_json_key(j, "tableName", p.tableName, "Table", "String", "tableName");
  to_json_key(j, "owner", p.owner, "Table", "String", "owner");
  to_json_key(
      j, "tableType", p.tableType, "Table", "PrestoTableType", "tableType");
  to_json_key(j, "storage", p.storage, "Table", "Storage", "storage");
  to_json_key(
      j, "dataColumns", p.dataColumns, "Table", "List<Column>", "dataColumns");
  to_json_key(
      j,
      "partitionColumns",
      p.partitionColumns,
      "Table",
      "List<Column>",
      "partitionColumns");
  to_json_key(
      j,
      "parameters",
      p.parameters,
      "Table",
      "Map<String, String>",
      "parameters");
  to_json_key(
      j,
      "viewOriginalText",
      p.viewOriginalText,
      "Table",
      "String",
      "viewOriginalText");
  to_json_key(
      j,
      "viewExpandedText",
      p.viewExpandedText,
      "Table",
      "String",
      "viewExpandedText");
}

void from_json(const json& j, Table& p) {
  from_json_key(
      j, "catalogName", p.catalogName, "Table", "String", "catalogName");
  from_json_key(
      j, "databaseName", p.databaseName, "Table", "String", "databaseName");
  from_json_key(j, "tableName", p.tableName, "Table", "String", "tableName");
  from_json_key(j, "owner", p.owner, "Table", "String", "owner");
  from_json_key(
      j, "tableType", p.tableType, "Table", "PrestoTableType", "tableType");
  from_json_key(j, "storage", p.storage, "Table", "Storage", "storage");
  from_json_key(
      j, "dataColumns", p.dataColumns, "Table", "List<Column>", "dataColumns");
  from_json_key(
      j,
      "partitionColumns",
      p.partitionColumns,
      "Table",
      "List<Column>",
      "partitionColumns");
  from_json_key(
      j,
      "parameters",
      p.parameters,
      "Table",
      "Map<String, String>",
      "parameters");
  from_json_key(
      j,
      "viewOriginalText",
      p.viewOriginalText,
      "Table",
      "String",
      "viewOriginalText");
  from_json_key(
      j,
      "viewExpandedText",
      p.viewExpandedText,
      "Table",
      "String",
      "viewExpandedText");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const HivePageSinkMetadata& p) {
  j = json::object();
  to_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "HivePageSinkMetadata",
      "SchemaTableName",
      "schemaTableName");
  to_json_key(j, "table", p.table, "HivePageSinkMetadata", "Table", "table");
}

void from_json(const json& j, HivePageSinkMetadata& p) {
  from_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "HivePageSinkMetadata",
      "SchemaTableName",
      "schemaTableName");
  from_json_key(j, "table", p.table, "HivePageSinkMetadata", "Table", "table");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

static const std::pair<HiveStorageFormat, json> HiveStorageFormat_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {HiveStorageFormat::ORC, "ORC"},
        {HiveStorageFormat::DWRF, "DWRF"},
        {HiveStorageFormat::ALPHA, "ALPHA"},
        {HiveStorageFormat::PARQUET, "PARQUET"},
        {HiveStorageFormat::AVRO, "AVRO"},
        {HiveStorageFormat::RCBINARY, "RCBINARY"},
        {HiveStorageFormat::RCTEXT, "RCTEXT"},
        {HiveStorageFormat::SEQUENCEFILE, "SEQUENCEFILE"},
        {HiveStorageFormat::JSON, "JSON"},
        {HiveStorageFormat::TEXTFILE, "TEXTFILE"},
        {HiveStorageFormat::CSV, "CSV"},
        {HiveStorageFormat::PAGEFILE, "PAGEFILE"}};

void to_json(json& j, const HiveStorageFormat& p) {
  static_assert(
      std::is_enum<HiveStorageFormat>::value,
      "HiveStorageFormat must be an enum!");
  const auto* it = std::find_if(
      std::begin(HiveStorageFormat_enum_table),
      std::end(HiveStorageFormat_enum_table),
      [&p](const std::pair<HiveStorageFormat, json>& ej_pair) -> bool {
        return ej_pair.first == p;
      });
  j = ((it != std::end(HiveStorageFormat_enum_table))
           ? it
           : std::begin(HiveStorageFormat_enum_table))
          ->second;
}

void from_json(const json& j, HiveStorageFormat& e) {
  static_assert(
      std::is_enum<HiveStorageFormat>::value,
      "HiveStorageFormat must be an enum!");
  const auto* it = std::find_if(
      std::begin(HiveStorageFormat_enum_table),
      std::end(HiveStorageFormat_enum_table),
      [&j](const std::pair<HiveStorageFormat, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(HiveStorageFormat_enum_table))
           ? it
           : std::begin(HiveStorageFormat_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<TableType, json> TableType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {TableType::NEW, "NEW"},
        {TableType::EXISTING, "EXISTING"},
        {TableType::TEMPORARY, "TEMPORARY"}};
void to_json(json& j, const TableType& e) {
  static_assert(std::is_enum<TableType>::value, "TableType must be an enum!");
  const auto* it = std::find_if(
      std::begin(TableType_enum_table),
      std::end(TableType_enum_table),
      [e](const std::pair<TableType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(TableType_enum_table))
           ? it
           : std::begin(TableType_enum_table))
          ->second;
}
void from_json(const json& j, TableType& e) {
  static_assert(std::is_enum<TableType>::value, "TableType must be an enum!");
  const auto* it = std::find_if(
      std::begin(TableType_enum_table),
      std::end(TableType_enum_table),
      [&j](const std::pair<TableType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(TableType_enum_table))
           ? it
           : std::begin(TableType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<WriteMode, json> WriteMode_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {WriteMode::STAGE_AND_MOVE_TO_TARGET_DIRECTORY,
         "STAGE_AND_MOVE_TO_TARGET_DIRECTORY"},
        {WriteMode::DIRECT_TO_TARGET_NEW_DIRECTORY,
         "DIRECT_TO_TARGET_NEW_DIRECTORY"},
        {WriteMode::DIRECT_TO_TARGET_EXISTING_DIRECTORY,
         "DIRECT_TO_TARGET_EXISTING_DIRECTORY"}};
void to_json(json& j, const WriteMode& e) {
  static_assert(std::is_enum<WriteMode>::value, "WriteMode must be an enum!");
  const auto* it = std::find_if(
      std::begin(WriteMode_enum_table),
      std::end(WriteMode_enum_table),
      [e](const std::pair<WriteMode, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(WriteMode_enum_table))
           ? it
           : std::begin(WriteMode_enum_table))
          ->second;
}
void from_json(const json& j, WriteMode& e) {
  static_assert(std::is_enum<WriteMode>::value, "WriteMode must be an enum!");
  const auto* it = std::find_if(
      std::begin(WriteMode_enum_table),
      std::end(WriteMode_enum_table),
      [&j](const std::pair<WriteMode, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(WriteMode_enum_table))
           ? it
           : std::begin(WriteMode_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const LocationHandle& p) {
  j = json::object();
  to_json_key(
      j, "targetPath", p.targetPath, "LocationHandle", "String", "targetPath");
  to_json_key(
      j, "writePath", p.writePath, "LocationHandle", "String", "writePath");
  to_json_key(
      j, "tempPath", p.tempPath, "LocationHandle", "String", "tempPath");
  to_json_key(
      j, "tableType", p.tableType, "LocationHandle", "TableType", "tableType");
  to_json_key(
      j, "writeMode", p.writeMode, "LocationHandle", "WriteMode", "writeMode");
}

void from_json(const json& j, LocationHandle& p) {
  from_json_key(
      j, "targetPath", p.targetPath, "LocationHandle", "String", "targetPath");
  from_json_key(
      j, "writePath", p.writePath, "LocationHandle", "String", "writePath");
  from_json_key(
      j, "tempPath", p.tempPath, "LocationHandle", "String", "tempPath");
  from_json_key(
      j, "tableType", p.tableType, "LocationHandle", "TableType", "tableType");
  from_json_key(
      j, "writeMode", p.writeMode, "LocationHandle", "WriteMode", "writeMode");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
HiveInsertTableHandle::HiveInsertTableHandle() noexcept {
  _type = "hive";
}

void to_json(json& j, const HiveInsertTableHandle& p) {
  j = json::object();
  j["@type"] = "hive";
  to_json_key(
      j,
      "schemaName",
      p.schemaName,
      "HiveInsertTableHandle",
      "String",
      "schemaName");
  to_json_key(
      j,
      "tableName",
      p.tableName,
      "HiveInsertTableHandle",
      "String",
      "tableName");
  to_json_key(
      j,
      "inputColumns",
      p.inputColumns,
      "HiveInsertTableHandle",
      "List<HiveColumnHandle>",
      "inputColumns");
  to_json_key(
      j,
      "pageSinkMetadata",
      p.pageSinkMetadata,
      "HiveInsertTableHandle",
      "HivePageSinkMetadata",
      "pageSinkMetadata");
  to_json_key(
      j,
      "locationHandle",
      p.locationHandle,
      "HiveInsertTableHandle",
      "LocationHandle",
      "locationHandle");
  to_json_key(
      j,
      "bucketProperty",
      p.bucketProperty,
      "HiveInsertTableHandle",
      "HiveBucketProperty",
      "bucketProperty");
  to_json_key(
      j,
      "preferredOrderingColumns",
      p.preferredOrderingColumns,
      "HiveInsertTableHandle",
      "List<SortingColumn>",
      "preferredOrderingColumns");
  to_json_key(
      j,
      "tableStorageFormat",
      p.tableStorageFormat,
      "HiveInsertTableHandle",
      "HiveStorageFormat",
      "tableStorageFormat");
  to_json_key(
      j,
      "partitionStorageFormat",
      p.partitionStorageFormat,
      "HiveInsertTableHandle",
      "HiveStorageFormat",
      "partitionStorageFormat");
  to_json_key(
      j,
      "actualStorageFormat",
      p.actualStorageFormat,
      "HiveInsertTableHandle",
      "HiveStorageFormat",
      "actualStorageFormat");
  to_json_key(
      j,
      "compressionCodec",
      p.compressionCodec,
      "HiveInsertTableHandle",
      "HiveCompressionCodec",
      "compressionCodec");
  to_json_key(
      j,
      "encryptionInformation",
      p.encryptionInformation,
      "HiveInsertTableHandle",
      "EncryptionInformation",
      "encryptionInformation");
}

void from_json(const json& j, HiveInsertTableHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "schemaName",
      p.schemaName,
      "HiveInsertTableHandle",
      "String",
      "schemaName");
  from_json_key(
      j,
      "tableName",
      p.tableName,
      "HiveInsertTableHandle",
      "String",
      "tableName");
  from_json_key(
      j,
      "inputColumns",
      p.inputColumns,
      "HiveInsertTableHandle",
      "List<HiveColumnHandle>",
      "inputColumns");
  from_json_key(
      j,
      "pageSinkMetadata",
      p.pageSinkMetadata,
      "HiveInsertTableHandle",
      "HivePageSinkMetadata",
      "pageSinkMetadata");
  from_json_key(
      j,
      "locationHandle",
      p.locationHandle,
      "HiveInsertTableHandle",
      "LocationHandle",
      "locationHandle");
  from_json_key(
      j,
      "bucketProperty",
      p.bucketProperty,
      "HiveInsertTableHandle",
      "HiveBucketProperty",
      "bucketProperty");
  from_json_key(
      j,
      "preferredOrderingColumns",
      p.preferredOrderingColumns,
      "HiveInsertTableHandle",
      "List<SortingColumn>",
      "preferredOrderingColumns");
  from_json_key(
      j,
      "tableStorageFormat",
      p.tableStorageFormat,
      "HiveInsertTableHandle",
      "HiveStorageFormat",
      "tableStorageFormat");
  from_json_key(
      j,
      "partitionStorageFormat",
      p.partitionStorageFormat,
      "HiveInsertTableHandle",
      "HiveStorageFormat",
      "partitionStorageFormat");
  from_json_key(
      j,
      "actualStorageFormat",
      p.actualStorageFormat,
      "HiveInsertTableHandle",
      "HiveStorageFormat",
      "actualStorageFormat");
  from_json_key(
      j,
      "compressionCodec",
      p.compressionCodec,
      "HiveInsertTableHandle",
      "HiveCompressionCodec",
      "compressionCodec");
  from_json_key(
      j,
      "encryptionInformation",
      p.encryptionInformation,
      "HiveInsertTableHandle",
      "EncryptionInformation",
      "encryptionInformation");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
HiveOutputTableHandle::HiveOutputTableHandle() noexcept {
  _type = "hive";
}

void to_json(json& j, const HiveOutputTableHandle& p) {
  j = json::object();
  j["@type"] = "hive";
  to_json_key(
      j,
      "schemaName",
      p.schemaName,
      "HiveOutputTableHandle",
      "String",
      "schemaName");
  to_json_key(
      j,
      "tableName",
      p.tableName,
      "HiveOutputTableHandle",
      "String",
      "tableName");
  to_json_key(
      j,
      "inputColumns",
      p.inputColumns,
      "HiveOutputTableHandle",
      "List<HiveColumnHandle>",
      "inputColumns");
  to_json_key(
      j,
      "pageSinkMetadata",
      p.pageSinkMetadata,
      "HiveOutputTableHandle",
      "HivePageSinkMetadata",
      "pageSinkMetadata");
  to_json_key(
      j,
      "locationHandle",
      p.locationHandle,
      "HiveOutputTableHandle",
      "LocationHandle",
      "locationHandle");
  to_json_key(
      j,
      "tableStorageFormat",
      p.tableStorageFormat,
      "HiveOutputTableHandle",
      "HiveStorageFormat",
      "tableStorageFormat");
  to_json_key(
      j,
      "partitionStorageFormat",
      p.partitionStorageFormat,
      "HiveOutputTableHandle",
      "HiveStorageFormat",
      "partitionStorageFormat");
  to_json_key(
      j,
      "actualStorageFormat",
      p.actualStorageFormat,
      "HiveOutputTableHandle",
      "HiveStorageFormat",
      "actualStorageFormat");
  to_json_key(
      j,
      "compressionCodec",
      p.compressionCodec,
      "HiveOutputTableHandle",
      "HiveCompressionCodec",
      "compressionCodec");
  to_json_key(
      j,
      "partitionedBy",
      p.partitionedBy,
      "HiveOutputTableHandle",
      "List<String>",
      "partitionedBy");
  to_json_key(
      j,
      "bucketProperty",
      p.bucketProperty,
      "HiveOutputTableHandle",
      "HiveBucketProperty",
      "bucketProperty");
  to_json_key(
      j,
      "preferredOrderingColumns",
      p.preferredOrderingColumns,
      "HiveOutputTableHandle",
      "List<SortingColumn>",
      "preferredOrderingColumns");
  to_json_key(
      j,
      "tableOwner",
      p.tableOwner,
      "HiveOutputTableHandle",
      "String",
      "tableOwner");
  to_json_key(
      j,
      "additionalTableParameters",
      p.additionalTableParameters,
      "HiveOutputTableHandle",
      "Map<String, String>",
      "additionalTableParameters");
  to_json_key(
      j,
      "encryptionInformation",
      p.encryptionInformation,
      "HiveOutputTableHandle",
      "EncryptionInformation",
      "encryptionInformation");
}

void from_json(const json& j, HiveOutputTableHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "schemaName",
      p.schemaName,
      "HiveOutputTableHandle",
      "String",
      "schemaName");
  from_json_key(
      j,
      "tableName",
      p.tableName,
      "HiveOutputTableHandle",
      "String",
      "tableName");
  from_json_key(
      j,
      "inputColumns",
      p.inputColumns,
      "HiveOutputTableHandle",
      "List<HiveColumnHandle>",
      "inputColumns");
  from_json_key(
      j,
      "pageSinkMetadata",
      p.pageSinkMetadata,
      "HiveOutputTableHandle",
      "HivePageSinkMetadata",
      "pageSinkMetadata");
  from_json_key(
      j,
      "locationHandle",
      p.locationHandle,
      "HiveOutputTableHandle",
      "LocationHandle",
      "locationHandle");
  from_json_key(
      j,
      "tableStorageFormat",
      p.tableStorageFormat,
      "HiveOutputTableHandle",
      "HiveStorageFormat",
      "tableStorageFormat");
  from_json_key(
      j,
      "partitionStorageFormat",
      p.partitionStorageFormat,
      "HiveOutputTableHandle",
      "HiveStorageFormat",
      "partitionStorageFormat");
  from_json_key(
      j,
      "actualStorageFormat",
      p.actualStorageFormat,
      "HiveOutputTableHandle",
      "HiveStorageFormat",
      "actualStorageFormat");
  from_json_key(
      j,
      "compressionCodec",
      p.compressionCodec,
      "HiveOutputTableHandle",
      "HiveCompressionCodec",
      "compressionCodec");
  from_json_key(
      j,
      "partitionedBy",
      p.partitionedBy,
      "HiveOutputTableHandle",
      "List<String>",
      "partitionedBy");
  from_json_key(
      j,
      "bucketProperty",
      p.bucketProperty,
      "HiveOutputTableHandle",
      "HiveBucketProperty",
      "bucketProperty");
  from_json_key(
      j,
      "preferredOrderingColumns",
      p.preferredOrderingColumns,
      "HiveOutputTableHandle",
      "List<SortingColumn>",
      "preferredOrderingColumns");
  from_json_key(
      j,
      "tableOwner",
      p.tableOwner,
      "HiveOutputTableHandle",
      "String",
      "tableOwner");
  from_json_key(
      j,
      "additionalTableParameters",
      p.additionalTableParameters,
      "HiveOutputTableHandle",
      "Map<String, String>",
      "additionalTableParameters");
  from_json_key(
      j,
      "encryptionInformation",
      p.encryptionInformation,
      "HiveOutputTableHandle",
      "EncryptionInformation",
      "encryptionInformation");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const HivePartitionKey& p) {
  j = json::object();
  to_json_key(j, "name", p.name, "HivePartitionKey", "String", "name");
  to_json_key(j, "value", p.value, "HivePartitionKey", "String", "value");
}

void from_json(const json& j, HivePartitionKey& p) {
  from_json_key(j, "name", p.name, "HivePartitionKey", "String", "name");
  from_json_key(j, "value", p.value, "HivePartitionKey", "String", "value");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
HivePartitioningHandle::HivePartitioningHandle() noexcept {
  _type = "hive";
}

void to_json(json& j, const HivePartitioningHandle& p) {
  j = json::object();
  j["@type"] = "hive";
  to_json_key(
      j,
      "bucketCount",
      p.bucketCount,
      "HivePartitioningHandle",
      "int",
      "bucketCount");
  to_json_key(
      j,
      "maxCompatibleBucketCount",
      p.maxCompatibleBucketCount,
      "HivePartitioningHandle",
      "int",
      "maxCompatibleBucketCount");
  to_json_key(
      j,
      "bucketFunctionType",
      p.bucketFunctionType,
      "HivePartitioningHandle",
      "BucketFunctionType",
      "bucketFunctionType");
  to_json_key(
      j,
      "hiveTypes",
      p.hiveTypes,
      "HivePartitioningHandle",
      "List<HiveType>",
      "hiveTypes");
  to_json_key(
      j, "types", p.types, "HivePartitioningHandle", "List<Type>", "types");
}

void from_json(const json& j, HivePartitioningHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "bucketCount",
      p.bucketCount,
      "HivePartitioningHandle",
      "int",
      "bucketCount");
  from_json_key(
      j,
      "maxCompatibleBucketCount",
      p.maxCompatibleBucketCount,
      "HivePartitioningHandle",
      "int",
      "maxCompatibleBucketCount");
  from_json_key(
      j,
      "bucketFunctionType",
      p.bucketFunctionType,
      "HivePartitioningHandle",
      "BucketFunctionType",
      "bucketFunctionType");
  from_json_key(
      j,
      "hiveTypes",
      p.hiveTypes,
      "HivePartitioningHandle",
      "List<HiveType>",
      "hiveTypes");
  from_json_key(
      j, "types", p.types, "HivePartitioningHandle", "List<Type>", "types");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
void to_json(json& j, const std::shared_ptr<ColumnHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "hive") {
    j = *std::static_pointer_cast<HiveColumnHandle>(p);
    return;
  }

  throw TypeError(type + " no abstract type ColumnHandle ");
}

void from_json(const json& j, std::shared_ptr<ColumnHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " ColumnHandle  ColumnHandle");
  }

  if (type == "hive") {
    std::shared_ptr<HiveColumnHandle> k = std::make_shared<HiveColumnHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ColumnHandle>(k);
    return;
  }

  throw TypeError(type + " no abstract type ColumnHandle ");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {

void to_json(json& j, const TableToPartitionMapping& p) {
  j = json::object();
  to_json_key(
      j,
      "tableToPartitionColumns",
      p.tableToPartitionColumns,
      "TableToPartitionMapping",
      "Map<Integer, Integer>",
      "tableToPartitionColumns");
  to_json_key(
      j,
      "partitionSchemaDifference",
      p.partitionSchemaDifference,
      "TableToPartitionMapping",
      "Map<Integer, Column>",
      "partitionSchemaDifference");
}

void from_json(const json& j, TableToPartitionMapping& p) {
  from_json_key(
      j,
      "tableToPartitionColumns",
      p.tableToPartitionColumns,
      "TableToPartitionMapping",
      "Map<Integer, Integer>",
      "tableToPartitionColumns");
  from_json_key(
      j,
      "partitionSchemaDifference",
      p.partitionSchemaDifference,
      "TableToPartitionMapping",
      "Map<Integer, Column>",
      "partitionSchemaDifference");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
HiveSplit::HiveSplit() noexcept {
  _type = "hive";
}

void to_json(json& j, const HiveSplit& p) {
  j = json::object();
  j["@type"] = "hive";
  to_json_key(
      j, "fileSplit", p.fileSplit, "HiveSplit", "HiveFileSplit", "fileSplit");
  to_json_key(j, "database", p.database, "HiveSplit", "String", "database");
  to_json_key(j, "table", p.table, "HiveSplit", "String", "table");
  to_json_key(
      j,
      "partitionName",
      p.partitionName,
      "HiveSplit",
      "String",
      "partitionName");
  to_json_key(j, "storage", p.storage, "HiveSplit", "Storage", "storage");
  to_json_key(
      j,
      "partitionKeys",
      p.partitionKeys,
      "HiveSplit",
      "List<HivePartitionKey>",
      "partitionKeys");
  to_json_key(
      j,
      "addresses",
      p.addresses,
      "HiveSplit",
      "List<HostAddress>",
      "addresses");
  to_json_key(
      j,
      "readBucketNumber",
      p.readBucketNumber,
      "HiveSplit",
      "int",
      "readBucketNumber");
  to_json_key(
      j,
      "tableBucketNumber",
      p.tableBucketNumber,
      "HiveSplit",
      "int",
      "tableBucketNumber");
  to_json_key(
      j,
      "nodeSelectionStrategy",
      p.nodeSelectionStrategy,
      "HiveSplit",
      "NodeSelectionStrategy",
      "nodeSelectionStrategy");
  to_json_key(
      j,
      "partitionDataColumnCount",
      p.partitionDataColumnCount,
      "HiveSplit",
      "int",
      "partitionDataColumnCount");
  to_json_key(
      j,
      "tableToPartitionMapping",
      p.tableToPartitionMapping,
      "HiveSplit",
      "TableToPartitionMapping",
      "tableToPartitionMapping");
  to_json_key(
      j,
      "bucketConversion",
      p.bucketConversion,
      "HiveSplit",
      "BucketConversion",
      "bucketConversion");
  to_json_key(
      j,
      "s3SelectPushdownEnabled",
      p.s3SelectPushdownEnabled,
      "HiveSplit",
      "bool",
      "s3SelectPushdownEnabled");
  to_json_key(
      j,
      "cacheQuota",
      p.cacheQuota,
      "HiveSplit",
      "CacheQuotaRequirement",
      "cacheQuota");
  to_json_key(
      j,
      "encryptionMetadata",
      p.encryptionMetadata,
      "HiveSplit",
      "EncryptionInformation",
      "encryptionMetadata");
  to_json_key(
      j,
      "redundantColumnDomains",
      p.redundantColumnDomains,
      "HiveSplit",
      "List<std::shared_ptr<ColumnHandle>>",
      "redundantColumnDomains");
  to_json_key(
      j,
      "splitWeight",
      p.splitWeight,
      "HiveSplit",
      "SplitWeight",
      "splitWeight");
  to_json_key(
      j,
      "rowIdPartitionComponent",
      p.rowIdPartitionComponent,
      "HiveSplit",
      "String",
      "rowIdPartitionComponent");
}

void from_json(const json& j, HiveSplit& p) {
  p._type = j["@type"];
  from_json_key(
      j, "fileSplit", p.fileSplit, "HiveSplit", "HiveFileSplit", "fileSplit");
  from_json_key(j, "database", p.database, "HiveSplit", "String", "database");
  from_json_key(j, "table", p.table, "HiveSplit", "String", "table");
  from_json_key(
      j,
      "partitionName",
      p.partitionName,
      "HiveSplit",
      "String",
      "partitionName");
  from_json_key(j, "storage", p.storage, "HiveSplit", "Storage", "storage");
  from_json_key(
      j,
      "partitionKeys",
      p.partitionKeys,
      "HiveSplit",
      "List<HivePartitionKey>",
      "partitionKeys");
  from_json_key(
      j,
      "addresses",
      p.addresses,
      "HiveSplit",
      "List<HostAddress>",
      "addresses");
  from_json_key(
      j,
      "readBucketNumber",
      p.readBucketNumber,
      "HiveSplit",
      "int",
      "readBucketNumber");
  from_json_key(
      j,
      "tableBucketNumber",
      p.tableBucketNumber,
      "HiveSplit",
      "int",
      "tableBucketNumber");
  from_json_key(
      j,
      "nodeSelectionStrategy",
      p.nodeSelectionStrategy,
      "HiveSplit",
      "NodeSelectionStrategy",
      "nodeSelectionStrategy");
  from_json_key(
      j,
      "partitionDataColumnCount",
      p.partitionDataColumnCount,
      "HiveSplit",
      "int",
      "partitionDataColumnCount");
  from_json_key(
      j,
      "tableToPartitionMapping",
      p.tableToPartitionMapping,
      "HiveSplit",
      "TableToPartitionMapping",
      "tableToPartitionMapping");
  from_json_key(
      j,
      "bucketConversion",
      p.bucketConversion,
      "HiveSplit",
      "BucketConversion",
      "bucketConversion");
  from_json_key(
      j,
      "s3SelectPushdownEnabled",
      p.s3SelectPushdownEnabled,
      "HiveSplit",
      "bool",
      "s3SelectPushdownEnabled");
  from_json_key(
      j,
      "cacheQuota",
      p.cacheQuota,
      "HiveSplit",
      "CacheQuotaRequirement",
      "cacheQuota");
  from_json_key(
      j,
      "encryptionMetadata",
      p.encryptionMetadata,
      "HiveSplit",
      "EncryptionInformation",
      "encryptionMetadata");
  from_json_key(
      j,
      "redundantColumnDomains",
      p.redundantColumnDomains,
      "HiveSplit",
      "List<std::shared_ptr<ColumnHandle>>",
      "redundantColumnDomains");
  from_json_key(
      j,
      "splitWeight",
      p.splitWeight,
      "HiveSplit",
      "SplitWeight",
      "splitWeight");
  from_json_key(
      j,
      "rowIdPartitionComponent",
      p.rowIdPartitionComponent,
      "HiveSplit",
      "String",
      "rowIdPartitionComponent");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
HiveTableHandle::HiveTableHandle() noexcept {
  _type = "hive";
}

void to_json(json& j, const HiveTableHandle& p) {
  j = json::object();
  j["@type"] = "hive";
  to_json_key(
      j, "schemaName", p.schemaName, "HiveTableHandle", "String", "schemaName");
  to_json_key(
      j, "tableName", p.tableName, "HiveTableHandle", "String", "tableName");
  to_json_key(
      j,
      "analyzePartitionValues",
      p.analyzePartitionValues,
      "HiveTableHandle",
      "List<List<String>>",
      "analyzePartitionValues");
}

void from_json(const json& j, HiveTableHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j, "schemaName", p.schemaName, "HiveTableHandle", "String", "schemaName");
  from_json_key(
      j, "tableName", p.tableName, "HiveTableHandle", "String", "tableName");
  from_json_key(
      j,
      "analyzePartitionValues",
      p.analyzePartitionValues,
      "HiveTableHandle",
      "List<List<String>>",
      "analyzePartitionValues");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
HiveTableLayoutHandle::HiveTableLayoutHandle() noexcept {
  _type = "hive";
}

void to_json(json& j, const HiveTableLayoutHandle& p) {
  j = json::object();
  j["@type"] = "hive";
  to_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "HiveTableLayoutHandle",
      "SchemaTableName",
      "schemaTableName");
  to_json_key(
      j,
      "tablePath",
      p.tablePath,
      "HiveTableLayoutHandle",
      "String",
      "tablePath");
  to_json_key(
      j,
      "partitionColumns",
      p.partitionColumns,
      "HiveTableLayoutHandle",
      "List<HiveColumnHandle>",
      "partitionColumns");
  to_json_key(
      j,
      "dataColumns",
      p.dataColumns,
      "HiveTableLayoutHandle",
      "List<Column>",
      "dataColumns");
  to_json_key(
      j,
      "tableParameters",
      p.tableParameters,
      "HiveTableLayoutHandle",
      "Map<String, String>",
      "tableParameters");
  to_json_key(
      j,
      "domainPredicate",
      p.domainPredicate,
      "HiveTableLayoutHandle",
      "TupleDomain<Subfield>",
      "domainPredicate");
  to_json_key(
      j,
      "remainingPredicate",
      p.remainingPredicate,
      "HiveTableLayoutHandle",
      "std::shared_ptr<RowExpression>",
      "remainingPredicate");
  to_json_key(
      j,
      "predicateColumns",
      p.predicateColumns,
      "HiveTableLayoutHandle",
      "Map<String, HiveColumnHandle>",
      "predicateColumns");
  to_json_key(
      j,
      "partitionColumnPredicate",
      p.partitionColumnPredicate,
      "HiveTableLayoutHandle",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "partitionColumnPredicate");
  to_json_key(
      j,
      "bucketHandle",
      p.bucketHandle,
      "HiveTableLayoutHandle",
      "HiveBucketHandle",
      "bucketHandle");
  to_json_key(
      j,
      "bucketFilter",
      p.bucketFilter,
      "HiveTableLayoutHandle",
      "HiveBucketFilter",
      "bucketFilter");
  to_json_key(
      j,
      "pushdownFilterEnabled",
      p.pushdownFilterEnabled,
      "HiveTableLayoutHandle",
      "bool",
      "pushdownFilterEnabled");
  to_json_key(
      j,
      "layoutString",
      p.layoutString,
      "HiveTableLayoutHandle",
      "String",
      "layoutString");
  to_json_key(
      j,
      "requestedColumns",
      p.requestedColumns,
      "HiveTableLayoutHandle",
      "List<HiveColumnHandle>",
      "requestedColumns");
  to_json_key(
      j,
      "partialAggregationsPushedDown",
      p.partialAggregationsPushedDown,
      "HiveTableLayoutHandle",
      "bool",
      "partialAggregationsPushedDown");
  to_json_key(
      j,
      "appendRowNumber",
      p.appendRowNumber,
      "HiveTableLayoutHandle",
      "bool",
      "appendRowNumber");
  to_json_key(
      j,
      "footerStatsUnreliable",
      p.footerStatsUnreliable,
      "HiveTableLayoutHandle",
      "bool",
      "footerStatsUnreliable");
}

void from_json(const json& j, HiveTableLayoutHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "HiveTableLayoutHandle",
      "SchemaTableName",
      "schemaTableName");
  from_json_key(
      j,
      "tablePath",
      p.tablePath,
      "HiveTableLayoutHandle",
      "String",
      "tablePath");
  from_json_key(
      j,
      "partitionColumns",
      p.partitionColumns,
      "HiveTableLayoutHandle",
      "List<HiveColumnHandle>",
      "partitionColumns");
  from_json_key(
      j,
      "dataColumns",
      p.dataColumns,
      "HiveTableLayoutHandle",
      "List<Column>",
      "dataColumns");
  from_json_key(
      j,
      "tableParameters",
      p.tableParameters,
      "HiveTableLayoutHandle",
      "Map<String, String>",
      "tableParameters");
  from_json_key(
      j,
      "domainPredicate",
      p.domainPredicate,
      "HiveTableLayoutHandle",
      "TupleDomain<Subfield>",
      "domainPredicate");
  from_json_key(
      j,
      "remainingPredicate",
      p.remainingPredicate,
      "HiveTableLayoutHandle",
      "std::shared_ptr<RowExpression>",
      "remainingPredicate");
  from_json_key(
      j,
      "predicateColumns",
      p.predicateColumns,
      "HiveTableLayoutHandle",
      "Map<String, HiveColumnHandle>",
      "predicateColumns");
  from_json_key(
      j,
      "partitionColumnPredicate",
      p.partitionColumnPredicate,
      "HiveTableLayoutHandle",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "partitionColumnPredicate");
  from_json_key(
      j,
      "bucketHandle",
      p.bucketHandle,
      "HiveTableLayoutHandle",
      "HiveBucketHandle",
      "bucketHandle");
  from_json_key(
      j,
      "bucketFilter",
      p.bucketFilter,
      "HiveTableLayoutHandle",
      "HiveBucketFilter",
      "bucketFilter");
  from_json_key(
      j,
      "pushdownFilterEnabled",
      p.pushdownFilterEnabled,
      "HiveTableLayoutHandle",
      "bool",
      "pushdownFilterEnabled");
  from_json_key(
      j,
      "layoutString",
      p.layoutString,
      "HiveTableLayoutHandle",
      "String",
      "layoutString");
  from_json_key(
      j,
      "requestedColumns",
      p.requestedColumns,
      "HiveTableLayoutHandle",
      "List<HiveColumnHandle>",
      "requestedColumns");
  from_json_key(
      j,
      "partialAggregationsPushedDown",
      p.partialAggregationsPushedDown,
      "HiveTableLayoutHandle",
      "bool",
      "partialAggregationsPushedDown");
  from_json_key(
      j,
      "appendRowNumber",
      p.appendRowNumber,
      "HiveTableLayoutHandle",
      "bool",
      "appendRowNumber");
  from_json_key(
      j,
      "footerStatsUnreliable",
      p.footerStatsUnreliable,
      "HiveTableLayoutHandle",
      "bool",
      "footerStatsUnreliable");
}
} // namespace facebook::presto::protocol::hive
namespace facebook::presto::protocol::hive {
HiveTransactionHandle::HiveTransactionHandle() noexcept {
  _type = "hive";
}

void to_json(json& j, const HiveTransactionHandle& p) {
  j = json::object();
  j["@type"] = "hive";
  to_json_key(j, "uuid", p.uuid, "HiveTransactionHandle", "UUID", "uuid");
}

void from_json(const json& j, HiveTransactionHandle& p) {
  p._type = j["@type"];
  from_json_key(j, "uuid", p.uuid, "HiveTransactionHandle", "UUID", "uuid");
}
} // namespace facebook::presto::protocol::hive
