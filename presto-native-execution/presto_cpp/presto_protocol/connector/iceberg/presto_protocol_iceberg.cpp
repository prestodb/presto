// DO NOT EDIT : This file is generated by chevron
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// presto_protocol.prolog.cpp
//

// This file is generated DO NOT EDIT @generated

#include "presto_cpp/presto_protocol/connector/iceberg/presto_protocol_iceberg.h"
using namespace std::string_literals;

namespace facebook::presto::protocol::iceberg {
// Loosly copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<ChangelogOperation, json>
    ChangelogOperation_enum_table[] = { // NOLINT: cert-err58-cpp
        {ChangelogOperation::INSERT, "INSERT"},
        {ChangelogOperation::DELETE, "DELETE"},
        {ChangelogOperation::UPDATE_BEFORE, "UPDATE_BEFORE"},
        {ChangelogOperation::UPDATE_AFTER, "UPDATE_AFTER"}};
void to_json(json& j, const ChangelogOperation& e) {
  static_assert(
      std::is_enum<ChangelogOperation>::value,
      "ChangelogOperation must be an enum!");
  const auto* it = std::find_if(
      std::begin(ChangelogOperation_enum_table),
      std::end(ChangelogOperation_enum_table),
      [e](const std::pair<ChangelogOperation, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(ChangelogOperation_enum_table))
           ? it
           : std::begin(ChangelogOperation_enum_table))
          ->second;
}
void from_json(const json& j, ChangelogOperation& e) {
  static_assert(
      std::is_enum<ChangelogOperation>::value,
      "ChangelogOperation must be an enum!");
  const auto* it = std::find_if(
      std::begin(ChangelogOperation_enum_table),
      std::end(ChangelogOperation_enum_table),
      [&j](const std::pair<ChangelogOperation, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(ChangelogOperation_enum_table))
           ? it
           : std::begin(ChangelogOperation_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {
// Loosly copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<TypeCategory, json> TypeCategory_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {TypeCategory::PRIMITIVE, "PRIMITIVE"},
        {TypeCategory::STRUCT, "STRUCT"},
        {TypeCategory::ARRAY, "ARRAY"},
        {TypeCategory::MAP, "MAP"}};
void to_json(json& j, const TypeCategory& e) {
  static_assert(
      std::is_enum<TypeCategory>::value, "TypeCategory must be an enum!");
  const auto* it = std::find_if(
      std::begin(TypeCategory_enum_table),
      std::end(TypeCategory_enum_table),
      [e](const std::pair<TypeCategory, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(TypeCategory_enum_table))
           ? it
           : std::begin(TypeCategory_enum_table))
          ->second;
}
void from_json(const json& j, TypeCategory& e) {
  static_assert(
      std::is_enum<TypeCategory>::value, "TypeCategory must be an enum!");
  const auto* it = std::find_if(
      std::begin(TypeCategory_enum_table),
      std::end(TypeCategory_enum_table),
      [&j](const std::pair<TypeCategory, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(TypeCategory_enum_table))
           ? it
           : std::begin(TypeCategory_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {

void to_json(json& j, const ColumnIdentity& p) {
  j = json::object();
  to_json_key(j, "id", p.id, "ColumnIdentity", "int", "id");
  to_json_key(j, "name", p.name, "ColumnIdentity", "String", "name");
  to_json_key(
      j,
      "typeCategory",
      p.typeCategory,
      "ColumnIdentity",
      "TypeCategory",
      "typeCategory");
  to_json_key(
      j,
      "children",
      p.children,
      "ColumnIdentity",
      "List<ColumnIdentity>",
      "children");
}

void from_json(const json& j, ColumnIdentity& p) {
  from_json_key(j, "id", p.id, "ColumnIdentity", "int", "id");
  from_json_key(j, "name", p.name, "ColumnIdentity", "String", "name");
  from_json_key(
      j,
      "typeCategory",
      p.typeCategory,
      "ColumnIdentity",
      "TypeCategory",
      "typeCategory");
  from_json_key(
      j,
      "children",
      p.children,
      "ColumnIdentity",
      "List<ColumnIdentity>",
      "children");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {
IcebergColumnHandle::IcebergColumnHandle() noexcept {
  _type = "hive-iceberg";
}

void to_json(json& j, const IcebergColumnHandle& p) {
  j = json::object();
  j["@type"] = "hive-iceberg";
  to_json_key(
      j,
      "columnIdentity",
      p.columnIdentity,
      "IcebergColumnHandle",
      "ColumnIdentity",
      "columnIdentity");
  to_json_key(j, "type", p.type, "IcebergColumnHandle", "Type", "type");
  to_json_key(
      j, "comment", p.comment, "IcebergColumnHandle", "String", "comment");
  to_json_key(
      j,
      "columnType",
      p.columnType,
      "IcebergColumnHandle",
      "ColumnType",
      "columnType");
  to_json_key(
      j,
      "requiredSubfields",
      p.requiredSubfields,
      "IcebergColumnHandle",
      "List<Subfield>",
      "requiredSubfields");
}

void from_json(const json& j, IcebergColumnHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "columnIdentity",
      p.columnIdentity,
      "IcebergColumnHandle",
      "ColumnIdentity",
      "columnIdentity");
  from_json_key(j, "type", p.type, "IcebergColumnHandle", "Type", "type");
  from_json_key(
      j, "comment", p.comment, "IcebergColumnHandle", "String", "comment");
  from_json_key(
      j,
      "columnType",
      p.columnType,
      "IcebergColumnHandle",
      "ColumnType",
      "columnType");
  from_json_key(
      j,
      "requiredSubfields",
      p.requiredSubfields,
      "IcebergColumnHandle",
      "List<Subfield>",
      "requiredSubfields");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {

void to_json(json& j, const ChangelogSplitInfo& p) {
  j = json::object();
  to_json_key(
      j,
      "operation",
      p.operation,
      "ChangelogSplitInfo",
      "ChangelogOperation",
      "operation");
  to_json_key(
      j, "ordinal", p.ordinal, "ChangelogSplitInfo", "int64_t", "ordinal");
  to_json_key(
      j,
      "snapshotId",
      p.snapshotId,
      "ChangelogSplitInfo",
      "int64_t",
      "snapshotId");
  to_json_key(
      j,
      "icebergColumns",
      p.icebergColumns,
      "ChangelogSplitInfo",
      "List<IcebergColumnHandle>",
      "icebergColumns");
}

void from_json(const json& j, ChangelogSplitInfo& p) {
  from_json_key(
      j,
      "operation",
      p.operation,
      "ChangelogSplitInfo",
      "ChangelogOperation",
      "operation");
  from_json_key(
      j, "ordinal", p.ordinal, "ChangelogSplitInfo", "int64_t", "ordinal");
  from_json_key(
      j,
      "snapshotId",
      p.snapshotId,
      "ChangelogSplitInfo",
      "int64_t",
      "snapshotId");
  from_json_key(
      j,
      "icebergColumns",
      p.icebergColumns,
      "ChangelogSplitInfo",
      "List<IcebergColumnHandle>",
      "icebergColumns");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {
// Loosly copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<FileContent, json> FileContent_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {FileContent::DATA, "DATA"},
        {FileContent::POSITION_DELETES, "POSITION_DELETES"},
        {FileContent::EQUALITY_DELETES, "EQUALITY_DELETES"}};
void to_json(json& j, const FileContent& e) {
  static_assert(
      std::is_enum<FileContent>::value, "FileContent must be an enum!");
  const auto* it = std::find_if(
      std::begin(FileContent_enum_table),
      std::end(FileContent_enum_table),
      [e](const std::pair<FileContent, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(FileContent_enum_table))
           ? it
           : std::begin(FileContent_enum_table))
          ->second;
}
void from_json(const json& j, FileContent& e) {
  static_assert(
      std::is_enum<FileContent>::value, "FileContent must be an enum!");
  const auto* it = std::find_if(
      std::begin(FileContent_enum_table),
      std::end(FileContent_enum_table),
      [&j](const std::pair<FileContent, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(FileContent_enum_table))
           ? it
           : std::begin(FileContent_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {
// Loosly copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<FileFormat, json> FileFormat_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {FileFormat::ORC, "ORC"},
        {FileFormat::PARQUET, "PARQUET"},
        {FileFormat::AVRO, "AVRO"},
        {FileFormat::METADATA, "METADATA"}};
void to_json(json& j, const FileFormat& e) {
  static_assert(std::is_enum<FileFormat>::value, "FileFormat must be an enum!");
  const auto* it = std::find_if(
      std::begin(FileFormat_enum_table),
      std::end(FileFormat_enum_table),
      [e](const std::pair<FileFormat, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(FileFormat_enum_table))
           ? it
           : std::begin(FileFormat_enum_table))
          ->second;
}
void from_json(const json& j, FileFormat& e) {
  static_assert(std::is_enum<FileFormat>::value, "FileFormat must be an enum!");
  const auto* it = std::find_if(
      std::begin(FileFormat_enum_table),
      std::end(FileFormat_enum_table),
      [&j](const std::pair<FileFormat, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(FileFormat_enum_table))
           ? it
           : std::begin(FileFormat_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {

void to_json(json& j, const DeleteFile& p) {
  j = json::object();
  to_json_key(j, "content", p.content, "DeleteFile", "FileContent", "content");
  to_json_key(j, "path", p.path, "DeleteFile", "String", "path");
  to_json_key(j, "format", p.format, "DeleteFile", "FileFormat", "format");
  to_json_key(
      j, "recordCount", p.recordCount, "DeleteFile", "int64_t", "recordCount");
  to_json_key(
      j,
      "fileSizeInBytes",
      p.fileSizeInBytes,
      "DeleteFile",
      "int64_t",
      "fileSizeInBytes");
  to_json_key(
      j,
      "equalityFieldIds",
      p.equalityFieldIds,
      "DeleteFile",
      "List<Integer>",
      "equalityFieldIds");
  to_json_key(
      j,
      "lowerBounds",
      p.lowerBounds,
      "DeleteFile",
      "Map<Integer, String>",
      "lowerBounds");
  to_json_key(
      j,
      "upperBounds",
      p.upperBounds,
      "DeleteFile",
      "Map<Integer, String>",
      "upperBounds");
}

void from_json(const json& j, DeleteFile& p) {
  from_json_key(
      j, "content", p.content, "DeleteFile", "FileContent", "content");
  from_json_key(j, "path", p.path, "DeleteFile", "String", "path");
  from_json_key(j, "format", p.format, "DeleteFile", "FileFormat", "format");
  from_json_key(
      j, "recordCount", p.recordCount, "DeleteFile", "int64_t", "recordCount");
  from_json_key(
      j,
      "fileSizeInBytes",
      p.fileSizeInBytes,
      "DeleteFile",
      "int64_t",
      "fileSizeInBytes");
  from_json_key(
      j,
      "equalityFieldIds",
      p.equalityFieldIds,
      "DeleteFile",
      "List<Integer>",
      "equalityFieldIds");
  from_json_key(
      j,
      "lowerBounds",
      p.lowerBounds,
      "DeleteFile",
      "Map<Integer, String>",
      "lowerBounds");
  from_json_key(
      j,
      "upperBounds",
      p.upperBounds,
      "DeleteFile",
      "Map<Integer, String>",
      "upperBounds");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {
// Loosly copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<IcebergTableType, json> IcebergTableType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {IcebergTableType::DATA, "DATA"},
        {IcebergTableType::HISTORY, "HISTORY"},
        {IcebergTableType::SNAPSHOTS, "SNAPSHOTS"},
        {IcebergTableType::MANIFESTS, "MANIFESTS"},
        {IcebergTableType::PARTITIONS, "PARTITIONS"},
        {IcebergTableType::FILES, "FILES"},
        {IcebergTableType::REFS, "REFS"},
        {IcebergTableType::PROPERTIES, "PROPERTIES"},
        {IcebergTableType::CHANGELOG, "CHANGELOG"},
        {IcebergTableType::EQUALITY_DELETES, "EQUALITY_DELETES"},
        {IcebergTableType::DATA_WITHOUT_EQUALITY_DELETES,
         "DATA_WITHOUT_EQUALITY_DELETES"}};
void to_json(json& j, const IcebergTableType& e) {
  static_assert(
      std::is_enum<IcebergTableType>::value,
      "IcebergTableType must be an enum!");
  const auto* it = std::find_if(
      std::begin(IcebergTableType_enum_table),
      std::end(IcebergTableType_enum_table),
      [e](const std::pair<IcebergTableType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(IcebergTableType_enum_table))
           ? it
           : std::begin(IcebergTableType_enum_table))
          ->second;
}
void from_json(const json& j, IcebergTableType& e) {
  static_assert(
      std::is_enum<IcebergTableType>::value,
      "IcebergTableType must be an enum!");
  const auto* it = std::find_if(
      std::begin(IcebergTableType_enum_table),
      std::end(IcebergTableType_enum_table),
      [&j](const std::pair<IcebergTableType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(IcebergTableType_enum_table))
           ? it
           : std::begin(IcebergTableType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {

void to_json(json& j, const IcebergTableName& p) {
  j = json::object();
  to_json_key(
      j, "tableName", p.tableName, "IcebergTableName", "String", "tableName");
  to_json_key(
      j,
      "tableType",
      p.tableType,
      "IcebergTableName",
      "IcebergTableType",
      "tableType");
  to_json_key(
      j, "snapshotId", p.snapshotId, "IcebergTableName", "Long", "snapshotId");
  to_json_key(
      j,
      "changelogEndSnapshot",
      p.changelogEndSnapshot,
      "IcebergTableName",
      "Long",
      "changelogEndSnapshot");
}

void from_json(const json& j, IcebergTableName& p) {
  from_json_key(
      j, "tableName", p.tableName, "IcebergTableName", "String", "tableName");
  from_json_key(
      j,
      "tableType",
      p.tableType,
      "IcebergTableName",
      "IcebergTableType",
      "tableType");
  from_json_key(
      j, "snapshotId", p.snapshotId, "IcebergTableName", "Long", "snapshotId");
  from_json_key(
      j,
      "changelogEndSnapshot",
      p.changelogEndSnapshot,
      "IcebergTableName",
      "Long",
      "changelogEndSnapshot");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {

void to_json(json& j, const PrestoIcebergNestedField& p) {
  j = json::object();
  to_json_key(
      j,
      "optional",
      p.optional,
      "PrestoIcebergNestedField",
      "bool",
      "optional");
  to_json_key(j, "id", p.id, "PrestoIcebergNestedField", "int", "id");
  to_json_key(j, "name", p.name, "PrestoIcebergNestedField", "String", "name");
  to_json_key(
      j,
      "prestoType",
      p.prestoType,
      "PrestoIcebergNestedField",
      "Type",
      "prestoType");
  to_json_key(j, "doc", p.doc, "PrestoIcebergNestedField", "String", "doc");
}

void from_json(const json& j, PrestoIcebergNestedField& p) {
  from_json_key(
      j,
      "optional",
      p.optional,
      "PrestoIcebergNestedField",
      "bool",
      "optional");
  from_json_key(j, "id", p.id, "PrestoIcebergNestedField", "int", "id");
  from_json_key(
      j, "name", p.name, "PrestoIcebergNestedField", "String", "name");
  from_json_key(
      j,
      "prestoType",
      p.prestoType,
      "PrestoIcebergNestedField",
      "Type",
      "prestoType");
  from_json_key(j, "doc", p.doc, "PrestoIcebergNestedField", "String", "doc");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {

void to_json(json& j, const PrestoIcebergSchema& p) {
  j = json::object();
  to_json_key(
      j, "schemaId", p.schemaId, "PrestoIcebergSchema", "int", "schemaId");
  to_json_key(
      j,
      "columns",
      p.columns,
      "PrestoIcebergSchema",
      "List<PrestoIcebergNestedField>",
      "columns");
  to_json_key(
      j,
      "columnNameToIdMapping",
      p.columnNameToIdMapping,
      "PrestoIcebergSchema",
      "Map<String, Integer>",
      "columnNameToIdMapping");
  to_json_key(
      j,
      "aliases",
      p.aliases,
      "PrestoIcebergSchema",
      "Map<String, Integer>",
      "aliases");
  to_json_key(
      j,
      "identifierFieldIds",
      p.identifierFieldIds,
      "PrestoIcebergSchema",
      "List<Integer>",
      "identifierFieldIds");
}

void from_json(const json& j, PrestoIcebergSchema& p) {
  from_json_key(
      j, "schemaId", p.schemaId, "PrestoIcebergSchema", "int", "schemaId");
  from_json_key(
      j,
      "columns",
      p.columns,
      "PrestoIcebergSchema",
      "List<PrestoIcebergNestedField>",
      "columns");
  from_json_key(
      j,
      "columnNameToIdMapping",
      p.columnNameToIdMapping,
      "PrestoIcebergSchema",
      "Map<String, Integer>",
      "columnNameToIdMapping");
  from_json_key(
      j,
      "aliases",
      p.aliases,
      "PrestoIcebergSchema",
      "Map<String, Integer>",
      "aliases");
  from_json_key(
      j,
      "identifierFieldIds",
      p.identifierFieldIds,
      "PrestoIcebergSchema",
      "List<Integer>",
      "identifierFieldIds");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {

void to_json(json& j, const PrestoIcebergPartitionSpec& p) {
  j = json::object();
  to_json_key(
      j, "specId", p.specId, "PrestoIcebergPartitionSpec", "int", "specId");
  to_json_key(
      j,
      "schema",
      p.schema,
      "PrestoIcebergPartitionSpec",
      "PrestoIcebergSchema",
      "schema");
  to_json_key(
      j,
      "fields",
      p.fields,
      "PrestoIcebergPartitionSpec",
      "List<String>",
      "fields");
}

void from_json(const json& j, PrestoIcebergPartitionSpec& p) {
  from_json_key(
      j, "specId", p.specId, "PrestoIcebergPartitionSpec", "int", "specId");
  from_json_key(
      j,
      "schema",
      p.schema,
      "PrestoIcebergPartitionSpec",
      "PrestoIcebergSchema",
      "schema");
  from_json_key(
      j,
      "fields",
      p.fields,
      "PrestoIcebergPartitionSpec",
      "List<String>",
      "fields");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {
IcebergInsertTableHandle::IcebergInsertTableHandle() noexcept {
  _type = "hive-iceberg";
}

void to_json(json& j, const IcebergInsertTableHandle& p) {
  j = json::object();
  j["@type"] = "hive-iceberg";
  to_json_key(
      j,
      "schemaName",
      p.schemaName,
      "IcebergInsertTableHandle",
      "String",
      "schemaName");
  to_json_key(
      j,
      "tableName",
      p.tableName,
      "IcebergInsertTableHandle",
      "IcebergTableName",
      "tableName");
  to_json_key(
      j,
      "schema",
      p.schema,
      "IcebergInsertTableHandle",
      "PrestoIcebergSchema",
      "schema");
  to_json_key(
      j,
      "partitionSpec",
      p.partitionSpec,
      "IcebergInsertTableHandle",
      "PrestoIcebergPartitionSpec",
      "partitionSpec");
  to_json_key(
      j,
      "inputColumns",
      p.inputColumns,
      "IcebergInsertTableHandle",
      "List<IcebergColumnHandle>",
      "inputColumns");
  to_json_key(
      j,
      "outputPath",
      p.outputPath,
      "IcebergInsertTableHandle",
      "String",
      "outputPath");
  to_json_key(
      j,
      "fileFormat",
      p.fileFormat,
      "IcebergInsertTableHandle",
      "FileFormat",
      "fileFormat");
  to_json_key(
      j,
      "compressionCodec",
      p.compressionCodec,
      "IcebergInsertTableHandle",
      "HiveCompressionCodec",
      "compressionCodec");
  to_json_key(
      j,
      "storageProperties",
      p.storageProperties,
      "IcebergInsertTableHandle",
      "Map<String, String>",
      "storageProperties");
}

void from_json(const json& j, IcebergInsertTableHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "schemaName",
      p.schemaName,
      "IcebergInsertTableHandle",
      "String",
      "schemaName");
  from_json_key(
      j,
      "tableName",
      p.tableName,
      "IcebergInsertTableHandle",
      "IcebergTableName",
      "tableName");
  from_json_key(
      j,
      "schema",
      p.schema,
      "IcebergInsertTableHandle",
      "PrestoIcebergSchema",
      "schema");
  from_json_key(
      j,
      "partitionSpec",
      p.partitionSpec,
      "IcebergInsertTableHandle",
      "PrestoIcebergPartitionSpec",
      "partitionSpec");
  from_json_key(
      j,
      "inputColumns",
      p.inputColumns,
      "IcebergInsertTableHandle",
      "List<IcebergColumnHandle>",
      "inputColumns");
  from_json_key(
      j,
      "outputPath",
      p.outputPath,
      "IcebergInsertTableHandle",
      "String",
      "outputPath");
  from_json_key(
      j,
      "fileFormat",
      p.fileFormat,
      "IcebergInsertTableHandle",
      "FileFormat",
      "fileFormat");
  from_json_key(
      j,
      "compressionCodec",
      p.compressionCodec,
      "IcebergInsertTableHandle",
      "HiveCompressionCodec",
      "compressionCodec");
  from_json_key(
      j,
      "storageProperties",
      p.storageProperties,
      "IcebergInsertTableHandle",
      "Map<String, String>",
      "storageProperties");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {
IcebergOutputTableHandle::IcebergOutputTableHandle() noexcept {
  _type = "hive-iceberg";
}

void to_json(json& j, const IcebergOutputTableHandle& p) {
  j = json::object();
  j["@type"] = "hive-iceberg";
  to_json_key(
      j,
      "schemaName",
      p.schemaName,
      "IcebergOutputTableHandle",
      "String",
      "schemaName");
  to_json_key(
      j,
      "tableName",
      p.tableName,
      "IcebergOutputTableHandle",
      "IcebergTableName",
      "tableName");
  to_json_key(
      j,
      "schema",
      p.schema,
      "IcebergOutputTableHandle",
      "PrestoIcebergSchema",
      "schema");
  to_json_key(
      j,
      "partitionSpec",
      p.partitionSpec,
      "IcebergOutputTableHandle",
      "PrestoIcebergPartitionSpec",
      "partitionSpec");
  to_json_key(
      j,
      "inputColumns",
      p.inputColumns,
      "IcebergOutputTableHandle",
      "List<IcebergColumnHandle>",
      "inputColumns");
  to_json_key(
      j,
      "outputPath",
      p.outputPath,
      "IcebergOutputTableHandle",
      "String",
      "outputPath");
  to_json_key(
      j,
      "fileFormat",
      p.fileFormat,
      "IcebergOutputTableHandle",
      "FileFormat",
      "fileFormat");
  to_json_key(
      j,
      "compressionCodec",
      p.compressionCodec,
      "IcebergOutputTableHandle",
      "HiveCompressionCodec",
      "compressionCodec");
  to_json_key(
      j,
      "storageProperties",
      p.storageProperties,
      "IcebergOutputTableHandle",
      "Map<String, String>",
      "storageProperties");
}

void from_json(const json& j, IcebergOutputTableHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "schemaName",
      p.schemaName,
      "IcebergOutputTableHandle",
      "String",
      "schemaName");
  from_json_key(
      j,
      "tableName",
      p.tableName,
      "IcebergOutputTableHandle",
      "IcebergTableName",
      "tableName");
  from_json_key(
      j,
      "schema",
      p.schema,
      "IcebergOutputTableHandle",
      "PrestoIcebergSchema",
      "schema");
  from_json_key(
      j,
      "partitionSpec",
      p.partitionSpec,
      "IcebergOutputTableHandle",
      "PrestoIcebergPartitionSpec",
      "partitionSpec");
  from_json_key(
      j,
      "inputColumns",
      p.inputColumns,
      "IcebergOutputTableHandle",
      "List<IcebergColumnHandle>",
      "inputColumns");
  from_json_key(
      j,
      "outputPath",
      p.outputPath,
      "IcebergOutputTableHandle",
      "String",
      "outputPath");
  from_json_key(
      j,
      "fileFormat",
      p.fileFormat,
      "IcebergOutputTableHandle",
      "FileFormat",
      "fileFormat");
  from_json_key(
      j,
      "compressionCodec",
      p.compressionCodec,
      "IcebergOutputTableHandle",
      "HiveCompressionCodec",
      "compressionCodec");
  from_json_key(
      j,
      "storageProperties",
      p.storageProperties,
      "IcebergOutputTableHandle",
      "Map<String, String>",
      "storageProperties");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {
IcebergSplit::IcebergSplit() noexcept {
  _type = "hive-iceberg";
}

void to_json(json& j, const IcebergSplit& p) {
  j = json::object();
  j["@type"] = "hive-iceberg";
  to_json_key(j, "path", p.path, "IcebergSplit", "String", "path");
  to_json_key(j, "start", p.start, "IcebergSplit", "int64_t", "start");
  to_json_key(j, "length", p.length, "IcebergSplit", "int64_t", "length");
  to_json_key(
      j,
      "fileFormat",
      p.fileFormat,
      "IcebergSplit",
      "FileFormat",
      "fileFormat");
  to_json_key(
      j,
      "addresses",
      p.addresses,
      "IcebergSplit",
      "List<HostAddress>",
      "addresses");
  to_json_key(
      j,
      "partitionKeys",
      p.partitionKeys,
      "IcebergSplit",
      "Map<Integer, HivePartitionKey>",
      "partitionKeys");
  to_json_key(
      j,
      "partitionSpecAsJson",
      p.partitionSpecAsJson,
      "IcebergSplit",
      "String",
      "partitionSpecAsJson");
  to_json_key(
      j,
      "partitionDataJson",
      p.partitionDataJson,
      "IcebergSplit",
      "String",
      "partitionDataJson");
  to_json_key(
      j,
      "nodeSelectionStrategy",
      p.nodeSelectionStrategy,
      "IcebergSplit",
      "NodeSelectionStrategy",
      "nodeSelectionStrategy");
  to_json_key(
      j,
      "splitWeight",
      p.splitWeight,
      "IcebergSplit",
      "SplitWeight",
      "splitWeight");
  to_json_key(
      j, "deletes", p.deletes, "IcebergSplit", "List<DeleteFile>", "deletes");
  to_json_key(
      j,
      "changelogSplitInfo",
      p.changelogSplitInfo,
      "IcebergSplit",
      "ChangelogSplitInfo",
      "changelogSplitInfo");
  to_json_key(
      j,
      "dataSequenceNumber",
      p.dataSequenceNumber,
      "IcebergSplit",
      "int64_t",
      "dataSequenceNumber");
}

void from_json(const json& j, IcebergSplit& p) {
  p._type = j["@type"];
  from_json_key(j, "path", p.path, "IcebergSplit", "String", "path");
  from_json_key(j, "start", p.start, "IcebergSplit", "int64_t", "start");
  from_json_key(j, "length", p.length, "IcebergSplit", "int64_t", "length");
  from_json_key(
      j,
      "fileFormat",
      p.fileFormat,
      "IcebergSplit",
      "FileFormat",
      "fileFormat");
  from_json_key(
      j,
      "addresses",
      p.addresses,
      "IcebergSplit",
      "List<HostAddress>",
      "addresses");
  from_json_key(
      j,
      "partitionKeys",
      p.partitionKeys,
      "IcebergSplit",
      "Map<Integer, HivePartitionKey>",
      "partitionKeys");
  from_json_key(
      j,
      "partitionSpecAsJson",
      p.partitionSpecAsJson,
      "IcebergSplit",
      "String",
      "partitionSpecAsJson");
  from_json_key(
      j,
      "partitionDataJson",
      p.partitionDataJson,
      "IcebergSplit",
      "String",
      "partitionDataJson");
  from_json_key(
      j,
      "nodeSelectionStrategy",
      p.nodeSelectionStrategy,
      "IcebergSplit",
      "NodeSelectionStrategy",
      "nodeSelectionStrategy");
  from_json_key(
      j,
      "splitWeight",
      p.splitWeight,
      "IcebergSplit",
      "SplitWeight",
      "splitWeight");
  from_json_key(
      j, "deletes", p.deletes, "IcebergSplit", "List<DeleteFile>", "deletes");
  from_json_key(
      j,
      "changelogSplitInfo",
      p.changelogSplitInfo,
      "IcebergSplit",
      "ChangelogSplitInfo",
      "changelogSplitInfo");
  from_json_key(
      j,
      "dataSequenceNumber",
      p.dataSequenceNumber,
      "IcebergSplit",
      "int64_t",
      "dataSequenceNumber");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {
IcebergTableHandle::IcebergTableHandle() noexcept {
  _type = "hive-iceberg";
}

void to_json(json& j, const IcebergTableHandle& p) {
  j = json::object();
  j["@type"] = "hive-iceberg";
  to_json_key(
      j,
      "schemaName",
      p.schemaName,
      "IcebergTableHandle",
      "String",
      "schemaName");
  to_json_key(
      j,
      "icebergTableName",
      p.icebergTableName,
      "IcebergTableHandle",
      "IcebergTableName",
      "icebergTableName");
  to_json_key(
      j,
      "snapshotSpecified",
      p.snapshotSpecified,
      "IcebergTableHandle",
      "bool",
      "snapshotSpecified");
  to_json_key(
      j,
      "outputPath",
      p.outputPath,
      "IcebergTableHandle",
      "String",
      "outputPath");
  to_json_key(
      j,
      "storageProperties",
      p.storageProperties,
      "IcebergTableHandle",
      "Map<String, String>",
      "storageProperties");
  to_json_key(
      j,
      "tableSchemaJson",
      p.tableSchemaJson,
      "IcebergTableHandle",
      "String",
      "tableSchemaJson");
  to_json_key(
      j,
      "partitionFieldIds",
      p.partitionFieldIds,
      "IcebergTableHandle",
      "List<Integer>",
      "partitionFieldIds");
  to_json_key(
      j,
      "equalityFieldIds",
      p.equalityFieldIds,
      "IcebergTableHandle",
      "List<Integer>",
      "equalityFieldIds");
}

void from_json(const json& j, IcebergTableHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "schemaName",
      p.schemaName,
      "IcebergTableHandle",
      "String",
      "schemaName");
  from_json_key(
      j,
      "icebergTableName",
      p.icebergTableName,
      "IcebergTableHandle",
      "IcebergTableName",
      "icebergTableName");
  from_json_key(
      j,
      "snapshotSpecified",
      p.snapshotSpecified,
      "IcebergTableHandle",
      "bool",
      "snapshotSpecified");
  from_json_key(
      j,
      "outputPath",
      p.outputPath,
      "IcebergTableHandle",
      "String",
      "outputPath");
  from_json_key(
      j,
      "storageProperties",
      p.storageProperties,
      "IcebergTableHandle",
      "Map<String, String>",
      "storageProperties");
  from_json_key(
      j,
      "tableSchemaJson",
      p.tableSchemaJson,
      "IcebergTableHandle",
      "String",
      "tableSchemaJson");
  from_json_key(
      j,
      "partitionFieldIds",
      p.partitionFieldIds,
      "IcebergTableHandle",
      "List<Integer>",
      "partitionFieldIds");
  from_json_key(
      j,
      "equalityFieldIds",
      p.equalityFieldIds,
      "IcebergTableHandle",
      "List<Integer>",
      "equalityFieldIds");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {
void to_json(json& j, const std::shared_ptr<ColumnHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "hive-iceberg") {
    j = *std::static_pointer_cast<IcebergColumnHandle>(p);
    return;
  }

  throw TypeError(type + " no abstract type ColumnHandle ");
}

void from_json(const json& j, std::shared_ptr<ColumnHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " ColumnHandle  ColumnHandle");
  }

  if (type == "hive-iceberg") {
    std::shared_ptr<IcebergColumnHandle> k =
        std::make_shared<IcebergColumnHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ColumnHandle>(k);
    return;
  }

  throw TypeError(type + " no abstract type ColumnHandle ");
}
} // namespace facebook::presto::protocol::iceberg
namespace facebook::presto::protocol::iceberg {
IcebergTableLayoutHandle::IcebergTableLayoutHandle() noexcept {
  _type = "hive-iceberg";
}

void to_json(json& j, const IcebergTableLayoutHandle& p) {
  j = json::object();
  j["@type"] = "hive-iceberg";
  to_json_key(
      j,
      "partitionColumns",
      p.partitionColumns,
      "IcebergTableLayoutHandle",
      "List<IcebergColumnHandle>",
      "partitionColumns");
  to_json_key(
      j,
      "dataColumns",
      p.dataColumns,
      "IcebergTableLayoutHandle",
      "List<Column>",
      "dataColumns");
  to_json_key(
      j,
      "domainPredicate",
      p.domainPredicate,
      "IcebergTableLayoutHandle",
      "TupleDomain<Subfield>",
      "domainPredicate");
  to_json_key(
      j,
      "remainingPredicate",
      p.remainingPredicate,
      "IcebergTableLayoutHandle",
      "std::shared_ptr<RowExpression>",
      "remainingPredicate");
  to_json_key(
      j,
      "predicateColumns",
      p.predicateColumns,
      "IcebergTableLayoutHandle",
      "Map<String, IcebergColumnHandle>",
      "predicateColumns");
  to_json_key(
      j,
      "requestedColumns",
      p.requestedColumns,
      "IcebergTableLayoutHandle",
      "List<IcebergColumnHandle>",
      "requestedColumns");
  to_json_key(
      j,
      "pushdownFilterEnabled",
      p.pushdownFilterEnabled,
      "IcebergTableLayoutHandle",
      "bool",
      "pushdownFilterEnabled");
  to_json_key(
      j,
      "partitionColumnPredicate",
      p.partitionColumnPredicate,
      "IcebergTableLayoutHandle",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "partitionColumnPredicate");
  to_json_key(
      j,
      "table",
      p.table,
      "IcebergTableLayoutHandle",
      "IcebergTableHandle",
      "table");
}

void from_json(const json& j, IcebergTableLayoutHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "partitionColumns",
      p.partitionColumns,
      "IcebergTableLayoutHandle",
      "List<IcebergColumnHandle>",
      "partitionColumns");
  from_json_key(
      j,
      "dataColumns",
      p.dataColumns,
      "IcebergTableLayoutHandle",
      "List<Column>",
      "dataColumns");
  from_json_key(
      j,
      "domainPredicate",
      p.domainPredicate,
      "IcebergTableLayoutHandle",
      "TupleDomain<Subfield>",
      "domainPredicate");
  from_json_key(
      j,
      "remainingPredicate",
      p.remainingPredicate,
      "IcebergTableLayoutHandle",
      "std::shared_ptr<RowExpression>",
      "remainingPredicate");
  from_json_key(
      j,
      "predicateColumns",
      p.predicateColumns,
      "IcebergTableLayoutHandle",
      "Map<String, IcebergColumnHandle>",
      "predicateColumns");
  from_json_key(
      j,
      "requestedColumns",
      p.requestedColumns,
      "IcebergTableLayoutHandle",
      "List<IcebergColumnHandle>",
      "requestedColumns");
  from_json_key(
      j,
      "pushdownFilterEnabled",
      p.pushdownFilterEnabled,
      "IcebergTableLayoutHandle",
      "bool",
      "pushdownFilterEnabled");
  from_json_key(
      j,
      "partitionColumnPredicate",
      p.partitionColumnPredicate,
      "IcebergTableLayoutHandle",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "partitionColumnPredicate");
  from_json_key(
      j,
      "table",
      p.table,
      "IcebergTableLayoutHandle",
      "IcebergTableHandle",
      "table");
}
} // namespace facebook::presto::protocol::iceberg
