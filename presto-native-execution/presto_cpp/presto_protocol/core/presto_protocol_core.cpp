// DO NOT EDIT : This file is generated by chevron
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// presto_protocol.prolog.cpp
//

// This file is generated DO NOT EDIT @generated

#include <folly/Format.h>
#include <iostream>

#include "presto_cpp/presto_protocol/core/ConnectorProtocol.h"
#include "presto_cpp/presto_protocol/core/presto_protocol_core.h"

using namespace std::string_literals;

namespace nlohmann {
std::string json_map_key(std::string p) {
  return p;
}
} // namespace nlohmann

namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<NodeSelectionStrategy, json>
    NodeSelectionStrategy_enum_table[] =
        { // NOLINT: cert-err58-cpp
            {NodeSelectionStrategy::HARD_AFFINITY, "HARD_AFFINITY"},
            {NodeSelectionStrategy::SOFT_AFFINITY, "SOFT_AFFINITY"},
            {NodeSelectionStrategy::NO_PREFERENCE, "NO_PREFERENCE"}};
void to_json(json& j, const NodeSelectionStrategy& e) {
  static_assert(
      std::is_enum<NodeSelectionStrategy>::value,
      "NodeSelectionStrategy must be an enum!");
  const auto* it = std::find_if(
      std::begin(NodeSelectionStrategy_enum_table),
      std::end(NodeSelectionStrategy_enum_table),
      [e](const std::pair<NodeSelectionStrategy, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(NodeSelectionStrategy_enum_table))
           ? it
           : std::begin(NodeSelectionStrategy_enum_table))
          ->second;
}
void from_json(const json& j, NodeSelectionStrategy& e) {
  static_assert(
      std::is_enum<NodeSelectionStrategy>::value,
      "NodeSelectionStrategy must be an enum!");
  const auto* it = std::find_if(
      std::begin(NodeSelectionStrategy_enum_table),
      std::end(NodeSelectionStrategy_enum_table),
      [&j](const std::pair<NodeSelectionStrategy, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(NodeSelectionStrategy_enum_table))
           ? it
           : std::begin(NodeSelectionStrategy_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

const char* const PRESTO_PAGES_MIME_TYPE = "application/x-presto-pages";

const char* const PRESTO_CURRENT_STATE_HTTP_HEADER = "X-Presto-Current-State";
const char* const PRESTO_MAX_WAIT_HTTP_HEADER = "X-Presto-Max-Wait";
const char* const PRESTO_MAX_SIZE_HTTP_HEADER = "X-Presto-Max-Size";
const char* const PRESTO_TASK_INSTANCE_ID_HEADER = "X-Presto-Task-Instance-Id";
const char* const PRESTO_PAGE_TOKEN_HEADER = "X-Presto-Page-Sequence-Id";
const char* const PRESTO_PAGE_NEXT_TOKEN_HEADER =
    "X-Presto-Page-End-Sequence-Id";
const char* const PRESTO_BUFFER_COMPLETE_HEADER = "X-Presto-Buffer-Complete";
const char* const PRESTO_GET_DATA_SIZE_HEADER = "X-Presto-Get-Data-Size";
const char* const PRESTO_BUFFER_REMAINING_BYTES_HEADER =
    "X-Presto-Buffer-Remaining-Bytes";
const char* const PRESTO_BUFFER_WAIT_TIME_MS_HEADER =
    "X-Presto-Buffer-Wait-Time-Ms";
const char* const PRESTO_BUFFER_REMAINING_FROM_SPILL_HEADER =
    "X-Presto-Buffer-Remaining-From-Spill";

const char* const PRESTO_MAX_WAIT_DEFAULT = "2s";
const char* const PRESTO_MAX_SIZE_DEFAULT = "4096 B";

const char* const PRESTO_ABORT_TASK_URL_PARAM = "abort";

std::string json_map_key(const VariableReferenceExpression& p) {
  return fmt::format("{}<{}>", p.name, p.type);
}
} // namespace facebook::presto::protocol

namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ArgumentSpecification>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "descriptor") {
    j = *std::static_pointer_cast<DescriptorArgumentSpecification>(p);
    return;
  }
  if (type == "scalar") {
    j = *std::static_pointer_cast<ScalarArgumentSpecification>(p);
    return;
  }
  if (type == "table") {
    j = *std::static_pointer_cast<TableArgumentSpecification>(p);
    return;
  }

  throw TypeError(type + " no abstract type ArgumentSpecification ");
}

void from_json(const json& j, std::shared_ptr<ArgumentSpecification>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) +
        " ArgumentSpecification  ArgumentSpecification");
  }

  if (type == "descriptor") {
    std::shared_ptr<DescriptorArgumentSpecification> k =
        std::make_shared<DescriptorArgumentSpecification>();
    j.get_to(*k);
    p = std::static_pointer_cast<ArgumentSpecification>(k);
    return;
  }
  if (type == "scalar") {
    std::shared_ptr<ScalarArgumentSpecification> k =
        std::make_shared<ScalarArgumentSpecification>();
    j.get_to(*k);
    p = std::static_pointer_cast<ArgumentSpecification>(k);
    return;
  }
  if (type == "table") {
    std::shared_ptr<TableArgumentSpecification> k =
        std::make_shared<TableArgumentSpecification>();
    j.get_to(*k);
    p = std::static_pointer_cast<ArgumentSpecification>(k);
    return;
  }

  throw TypeError(type + " no abstract type ArgumentSpecification ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ReturnTypeSpecification>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "described_table") {
    j = *std::static_pointer_cast<DescribedTableReturnTypeSpecification>(p);
    return;
  }
  if (type == "generic_table") {
    j = *std::static_pointer_cast<GenericTableReturnTypeSpecification>(p);
    return;
  }
  if (type == "only_pass_through_table") {
    j = *std::static_pointer_cast<OnlyPassThroughReturnTypeSpecification>(p);
    return;
  }

  throw TypeError(type + " no abstract type ReturnTypeSpecification ");
}

void from_json(const json& j, std::shared_ptr<ReturnTypeSpecification>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) +
        " ReturnTypeSpecification  ReturnTypeSpecification");
  }

  if (type == "described_table") {
    std::shared_ptr<DescribedTableReturnTypeSpecification> k =
        std::make_shared<DescribedTableReturnTypeSpecification>();
    j.get_to(*k);
    p = std::static_pointer_cast<ReturnTypeSpecification>(k);
    return;
  }
  if (type == "generic_table") {
    std::shared_ptr<GenericTableReturnTypeSpecification> k =
        std::make_shared<GenericTableReturnTypeSpecification>();
    j.get_to(*k);
    p = std::static_pointer_cast<ReturnTypeSpecification>(k);
    return;
  }
  if (type == "only_pass_through_table") {
    std::shared_ptr<OnlyPassThroughReturnTypeSpecification> k =
        std::make_shared<OnlyPassThroughReturnTypeSpecification>();
    j.get_to(*k);
    p = std::static_pointer_cast<ReturnTypeSpecification>(k);
    return;
  }

  throw TypeError(type + " no abstract type ReturnTypeSpecification ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const AbstractConnectorTableFunction& p) {
  j = json::object();
  to_json_key(
      j,
      "schema",
      p.schema,
      "AbstractConnectorTableFunction",
      "String",
      "schema");
  to_json_key(
      j, "name", p.name, "AbstractConnectorTableFunction", "String", "name");
  to_json_key(
      j,
      "arguments",
      p.arguments,
      "AbstractConnectorTableFunction",
      "List<std::shared_ptr<ArgumentSpecification>>",
      "arguments");
  to_json_key(
      j,
      "returnTypeSpecification",
      p.returnTypeSpecification,
      "AbstractConnectorTableFunction",
      "ReturnTypeSpecification",
      "returnTypeSpecification");
}

void from_json(const json& j, AbstractConnectorTableFunction& p) {
  from_json_key(
      j,
      "schema",
      p.schema,
      "AbstractConnectorTableFunction",
      "String",
      "schema");
  from_json_key(
      j, "name", p.name, "AbstractConnectorTableFunction", "String", "name");
  from_json_key(
      j,
      "arguments",
      p.arguments,
      "AbstractConnectorTableFunction",
      "List<std::shared_ptr<ArgumentSpecification>>",
      "arguments");
  from_json_key(
      j,
      "returnTypeSpecification",
      p.returnTypeSpecification,
      "AbstractConnectorTableFunction",
      "ReturnTypeSpecification",
      "returnTypeSpecification");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<FunctionHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "$static") {
    j = *std::static_pointer_cast<BuiltInFunctionHandle>(p);
    return;
  }
  if (type == "native") {
    j = *std::static_pointer_cast<SqlFunctionHandle>(p);
    return;
  }
  if (type == "json_file") {
    j = *std::static_pointer_cast<SqlFunctionHandle>(p);
    return;
  }
  if (type == "sql_function_handle") {
    j = *std::static_pointer_cast<SqlFunctionHandle>(p);
    return;
  }
  if (type == "rest") {
    j = *std::static_pointer_cast<RestFunctionHandle>(p);
    return;
  }

  throw TypeError(type + " no abstract type FunctionHandle ");
}

void from_json(const json& j, std::shared_ptr<FunctionHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " FunctionHandle  FunctionHandle");
  }

  if (type == "$static") {
    std::shared_ptr<BuiltInFunctionHandle> k =
        std::make_shared<BuiltInFunctionHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<FunctionHandle>(k);
    return;
  }
  if (type == "native") {
    std::shared_ptr<SqlFunctionHandle> k =
        std::make_shared<SqlFunctionHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<FunctionHandle>(k);
    return;
  }
  if (type == "json_file") {
    std::shared_ptr<SqlFunctionHandle> k =
        std::make_shared<SqlFunctionHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<FunctionHandle>(k);
    return;
  }
  if (type == "sql_function_handle") {
    std::shared_ptr<SqlFunctionHandle> k =
        std::make_shared<SqlFunctionHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<FunctionHandle>(k);
    return;
  }
  if (type == "rest") {
    std::shared_ptr<RestFunctionHandle> k =
        std::make_shared<RestFunctionHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<FunctionHandle>(k);
    return;
  }

  throw TypeError(type + " no abstract type FunctionHandle ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const SourceLocation& p) {
  j = json::object();
  to_json_key(j, "line", p.line, "SourceLocation", "int", "line");
  to_json_key(j, "column", p.column, "SourceLocation", "int", "column");
}

void from_json(const json& j, SourceLocation& p) {
  from_json_key(j, "line", p.line, "SourceLocation", "int", "line");
  from_json_key(j, "column", p.column, "SourceLocation", "int", "column");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<RowExpression>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "call") {
    j = *std::static_pointer_cast<CallExpression>(p);
    return;
  }
  if (type == "constant") {
    j = *std::static_pointer_cast<ConstantExpression>(p);
    return;
  }
  if (type == "special") {
    j = *std::static_pointer_cast<SpecialFormExpression>(p);
    return;
  }
  if (type == "lambda") {
    j = *std::static_pointer_cast<LambdaDefinitionExpression>(p);
    return;
  }
  if (type == "variable") {
    j = *std::static_pointer_cast<VariableReferenceExpression>(p);
    return;
  }

  throw TypeError(type + " no abstract type RowExpression ");
}

void from_json(const json& j, std::shared_ptr<RowExpression>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " RowExpression  RowExpression");
  }

  if (type == "call") {
    std::shared_ptr<CallExpression> k = std::make_shared<CallExpression>();
    j.get_to(*k);
    p = std::static_pointer_cast<RowExpression>(k);
    return;
  }
  if (type == "constant") {
    std::shared_ptr<ConstantExpression> k =
        std::make_shared<ConstantExpression>();
    j.get_to(*k);
    p = std::static_pointer_cast<RowExpression>(k);
    return;
  }
  if (type == "special") {
    std::shared_ptr<SpecialFormExpression> k =
        std::make_shared<SpecialFormExpression>();
    j.get_to(*k);
    p = std::static_pointer_cast<RowExpression>(k);
    return;
  }
  if (type == "lambda") {
    std::shared_ptr<LambdaDefinitionExpression> k =
        std::make_shared<LambdaDefinitionExpression>();
    j.get_to(*k);
    p = std::static_pointer_cast<RowExpression>(k);
    return;
  }
  if (type == "variable") {
    std::shared_ptr<VariableReferenceExpression> k =
        std::make_shared<VariableReferenceExpression>();
    j.get_to(*k);
    p = std::static_pointer_cast<RowExpression>(k);
    return;
  }

  throw TypeError(type + " no abstract type RowExpression ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
CallExpression::CallExpression() noexcept {
  _type = "call";
}

void to_json(json& j, const CallExpression& p) {
  j = json::object();
  j["@type"] = "call";
  to_json_key(
      j,
      "sourceLocation",
      p.sourceLocation,
      "CallExpression",
      "SourceLocation",
      "sourceLocation");
  to_json_key(
      j,
      "displayName",
      p.displayName,
      "CallExpression",
      "String",
      "displayName");
  to_json_key(
      j,
      "functionHandle",
      p.functionHandle,
      "CallExpression",
      "FunctionHandle",
      "functionHandle");
  to_json_key(
      j, "returnType", p.returnType, "CallExpression", "Type", "returnType");
  to_json_key(
      j,
      "arguments",
      p.arguments,
      "CallExpression",
      "List<std::shared_ptr<RowExpression>>",
      "arguments");
}

void from_json(const json& j, CallExpression& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "sourceLocation",
      p.sourceLocation,
      "CallExpression",
      "SourceLocation",
      "sourceLocation");
  from_json_key(
      j,
      "displayName",
      p.displayName,
      "CallExpression",
      "String",
      "displayName");
  from_json_key(
      j,
      "functionHandle",
      p.functionHandle,
      "CallExpression",
      "FunctionHandle",
      "functionHandle");
  from_json_key(
      j, "returnType", p.returnType, "CallExpression", "Type", "returnType");
  from_json_key(
      j,
      "arguments",
      p.arguments,
      "CallExpression",
      "List<std::shared_ptr<RowExpression>>",
      "arguments");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<SortOrder, json> SortOrder_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {SortOrder::ASC_NULLS_FIRST, "ASC_NULLS_FIRST"},
        {SortOrder::ASC_NULLS_LAST, "ASC_NULLS_LAST"},
        {SortOrder::DESC_NULLS_FIRST, "DESC_NULLS_FIRST"},
        {SortOrder::DESC_NULLS_LAST, "DESC_NULLS_LAST"}};
void to_json(json& j, const SortOrder& e) {
  static_assert(std::is_enum<SortOrder>::value, "SortOrder must be an enum!");
  const auto* it = std::find_if(
      std::begin(SortOrder_enum_table),
      std::end(SortOrder_enum_table),
      [e](const std::pair<SortOrder, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(SortOrder_enum_table))
           ? it
           : std::begin(SortOrder_enum_table))
          ->second;
}
void from_json(const json& j, SortOrder& e) {
  static_assert(std::is_enum<SortOrder>::value, "SortOrder must be an enum!");
  const auto* it = std::find_if(
      std::begin(SortOrder_enum_table),
      std::end(SortOrder_enum_table),
      [&j](const std::pair<SortOrder, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(SortOrder_enum_table))
           ? it
           : std::begin(SortOrder_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
VariableReferenceExpression::VariableReferenceExpression() noexcept {
  _type = "variable";
}

void to_json(json& j, const VariableReferenceExpression& p) {
  j = json::object();
  j["@type"] = "variable";
  to_json_key(
      j,
      "sourceLocation",
      p.sourceLocation,
      "VariableReferenceExpression",
      "SourceLocation",
      "sourceLocation");
  to_json_key(
      j, "name", p.name, "VariableReferenceExpression", "String", "name");
  to_json_key(j, "type", p.type, "VariableReferenceExpression", "Type", "type");
}

void from_json(const json& j, VariableReferenceExpression& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "sourceLocation",
      p.sourceLocation,
      "VariableReferenceExpression",
      "SourceLocation",
      "sourceLocation");
  from_json_key(
      j, "name", p.name, "VariableReferenceExpression", "String", "name");
  from_json_key(
      j, "type", p.type, "VariableReferenceExpression", "Type", "type");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Ordering& p) {
  j = json::object();
  to_json_key(
      j,
      "variable",
      p.variable,
      "Ordering",
      "VariableReferenceExpression",
      "variable");
  to_json_key(
      j, "sortOrder", p.sortOrder, "Ordering", "SortOrder", "sortOrder");
}

void from_json(const json& j, Ordering& p) {
  from_json_key(
      j,
      "variable",
      p.variable,
      "Ordering",
      "VariableReferenceExpression",
      "variable");
  from_json_key(
      j, "sortOrder", p.sortOrder, "Ordering", "SortOrder", "sortOrder");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const OrderingScheme& p) {
  j = json::object();
  to_json_key(
      j, "orderBy", p.orderBy, "OrderingScheme", "List<Ordering>", "orderBy");
}

void from_json(const json& j, OrderingScheme& p) {
  from_json_key(
      j, "orderBy", p.orderBy, "OrderingScheme", "List<Ordering>", "orderBy");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Aggregation& p) {
  j = json::object();
  to_json_key(j, "call", p.call, "Aggregation", "CallExpression", "call");
  to_json_key(
      j,
      "filter",
      p.filter,
      "Aggregation",
      "std::shared_ptr<RowExpression>",
      "filter");
  to_json_key(
      j, "orderBy", p.orderBy, "Aggregation", "OrderingScheme", "orderBy");
  to_json_key(j, "distinct", p.distinct, "Aggregation", "bool", "distinct");
  to_json_key(
      j, "mask", p.mask, "Aggregation", "VariableReferenceExpression", "mask");
  to_json_key(
      j,
      "functionHandle",
      p.functionHandle,
      "Aggregation",
      "FunctionHandle",
      "functionHandle");
  to_json_key(
      j,
      "arguments",
      p.arguments,
      "Aggregation",
      "List<std::shared_ptr<RowExpression>>",
      "arguments");
}

void from_json(const json& j, Aggregation& p) {
  from_json_key(j, "call", p.call, "Aggregation", "CallExpression", "call");
  from_json_key(
      j,
      "filter",
      p.filter,
      "Aggregation",
      "std::shared_ptr<RowExpression>",
      "filter");
  from_json_key(
      j, "orderBy", p.orderBy, "Aggregation", "OrderingScheme", "orderBy");
  from_json_key(j, "distinct", p.distinct, "Aggregation", "bool", "distinct");
  from_json_key(
      j, "mask", p.mask, "Aggregation", "VariableReferenceExpression", "mask");
  from_json_key(
      j,
      "functionHandle",
      p.functionHandle,
      "Aggregation",
      "FunctionHandle",
      "functionHandle");
  from_json_key(
      j,
      "arguments",
      p.arguments,
      "Aggregation",
      "List<std::shared_ptr<RowExpression>>",
      "arguments");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const AggregationFunctionMetadata& p) {
  j = json::object();
  to_json_key(
      j,
      "intermediateType",
      p.intermediateType,
      "AggregationFunctionMetadata",
      "TypeSignature",
      "intermediateType");
  to_json_key(
      j,
      "isOrderSensitive",
      p.isOrderSensitive,
      "AggregationFunctionMetadata",
      "bool",
      "isOrderSensitive");
}

void from_json(const json& j, AggregationFunctionMetadata& p) {
  from_json_key(
      j,
      "intermediateType",
      p.intermediateType,
      "AggregationFunctionMetadata",
      "TypeSignature",
      "intermediateType");
  from_json_key(
      j,
      "isOrderSensitive",
      p.isOrderSensitive,
      "AggregationFunctionMetadata",
      "bool",
      "isOrderSensitive");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<AggregationNodeStep, json>
    AggregationNodeStep_enum_table[] =
        { // NOLINT: cert-err58-cpp
            {AggregationNodeStep::PARTIAL, "PARTIAL"},
            {AggregationNodeStep::FINAL, "FINAL"},
            {AggregationNodeStep::INTERMEDIATE, "INTERMEDIATE"},
            {AggregationNodeStep::SINGLE, "SINGLE"}};
void to_json(json& j, const AggregationNodeStep& e) {
  static_assert(
      std::is_enum<AggregationNodeStep>::value,
      "AggregationNodeStep must be an enum!");
  const auto* it = std::find_if(
      std::begin(AggregationNodeStep_enum_table),
      std::end(AggregationNodeStep_enum_table),
      [e](const std::pair<AggregationNodeStep, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(AggregationNodeStep_enum_table))
           ? it
           : std::begin(AggregationNodeStep_enum_table))
          ->second;
}
void from_json(const json& j, AggregationNodeStep& e) {
  static_assert(
      std::is_enum<AggregationNodeStep>::value,
      "AggregationNodeStep must be an enum!");
  const auto* it = std::find_if(
      std::begin(AggregationNodeStep_enum_table),
      std::end(AggregationNodeStep_enum_table),
      [&j](const std::pair<AggregationNodeStep, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(AggregationNodeStep_enum_table))
           ? it
           : std::begin(AggregationNodeStep_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const GroupingSetDescriptor& p) {
  j = json::object();
  to_json_key(
      j,
      "groupingKeys",
      p.groupingKeys,
      "GroupingSetDescriptor",
      "List<VariableReferenceExpression>",
      "groupingKeys");
  to_json_key(
      j,
      "groupingSetCount",
      p.groupingSetCount,
      "GroupingSetDescriptor",
      "int",
      "groupingSetCount");
  to_json_key(
      j,
      "globalGroupingSets",
      p.globalGroupingSets,
      "GroupingSetDescriptor",
      "List<Integer>",
      "globalGroupingSets");
}

void from_json(const json& j, GroupingSetDescriptor& p) {
  from_json_key(
      j,
      "groupingKeys",
      p.groupingKeys,
      "GroupingSetDescriptor",
      "List<VariableReferenceExpression>",
      "groupingKeys");
  from_json_key(
      j,
      "groupingSetCount",
      p.groupingSetCount,
      "GroupingSetDescriptor",
      "int",
      "groupingSetCount");
  from_json_key(
      j,
      "globalGroupingSets",
      p.globalGroupingSets,
      "GroupingSetDescriptor",
      "List<Integer>",
      "globalGroupingSets");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<PlanNode>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == ".AggregationNode") {
    j = *std::static_pointer_cast<AggregationNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.GroupIdNode") {
    j = *std::static_pointer_cast<GroupIdNode>(p);
    return;
  }
  if (type == ".DeleteNode") {
    j = *std::static_pointer_cast<DeleteNode>(p);
    return;
  }
  if (type == ".DistinctLimitNode") {
    j = *std::static_pointer_cast<DistinctLimitNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.EnforceSingleRowNode") {
    j = *std::static_pointer_cast<EnforceSingleRowNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.ExchangeNode") {
    j = *std::static_pointer_cast<ExchangeNode>(p);
    return;
  }
  if (type == ".FilterNode") {
    j = *std::static_pointer_cast<FilterNode>(p);
    return;
  }
  if (type == ".JoinNode") {
    j = *std::static_pointer_cast<JoinNode>(p);
    return;
  }
  if (type == ".IndexJoinNode") {
    j = *std::static_pointer_cast<IndexJoinNode>(p);
    return;
  }
  if (type == ".IndexSourceNode") {
    j = *std::static_pointer_cast<IndexSourceNode>(p);
    return;
  }
  if (type == ".LimitNode") {
    j = *std::static_pointer_cast<LimitNode>(p);
    return;
  }
  if (type == ".MarkDistinctNode") {
    j = *std::static_pointer_cast<MarkDistinctNode>(p);
    return;
  }
  if (type == ".SortNode") {
    j = *std::static_pointer_cast<SortNode>(p);
    return;
  }
  if (type == ".OutputNode") {
    j = *std::static_pointer_cast<OutputNode>(p);
    return;
  }
  if (type == ".ProjectNode") {
    j = *std::static_pointer_cast<ProjectNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.RowNumberNode") {
    j = *std::static_pointer_cast<RowNumberNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.RemoteSourceNode") {
    j = *std::static_pointer_cast<RemoteSourceNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.SampleNode") {
    j = *std::static_pointer_cast<SampleNode>(p);
    return;
  }
  if (type == ".SemiJoinNode") {
    j = *std::static_pointer_cast<SemiJoinNode>(p);
    return;
  }
  if (type == ".SpatialJoinNode") {
    j = *std::static_pointer_cast<SpatialJoinNode>(p);
    return;
  }
  if (type == ".TableScanNode") {
    j = *std::static_pointer_cast<TableScanNode>(p);
    return;
  }
  if (type == ".TableWriterNode") {
    j = *std::static_pointer_cast<TableWriterNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.TableWriterMergeNode") {
    j = *std::static_pointer_cast<TableWriterMergeNode>(p);
    return;
  }
  if (type == ".TopNNode") {
    j = *std::static_pointer_cast<TopNNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.TopNRowNumberNode") {
    j = *std::static_pointer_cast<TopNRowNumberNode>(p);
    return;
  }
  if (type == ".UnnestNode") {
    j = *std::static_pointer_cast<UnnestNode>(p);
    return;
  }
  if (type == ".ValuesNode") {
    j = *std::static_pointer_cast<ValuesNode>(p);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.AssignUniqueId") {
    j = *std::static_pointer_cast<AssignUniqueId>(p);
    return;
  }
  if (type == ".MergeJoinNode") {
    j = *std::static_pointer_cast<MergeJoinNode>(p);
    return;
  }
  if (type == ".WindowNode") {
    j = *std::static_pointer_cast<WindowNode>(p);
    return;
  }
  if (type ==
      "com.facebook.presto.sql.planner.plan.CallDistributedProcedureNode") {
    j = *std::static_pointer_cast<CallDistributedProcedureNode>(p);
    return;
  }

  throw TypeError(type + " no abstract type PlanNode ");
}

void from_json(const json& j, std::shared_ptr<PlanNode>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " PlanNode  PlanNode");
  }

  if (type == ".AggregationNode") {
    std::shared_ptr<AggregationNode> k = std::make_shared<AggregationNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.GroupIdNode") {
    std::shared_ptr<GroupIdNode> k = std::make_shared<GroupIdNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".DeleteNode") {
    std::shared_ptr<DeleteNode> k = std::make_shared<DeleteNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".DistinctLimitNode") {
    std::shared_ptr<DistinctLimitNode> k =
        std::make_shared<DistinctLimitNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.EnforceSingleRowNode") {
    std::shared_ptr<EnforceSingleRowNode> k =
        std::make_shared<EnforceSingleRowNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.ExchangeNode") {
    std::shared_ptr<ExchangeNode> k = std::make_shared<ExchangeNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".FilterNode") {
    std::shared_ptr<FilterNode> k = std::make_shared<FilterNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".JoinNode") {
    std::shared_ptr<JoinNode> k = std::make_shared<JoinNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".IndexJoinNode") {
    std::shared_ptr<IndexJoinNode> k = std::make_shared<IndexJoinNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".IndexSourceNode") {
    std::shared_ptr<IndexSourceNode> k = std::make_shared<IndexSourceNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".LimitNode") {
    std::shared_ptr<LimitNode> k = std::make_shared<LimitNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".MarkDistinctNode") {
    std::shared_ptr<MarkDistinctNode> k = std::make_shared<MarkDistinctNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".SortNode") {
    std::shared_ptr<SortNode> k = std::make_shared<SortNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".OutputNode") {
    std::shared_ptr<OutputNode> k = std::make_shared<OutputNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".ProjectNode") {
    std::shared_ptr<ProjectNode> k = std::make_shared<ProjectNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.RowNumberNode") {
    std::shared_ptr<RowNumberNode> k = std::make_shared<RowNumberNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.RemoteSourceNode") {
    std::shared_ptr<RemoteSourceNode> k = std::make_shared<RemoteSourceNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.SampleNode") {
    std::shared_ptr<SampleNode> k = std::make_shared<SampleNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".SemiJoinNode") {
    std::shared_ptr<SemiJoinNode> k = std::make_shared<SemiJoinNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".SpatialJoinNode") {
    std::shared_ptr<SpatialJoinNode> k = std::make_shared<SpatialJoinNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".TableScanNode") {
    std::shared_ptr<TableScanNode> k = std::make_shared<TableScanNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".TableWriterNode") {
    std::shared_ptr<TableWriterNode> k = std::make_shared<TableWriterNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.TableWriterMergeNode") {
    std::shared_ptr<TableWriterMergeNode> k =
        std::make_shared<TableWriterMergeNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".TopNNode") {
    std::shared_ptr<TopNNode> k = std::make_shared<TopNNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.TopNRowNumberNode") {
    std::shared_ptr<TopNRowNumberNode> k =
        std::make_shared<TopNRowNumberNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".UnnestNode") {
    std::shared_ptr<UnnestNode> k = std::make_shared<UnnestNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".ValuesNode") {
    std::shared_ptr<ValuesNode> k = std::make_shared<ValuesNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == "com.facebook.presto.sql.planner.plan.AssignUniqueId") {
    std::shared_ptr<AssignUniqueId> k = std::make_shared<AssignUniqueId>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".MergeJoinNode") {
    std::shared_ptr<MergeJoinNode> k = std::make_shared<MergeJoinNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type == ".WindowNode") {
    std::shared_ptr<WindowNode> k = std::make_shared<WindowNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }
  if (type ==
      "com.facebook.presto.sql.planner.plan.CallDistributedProcedureNode") {
    std::shared_ptr<CallDistributedProcedureNode> k =
        std::make_shared<CallDistributedProcedureNode>();
    j.get_to(*k);
    p = std::static_pointer_cast<PlanNode>(k);
    return;
  }

  throw TypeError(type + " no abstract type PlanNode ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
AggregationNode::AggregationNode() noexcept {
  _type = ".AggregationNode";
}

void to_json(json& j, const AggregationNode& p) {
  j = json::object();
  j["@type"] = ".AggregationNode";
  to_json_key(j, "id", p.id, "AggregationNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "AggregationNode", "PlanNode", "source");
  to_json_key(
      j,
      "aggregations",
      p.aggregations,
      "AggregationNode",
      "Map<VariableReferenceExpression, Aggregation>",
      "aggregations");
  to_json_key(
      j,
      "groupingSets",
      p.groupingSets,
      "AggregationNode",
      "GroupingSetDescriptor",
      "groupingSets");
  to_json_key(
      j,
      "preGroupedVariables",
      p.preGroupedVariables,
      "AggregationNode",
      "List<VariableReferenceExpression>",
      "preGroupedVariables");
  to_json_key(
      j, "step", p.step, "AggregationNode", "AggregationNodeStep", "step");
  to_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "AggregationNode",
      "VariableReferenceExpression",
      "hashVariable");
  to_json_key(
      j,
      "groupIdVariable",
      p.groupIdVariable,
      "AggregationNode",
      "VariableReferenceExpression",
      "groupIdVariable");
  to_json_key(
      j,
      "aggregationId",
      p.aggregationId,
      "AggregationNode",
      "Integer",
      "aggregationId");
}

void from_json(const json& j, AggregationNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "AggregationNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "AggregationNode", "PlanNode", "source");
  from_json_key(
      j,
      "aggregations",
      p.aggregations,
      "AggregationNode",
      "Map<VariableReferenceExpression, Aggregation>",
      "aggregations");
  from_json_key(
      j,
      "groupingSets",
      p.groupingSets,
      "AggregationNode",
      "GroupingSetDescriptor",
      "groupingSets");
  from_json_key(
      j,
      "preGroupedVariables",
      p.preGroupedVariables,
      "AggregationNode",
      "List<VariableReferenceExpression>",
      "preGroupedVariables");
  from_json_key(
      j, "step", p.step, "AggregationNode", "AggregationNodeStep", "step");
  from_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "AggregationNode",
      "VariableReferenceExpression",
      "hashVariable");
  from_json_key(
      j,
      "groupIdVariable",
      p.groupIdVariable,
      "AggregationNode",
      "VariableReferenceExpression",
      "groupIdVariable");
  from_json_key(
      j,
      "aggregationId",
      p.aggregationId,
      "AggregationNode",
      "Integer",
      "aggregationId");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
AllOrNoneValueSet::AllOrNoneValueSet() noexcept {
  _type = "allOrNone";
}

void to_json(json& j, const AllOrNoneValueSet& p) {
  j = json::object();
  j["@type"] = "allOrNone";
  to_json_key(j, "type", p.type, "AllOrNoneValueSet", "Type", "type");
  to_json_key(j, "all", p.all, "AllOrNoneValueSet", "bool", "all");
}

void from_json(const json& j, AllOrNoneValueSet& p) {
  p._type = j["@type"];
  from_json_key(j, "type", p.type, "AllOrNoneValueSet", "Type", "type");
  from_json_key(j, "all", p.all, "AllOrNoneValueSet", "bool", "all");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ConnectorTableHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;
  getConnectorProtocol(type).to_json(j, p);
}

void from_json(const json& j, std::shared_ptr<ConnectorTableHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) + " ConnectorTableHandle  ConnectorTableHandle");
  }
  getConnectorProtocol(type).from_json(j, p);
}
} // namespace facebook::presto::protocol
// dependency TpchTransactionHandle
// dependency TpcdsTransactionHandle
// dependency ArrowTransactionHandle

namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ConnectorTransactionHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "$remote") {
    j = *std::static_pointer_cast<RemoteTransactionHandle>(p);
    return;
  }
  getConnectorProtocol(type).to_json(j, p);
}

void from_json(const json& j, std::shared_ptr<ConnectorTransactionHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) +
        " ConnectorTransactionHandle  ConnectorTransactionHandle");
  }

  if (type == "$remote") {
    auto k = std::make_shared<RemoteTransactionHandle>();
    j.get_to(*k);
    p = k;
    return;
  }
  getConnectorProtocol(type).from_json(j, p);
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const AnalyzeTableHandle& p) {
  j = json::object();
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "AnalyzeTableHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "AnalyzeTableHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  to_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "AnalyzeTableHandle",
      "ConnectorTableHandle",
      "connectorHandle");
}

void from_json(const json& j, AnalyzeTableHandle& p) {
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "AnalyzeTableHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "AnalyzeTableHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  from_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "AnalyzeTableHandle",
      "ConnectorTableHandle",
      "connectorHandle");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
AssignUniqueId::AssignUniqueId() noexcept {
  _type = "com.facebook.presto.sql.planner.plan.AssignUniqueId";
}

void to_json(json& j, const AssignUniqueId& p) {
  j = json::object();
  j["@type"] = "com.facebook.presto.sql.planner.plan.AssignUniqueId";
  to_json_key(j, "id", p.id, "AssignUniqueId", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "AssignUniqueId", "PlanNode", "source");
  to_json_key(
      j,
      "idVariable",
      p.idVariable,
      "AssignUniqueId",
      "VariableReferenceExpression",
      "idVariable");
}

void from_json(const json& j, AssignUniqueId& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "AssignUniqueId", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "AssignUniqueId", "PlanNode", "source");
  from_json_key(
      j,
      "idVariable",
      p.idVariable,
      "AssignUniqueId",
      "VariableReferenceExpression",
      "idVariable");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Assignments& p) {
  j = json::object();
  to_json_key(
      j,
      "assignments",
      p.assignments,
      "Assignments",
      "Map<VariableReferenceExpression, std::shared_ptr<RowExpression>>",
      "assignments");
}

void from_json(const json& j, Assignments& p) {
  from_json_key(
      j,
      "assignments",
      p.assignments,
      "Assignments",
      "Map<VariableReferenceExpression, std::shared_ptr<RowExpression>>",
      "assignments");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
BaseInputDistribution::BaseInputDistribution() noexcept {
  _type = ".BaseInputDistribution";
}

void to_json(json& j, const BaseInputDistribution& p) {
  j = json::object();
  j["@type"] = ".BaseInputDistribution";
  to_json_key(
      j,
      "partitionBy",
      p.partitionBy,
      "BaseInputDistribution",
      "List<VariableReferenceExpression>",
      "partitionBy");
  to_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "BaseInputDistribution",
      "OrderingScheme",
      "orderingScheme");
  to_json_key(
      j,
      "inputVariables",
      p.inputVariables,
      "BaseInputDistribution",
      "List<VariableReferenceExpression>",
      "inputVariables");
}

void from_json(const json& j, BaseInputDistribution& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "partitionBy",
      p.partitionBy,
      "BaseInputDistribution",
      "List<VariableReferenceExpression>",
      "partitionBy");
  from_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "BaseInputDistribution",
      "OrderingScheme",
      "orderingScheme");
  from_json_key(
      j,
      "inputVariables",
      p.inputVariables,
      "BaseInputDistribution",
      "List<VariableReferenceExpression>",
      "inputVariables");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<BufferType, json> BufferType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {BufferType::PARTITIONED, "PARTITIONED"},
        {BufferType::BROADCAST, "BROADCAST"},
        {BufferType::ARBITRARY, "ARBITRARY"},
        {BufferType::DISCARDING, "DISCARDING"},
        {BufferType::SPOOLING, "SPOOLING"}};
void to_json(json& j, const BufferType& e) {
  static_assert(std::is_enum<BufferType>::value, "BufferType must be an enum!");
  const auto* it = std::find_if(
      std::begin(BufferType_enum_table),
      std::end(BufferType_enum_table),
      [e](const std::pair<BufferType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(BufferType_enum_table))
           ? it
           : std::begin(BufferType_enum_table))
          ->second;
}
void from_json(const json& j, BufferType& e) {
  static_assert(std::is_enum<BufferType>::value, "BufferType must be an enum!");
  const auto* it = std::find_if(
      std::begin(BufferType_enum_table),
      std::end(BufferType_enum_table),
      [&j](const std::pair<BufferType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(BufferType_enum_table))
           ? it
           : std::begin(BufferType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const OutputBuffers& p) {
  j = json::object();
  to_json_key(j, "type", p.type, "OutputBuffers", "BufferType", "type");
  to_json_key(j, "version", p.version, "OutputBuffers", "int64_t", "version");
  to_json_key(
      j,
      "noMoreBufferIds",
      p.noMoreBufferIds,
      "OutputBuffers",
      "bool",
      "noMoreBufferIds");
  to_json_key(
      j,
      "buffers",
      p.buffers,
      "OutputBuffers",
      "Map<OutputBufferId, Integer>",
      "buffers");
}

void from_json(const json& j, OutputBuffers& p) {
  from_json_key(j, "type", p.type, "OutputBuffers", "BufferType", "type");
  from_json_key(j, "version", p.version, "OutputBuffers", "int64_t", "version");
  from_json_key(
      j,
      "noMoreBufferIds",
      p.noMoreBufferIds,
      "OutputBuffers",
      "bool",
      "noMoreBufferIds");
  from_json_key(
      j,
      "buffers",
      p.buffers,
      "OutputBuffers",
      "Map<OutputBufferId, Integer>",
      "buffers");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(nlohmann::json& j, const DataSize& p) {
  j = p.toString();
}

void from_json(const nlohmann::json& j, DataSize& p) {
  p = DataSize(std::string(j));
}

std::ostream& operator<<(std::ostream& os, const DataSize& d) {
  return os << d.toString();
}

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Duration& p) {
  j = p.toString();
}

void from_json(const json& j, Duration& p) {
  p = Duration(std::string(j));
}

std::ostream& operator<<(std::ostream& os, const Duration& d) {
  return os << d.toString();
}

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const ResourceEstimates& p) {
  j = json::object();
  to_json_key(
      j,
      "executionTime",
      p.executionTime,
      "ResourceEstimates",
      "Duration",
      "executionTime");
  to_json_key(
      j, "cpuTime", p.cpuTime, "ResourceEstimates", "Duration", "cpuTime");
  to_json_key(
      j,
      "peakMemory",
      p.peakMemory,
      "ResourceEstimates",
      "DataSize",
      "peakMemory");
  to_json_key(
      j,
      "peakTaskMemory",
      p.peakTaskMemory,
      "ResourceEstimates",
      "DataSize",
      "peakTaskMemory");
}

void from_json(const json& j, ResourceEstimates& p) {
  from_json_key(
      j,
      "executionTime",
      p.executionTime,
      "ResourceEstimates",
      "Duration",
      "executionTime");
  from_json_key(
      j, "cpuTime", p.cpuTime, "ResourceEstimates", "Duration", "cpuTime");
  from_json_key(
      j,
      "peakMemory",
      p.peakMemory,
      "ResourceEstimates",
      "DataSize",
      "peakMemory");
  from_json_key(
      j,
      "peakTaskMemory",
      p.peakTaskMemory,
      "ResourceEstimates",
      "DataSize",
      "peakTaskMemory");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<SelectedRoleType, json> SelectedRoleType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {SelectedRoleType::ROLE, "ROLE"},
        {SelectedRoleType::ALL, "ALL"},
        {SelectedRoleType::NONE, "NONE"}};
void to_json(json& j, const SelectedRoleType& e) {
  static_assert(
      std::is_enum<SelectedRoleType>::value,
      "SelectedRoleType must be an enum!");
  const auto* it = std::find_if(
      std::begin(SelectedRoleType_enum_table),
      std::end(SelectedRoleType_enum_table),
      [e](const std::pair<SelectedRoleType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(SelectedRoleType_enum_table))
           ? it
           : std::begin(SelectedRoleType_enum_table))
          ->second;
}
void from_json(const json& j, SelectedRoleType& e) {
  static_assert(
      std::is_enum<SelectedRoleType>::value,
      "SelectedRoleType must be an enum!");
  const auto* it = std::find_if(
      std::begin(SelectedRoleType_enum_table),
      std::end(SelectedRoleType_enum_table),
      [&j](const std::pair<SelectedRoleType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(SelectedRoleType_enum_table))
           ? it
           : std::begin(SelectedRoleType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const SelectedRole& p) {
  j = json::object();
  to_json_key(j, "type", p.type, "SelectedRole", "SelectedRoleType", "type");
  to_json_key(j, "role", p.role, "SelectedRole", "String", "role");
}

void from_json(const json& j, SelectedRole& p) {
  from_json_key(j, "type", p.type, "SelectedRole", "SelectedRoleType", "type");
  from_json_key(j, "role", p.role, "SelectedRole", "String", "role");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Parameter& p) {
  j = json::object();
  to_json_key(j, "name", p.name, "Parameter", "String", "name");
  to_json_key(j, "type", p.type, "Parameter", "TypeSignature", "type");
}

void from_json(const json& j, Parameter& p) {
  from_json_key(j, "name", p.name, "Parameter", "String", "name");
  from_json_key(j, "type", p.type, "Parameter", "TypeSignature", "type");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<Determinism, json> Determinism_enum_table[] = {
    // NOLINT: cert-err58-cpp
    {Determinism::DETERMINISTIC, "DETERMINISTIC"},
    {Determinism::NOT_DETERMINISTIC, "NOT_DETERMINISTIC"},
};
void to_json(json& j, const Determinism& e) {
  static_assert(
      std::is_enum<Determinism>::value, "Determinism must be an enum!");
  const auto* it = std::find_if(
      std::begin(Determinism_enum_table),
      std::end(Determinism_enum_table),
      [e](const std::pair<Determinism, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(Determinism_enum_table))
           ? it
           : std::begin(Determinism_enum_table))
          ->second;
}
void from_json(const json& j, Determinism& e) {
  static_assert(
      std::is_enum<Determinism>::value, "Determinism must be an enum!");
  const auto* it = std::find_if(
      std::begin(Determinism_enum_table),
      std::end(Determinism_enum_table),
      [&j](const std::pair<Determinism, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(Determinism_enum_table))
           ? it
           : std::begin(Determinism_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Language& p) {
  json tj = json::object();
  to_json_key(tj, "language", p.language, "Language", "String", "language");
  j = tj["language"];
}

void from_json(const json& j, Language& p) {
  from_json_key(j, "language", p.language, "Language", "String", "language");
}

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<NullCallClause, json> NullCallClause_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {NullCallClause::RETURNS_NULL_ON_NULL_INPUT,
         "RETURNS_NULL_ON_NULL_INPUT"},
        {NullCallClause::CALLED_ON_NULL_INPUT, "CALLED_ON_NULL_INPUT"}};
void to_json(json& j, const NullCallClause& e) {
  static_assert(
      std::is_enum<NullCallClause>::value, "NullCallClause must be an enum!");
  const auto* it = std::find_if(
      std::begin(NullCallClause_enum_table),
      std::end(NullCallClause_enum_table),
      [e](const std::pair<NullCallClause, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(NullCallClause_enum_table))
           ? it
           : std::begin(NullCallClause_enum_table))
          ->second;
}
void from_json(const json& j, NullCallClause& e) {
  static_assert(
      std::is_enum<NullCallClause>::value, "NullCallClause must be an enum!");
  const auto* it = std::find_if(
      std::begin(NullCallClause_enum_table),
      std::end(NullCallClause_enum_table),
      [&j](const std::pair<NullCallClause, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(NullCallClause_enum_table))
           ? it
           : std::begin(NullCallClause_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const RoutineCharacteristics& p) {
  j = json::object();
  to_json_key(
      j,
      "language",
      p.language,
      "RoutineCharacteristics",
      "Language",
      "language");
  to_json_key(
      j,
      "determinism",
      p.determinism,
      "RoutineCharacteristics",
      "Determinism",
      "determinism");
  to_json_key(
      j,
      "nullCallClause",
      p.nullCallClause,
      "RoutineCharacteristics",
      "NullCallClause",
      "nullCallClause");
}

void from_json(const json& j, RoutineCharacteristics& p) {
  from_json_key(
      j,
      "language",
      p.language,
      "RoutineCharacteristics",
      "Language",
      "language");
  from_json_key(
      j,
      "determinism",
      p.determinism,
      "RoutineCharacteristics",
      "Determinism",
      "determinism");
  from_json_key(
      j,
      "nullCallClause",
      p.nullCallClause,
      "RoutineCharacteristics",
      "NullCallClause",
      "nullCallClause");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<FunctionKind, json> FunctionKind_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {FunctionKind::SCALAR, "SCALAR"},
        {FunctionKind::AGGREGATE, "AGGREGATE"},
        {FunctionKind::WINDOW, "WINDOW"}};
void to_json(json& j, const FunctionKind& e) {
  static_assert(
      std::is_enum<FunctionKind>::value, "FunctionKind must be an enum!");
  const auto* it = std::find_if(
      std::begin(FunctionKind_enum_table),
      std::end(FunctionKind_enum_table),
      [e](const std::pair<FunctionKind, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(FunctionKind_enum_table))
           ? it
           : std::begin(FunctionKind_enum_table))
          ->second;
}
void from_json(const json& j, FunctionKind& e) {
  static_assert(
      std::is_enum<FunctionKind>::value, "FunctionKind must be an enum!");
  const auto* it = std::find_if(
      std::begin(FunctionKind_enum_table),
      std::end(FunctionKind_enum_table),
      [&j](const std::pair<FunctionKind, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(FunctionKind_enum_table))
           ? it
           : std::begin(FunctionKind_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const LongVariableConstraint& p) {
  j = json::object();
  to_json_key(j, "name", p.name, "LongVariableConstraint", "String", "name");
  to_json_key(
      j,
      "expression",
      p.expression,
      "LongVariableConstraint",
      "String",
      "expression");
}

void from_json(const json& j, LongVariableConstraint& p) {
  from_json_key(j, "name", p.name, "LongVariableConstraint", "String", "name");
  from_json_key(
      j,
      "expression",
      p.expression,
      "LongVariableConstraint",
      "String",
      "expression");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const TypeVariableConstraint& p) {
  j = json::object();
  to_json_key(j, "name", p.name, "TypeVariableConstraint", "String", "name");
  to_json_key(
      j,
      "comparableRequired",
      p.comparableRequired,
      "TypeVariableConstraint",
      "bool",
      "comparableRequired");
  to_json_key(
      j,
      "orderableRequired",
      p.orderableRequired,
      "TypeVariableConstraint",
      "bool",
      "orderableRequired");
  to_json_key(
      j,
      "variadicBound",
      p.variadicBound,
      "TypeVariableConstraint",
      "String",
      "variadicBound");
  to_json_key(
      j,
      "nonDecimalNumericRequired",
      p.nonDecimalNumericRequired,
      "TypeVariableConstraint",
      "bool",
      "nonDecimalNumericRequired");
}

void from_json(const json& j, TypeVariableConstraint& p) {
  from_json_key(j, "name", p.name, "TypeVariableConstraint", "String", "name");
  from_json_key(
      j,
      "comparableRequired",
      p.comparableRequired,
      "TypeVariableConstraint",
      "bool",
      "comparableRequired");
  from_json_key(
      j,
      "orderableRequired",
      p.orderableRequired,
      "TypeVariableConstraint",
      "bool",
      "orderableRequired");
  from_json_key(
      j,
      "variadicBound",
      p.variadicBound,
      "TypeVariableConstraint",
      "String",
      "variadicBound");
  from_json_key(
      j,
      "nonDecimalNumericRequired",
      p.nonDecimalNumericRequired,
      "TypeVariableConstraint",
      "bool",
      "nonDecimalNumericRequired");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Signature& p) {
  j = json::object();
  to_json_key(j, "name", p.name, "Signature", "QualifiedObjectName", "name");
  to_json_key(j, "kind", p.kind, "Signature", "FunctionKind", "kind");
  to_json_key(
      j,
      "typeVariableConstraints",
      p.typeVariableConstraints,
      "Signature",
      "List<TypeVariableConstraint>",
      "typeVariableConstraints");
  to_json_key(
      j,
      "longVariableConstraints",
      p.longVariableConstraints,
      "Signature",
      "List<LongVariableConstraint>",
      "longVariableConstraints");
  to_json_key(
      j,
      "returnType",
      p.returnType,
      "Signature",
      "TypeSignature",
      "returnType");
  to_json_key(
      j,
      "argumentTypes",
      p.argumentTypes,
      "Signature",
      "List<TypeSignature>",
      "argumentTypes");
  to_json_key(
      j,
      "variableArity",
      p.variableArity,
      "Signature",
      "bool",
      "variableArity");
}

void from_json(const json& j, Signature& p) {
  from_json_key(j, "name", p.name, "Signature", "QualifiedObjectName", "name");
  from_json_key(j, "kind", p.kind, "Signature", "FunctionKind", "kind");
  from_json_key(
      j,
      "typeVariableConstraints",
      p.typeVariableConstraints,
      "Signature",
      "List<TypeVariableConstraint>",
      "typeVariableConstraints");
  from_json_key(
      j,
      "longVariableConstraints",
      p.longVariableConstraints,
      "Signature",
      "List<LongVariableConstraint>",
      "longVariableConstraints");
  from_json_key(
      j,
      "returnType",
      p.returnType,
      "Signature",
      "TypeSignature",
      "returnType");
  from_json_key(
      j,
      "argumentTypes",
      p.argumentTypes,
      "Signature",
      "List<TypeSignature>",
      "argumentTypes");
  from_json_key(
      j,
      "variableArity",
      p.variableArity,
      "Signature",
      "bool",
      "variableArity");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const SqlInvokedFunction& p) {
  j = json::object();
  to_json_key(
      j,
      "parameters",
      p.parameters,
      "SqlInvokedFunction",
      "List<Parameter>",
      "parameters");
  to_json_key(
      j,
      "description",
      p.description,
      "SqlInvokedFunction",
      "String",
      "description");
  to_json_key(
      j,
      "routineCharacteristics",
      p.routineCharacteristics,
      "SqlInvokedFunction",
      "RoutineCharacteristics",
      "routineCharacteristics");
  to_json_key(j, "body", p.body, "SqlInvokedFunction", "String", "body");
  to_json_key(
      j,
      "variableArity",
      p.variableArity,
      "SqlInvokedFunction",
      "bool",
      "variableArity");
  to_json_key(
      j,
      "signature",
      p.signature,
      "SqlInvokedFunction",
      "Signature",
      "signature");
  to_json_key(
      j,
      "functionId",
      p.functionId,
      "SqlInvokedFunction",
      "SqlFunctionId",
      "functionId");
}

void from_json(const json& j, SqlInvokedFunction& p) {
  from_json_key(
      j,
      "parameters",
      p.parameters,
      "SqlInvokedFunction",
      "List<Parameter>",
      "parameters");
  from_json_key(
      j,
      "description",
      p.description,
      "SqlInvokedFunction",
      "String",
      "description");
  from_json_key(
      j,
      "routineCharacteristics",
      p.routineCharacteristics,
      "SqlInvokedFunction",
      "RoutineCharacteristics",
      "routineCharacteristics");
  from_json_key(j, "body", p.body, "SqlInvokedFunction", "String", "body");
  from_json_key(
      j,
      "variableArity",
      p.variableArity,
      "SqlInvokedFunction",
      "bool",
      "variableArity");
  from_json_key(
      j,
      "signature",
      p.signature,
      "SqlInvokedFunction",
      "Signature",
      "signature");
  from_json_key(
      j,
      "functionId",
      p.functionId,
      "SqlInvokedFunction",
      "SqlFunctionId",
      "functionId");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const SessionRepresentation& p) {
  j = json::object();
  to_json_key(
      j, "queryId", p.queryId, "SessionRepresentation", "String", "queryId");
  to_json_key(
      j,
      "transactionId",
      p.transactionId,
      "SessionRepresentation",
      "TransactionId",
      "transactionId");
  to_json_key(
      j,
      "clientTransactionSupport",
      p.clientTransactionSupport,
      "SessionRepresentation",
      "bool",
      "clientTransactionSupport");
  to_json_key(j, "user", p.user, "SessionRepresentation", "String", "user");
  to_json_key(
      j,
      "principal",
      p.principal,
      "SessionRepresentation",
      "String",
      "principal");
  to_json_key(
      j, "source", p.source, "SessionRepresentation", "String", "source");
  to_json_key(
      j, "catalog", p.catalog, "SessionRepresentation", "String", "catalog");
  to_json_key(
      j, "schema", p.schema, "SessionRepresentation", "String", "schema");
  to_json_key(
      j,
      "traceToken",
      p.traceToken,
      "SessionRepresentation",
      "String",
      "traceToken");
  to_json_key(
      j,
      "timeZoneKey",
      p.timeZoneKey,
      "SessionRepresentation",
      "TimeZoneKey",
      "timeZoneKey");
  to_json_key(
      j, "locale", p.locale, "SessionRepresentation", "Locale", "locale");
  to_json_key(
      j,
      "remoteUserAddress",
      p.remoteUserAddress,
      "SessionRepresentation",
      "String",
      "remoteUserAddress");
  to_json_key(
      j,
      "userAgent",
      p.userAgent,
      "SessionRepresentation",
      "String",
      "userAgent");
  to_json_key(
      j,
      "clientInfo",
      p.clientInfo,
      "SessionRepresentation",
      "String",
      "clientInfo");
  to_json_key(
      j,
      "clientTags",
      p.clientTags,
      "SessionRepresentation",
      "List<String>",
      "clientTags");
  to_json_key(
      j,
      "resourceEstimates",
      p.resourceEstimates,
      "SessionRepresentation",
      "ResourceEstimates",
      "resourceEstimates");
  to_json_key(
      j,
      "startTime",
      p.startTime,
      "SessionRepresentation",
      "int64_t",
      "startTime");
  to_json_key(
      j,
      "systemProperties",
      p.systemProperties,
      "SessionRepresentation",
      "Map<String, String>",
      "systemProperties");
  to_json_key(
      j,
      "catalogProperties",
      p.catalogProperties,
      "SessionRepresentation",
      "Map<ConnectorId, Map<String, String>>",
      "catalogProperties");
  to_json_key(
      j,
      "unprocessedCatalogProperties",
      p.unprocessedCatalogProperties,
      "SessionRepresentation",
      "Map<String, Map<String, String>>",
      "unprocessedCatalogProperties");
  to_json_key(
      j,
      "roles",
      p.roles,
      "SessionRepresentation",
      "Map<String, SelectedRole>",
      "roles");
  to_json_key(
      j,
      "preparedStatements",
      p.preparedStatements,
      "SessionRepresentation",
      "Map<String, String>",
      "preparedStatements");
  to_json_key(
      j,
      "sessionFunctions",
      p.sessionFunctions,
      "SessionRepresentation",
      "Map<SqlFunctionId, SqlInvokedFunction>",
      "sessionFunctions");
}

void from_json(const json& j, SessionRepresentation& p) {
  from_json_key(
      j, "queryId", p.queryId, "SessionRepresentation", "String", "queryId");
  from_json_key(
      j,
      "transactionId",
      p.transactionId,
      "SessionRepresentation",
      "TransactionId",
      "transactionId");
  from_json_key(
      j,
      "clientTransactionSupport",
      p.clientTransactionSupport,
      "SessionRepresentation",
      "bool",
      "clientTransactionSupport");
  from_json_key(j, "user", p.user, "SessionRepresentation", "String", "user");
  from_json_key(
      j,
      "principal",
      p.principal,
      "SessionRepresentation",
      "String",
      "principal");
  from_json_key(
      j, "source", p.source, "SessionRepresentation", "String", "source");
  from_json_key(
      j, "catalog", p.catalog, "SessionRepresentation", "String", "catalog");
  from_json_key(
      j, "schema", p.schema, "SessionRepresentation", "String", "schema");
  from_json_key(
      j,
      "traceToken",
      p.traceToken,
      "SessionRepresentation",
      "String",
      "traceToken");
  from_json_key(
      j,
      "timeZoneKey",
      p.timeZoneKey,
      "SessionRepresentation",
      "TimeZoneKey",
      "timeZoneKey");
  from_json_key(
      j, "locale", p.locale, "SessionRepresentation", "Locale", "locale");
  from_json_key(
      j,
      "remoteUserAddress",
      p.remoteUserAddress,
      "SessionRepresentation",
      "String",
      "remoteUserAddress");
  from_json_key(
      j,
      "userAgent",
      p.userAgent,
      "SessionRepresentation",
      "String",
      "userAgent");
  from_json_key(
      j,
      "clientInfo",
      p.clientInfo,
      "SessionRepresentation",
      "String",
      "clientInfo");
  from_json_key(
      j,
      "clientTags",
      p.clientTags,
      "SessionRepresentation",
      "List<String>",
      "clientTags");
  from_json_key(
      j,
      "resourceEstimates",
      p.resourceEstimates,
      "SessionRepresentation",
      "ResourceEstimates",
      "resourceEstimates");
  from_json_key(
      j,
      "startTime",
      p.startTime,
      "SessionRepresentation",
      "int64_t",
      "startTime");
  from_json_key(
      j,
      "systemProperties",
      p.systemProperties,
      "SessionRepresentation",
      "Map<String, String>",
      "systemProperties");
  from_json_key(
      j,
      "catalogProperties",
      p.catalogProperties,
      "SessionRepresentation",
      "Map<ConnectorId, Map<String, String>>",
      "catalogProperties");
  from_json_key(
      j,
      "unprocessedCatalogProperties",
      p.unprocessedCatalogProperties,
      "SessionRepresentation",
      "Map<String, Map<String, String>>",
      "unprocessedCatalogProperties");
  from_json_key(
      j,
      "roles",
      p.roles,
      "SessionRepresentation",
      "Map<String, SelectedRole>",
      "roles");
  from_json_key(
      j,
      "preparedStatements",
      p.preparedStatements,
      "SessionRepresentation",
      "Map<String, String>",
      "preparedStatements");
  from_json_key(
      j,
      "sessionFunctions",
      p.sessionFunctions,
      "SessionRepresentation",
      "Map<SqlFunctionId, SqlInvokedFunction>",
      "sessionFunctions");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ExecutionWriterTarget>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "CreateHandle") {
    j = *std::static_pointer_cast<CreateHandle>(p);
    return;
  }
  if (type == "RefreshMaterializedViewHandle") {
    j = *std::static_pointer_cast<InsertHandle>(p);
    return;
  }
  if (type == "InsertHandle") {
    j = *std::static_pointer_cast<InsertHandle>(p);
    return;
  }
  if (type == "DeleteHandle") {
    j = *std::static_pointer_cast<DeleteHandle>(p);
    return;
  }
  if (type == "UpdateHandle") {
    j = *std::static_pointer_cast<UpdateHandle>(p);
    return;
  }
  if (type == "ExecuteProcedureHandle") {
    j = *std::static_pointer_cast<ExecuteProcedureHandle>(p);
    return;
  }
  if (type == "MergeHandle") {
    j = *std::static_pointer_cast<MergeHandle>(p);
    return;
  }

  throw TypeError(type + " no abstract type ExecutionWriterTarget ");
}

void from_json(const json& j, std::shared_ptr<ExecutionWriterTarget>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) +
        " ExecutionWriterTarget  ExecutionWriterTarget");
  }

  if (type == "CreateHandle") {
    std::shared_ptr<CreateHandle> k = std::make_shared<CreateHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ExecutionWriterTarget>(k);
    return;
  }
  if (type == "RefreshMaterializedViewHandle") {
    std::shared_ptr<InsertHandle> k = std::make_shared<InsertHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ExecutionWriterTarget>(k);
    return;
  }
  if (type == "InsertHandle") {
    std::shared_ptr<InsertHandle> k = std::make_shared<InsertHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ExecutionWriterTarget>(k);
    return;
  }
  if (type == "DeleteHandle") {
    std::shared_ptr<DeleteHandle> k = std::make_shared<DeleteHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ExecutionWriterTarget>(k);
    return;
  }
  if (type == "UpdateHandle") {
    std::shared_ptr<UpdateHandle> k = std::make_shared<UpdateHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ExecutionWriterTarget>(k);
    return;
  }
  if (type == "ExecuteProcedureHandle") {
    std::shared_ptr<ExecuteProcedureHandle> k =
        std::make_shared<ExecuteProcedureHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ExecutionWriterTarget>(k);
    return;
  }
  if (type == "MergeHandle") {
    std::shared_ptr<MergeHandle> k = std::make_shared<MergeHandle>();
    j.get_to(*k);
    p = std::static_pointer_cast<ExecutionWriterTarget>(k);
    return;
  }

  throw TypeError(type + " no abstract type ExecutionWriterTarget ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const TableWriteInfo& p) {
  j = json::object();
  to_json_key(
      j,
      "writerTarget",
      p.writerTarget,
      "TableWriteInfo",
      "ExecutionWriterTarget",
      "writerTarget");
  to_json_key(
      j,
      "analyzeTableHandle",
      p.analyzeTableHandle,
      "TableWriteInfo",
      "AnalyzeTableHandle",
      "analyzeTableHandle");
}

void from_json(const json& j, TableWriteInfo& p) {
  from_json_key(
      j,
      "writerTarget",
      p.writerTarget,
      "TableWriteInfo",
      "ExecutionWriterTarget",
      "writerTarget");
  from_json_key(
      j,
      "analyzeTableHandle",
      p.analyzeTableHandle,
      "TableWriteInfo",
      "AnalyzeTableHandle",
      "analyzeTableHandle");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Lifespan& p) {
  if (p.isgroup) {
    j = "Group" + std::to_string(p.groupid);
  } else {
    j = "TaskWide";
  }
}

void from_json(const json& j, Lifespan& p) {
  String lifespan = j;

  if (lifespan == "TaskWide") {
    p.isgroup = false;
    p.groupid = 0;
  } else {
    if (lifespan != "Group") {
      // fail...
    }
    p.isgroup = true;
    p.groupid = std::stoi(lifespan.substr(strlen("Group")));
  }
}

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ConnectorSplit>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "$remote") {
    j = *std::static_pointer_cast<RemoteSplit>(p);
    return;
  }
  if (type == "$empty") {
    j = *std::static_pointer_cast<EmptySplit>(p);
    return;
  }
  getConnectorProtocol(type).to_json(j, p);
}

void from_json(const json& j, std::shared_ptr<ConnectorSplit>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " ConnectorSplit");
  }

  if (type == "$remote") {
    auto k = std::make_shared<RemoteSplit>();
    j.get_to(*k);
    p = k;
    return;
  }
  if (type == "$empty") {
    auto k = std::make_shared<EmptySplit>();
    j.get_to(*k);
    p = k;
    return;
  }
  getConnectorProtocol(type).from_json(j, p);
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const SplitContext& p) {
  j = json::object();
  to_json_key(j, "cacheable", p.cacheable, "SplitContext", "bool", "cacheable");
}

void from_json(const json& j, SplitContext& p) {
  from_json_key(
      j, "cacheable", p.cacheable, "SplitContext", "bool", "cacheable");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Split& p) {
  j = json::object();
  to_json_key(
      j, "connectorId", p.connectorId, "Split", "ConnectorId", "connectorId");
  to_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "Split",
      "ConnectorTransactionHandle",
      "transactionHandle");
  to_json_key(
      j,
      "connectorSplit",
      p.connectorSplit,
      "Split",
      "ConnectorSplit",
      "connectorSplit");
  to_json_key(j, "lifespan", p.lifespan, "Split", "Lifespan", "lifespan");
  to_json_key(
      j,
      "splitContext",
      p.splitContext,
      "Split",
      "SplitContext",
      "splitContext");
}

void from_json(const json& j, Split& p) {
  from_json_key(
      j, "connectorId", p.connectorId, "Split", "ConnectorId", "connectorId");
  from_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "Split",
      "ConnectorTransactionHandle",
      "transactionHandle");
  from_json_key(
      j,
      "connectorSplit",
      p.connectorSplit,
      "Split",
      "ConnectorSplit",
      "connectorSplit");
  from_json_key(j, "lifespan", p.lifespan, "Split", "Lifespan", "lifespan");
  from_json_key(
      j,
      "splitContext",
      p.splitContext,
      "Split",
      "SplitContext",
      "splitContext");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const ScheduledSplit& p) {
  j = json::object();
  to_json_key(
      j, "sequenceId", p.sequenceId, "ScheduledSplit", "int64_t", "sequenceId");
  to_json_key(
      j,
      "planNodeId",
      p.planNodeId,
      "ScheduledSplit",
      "PlanNodeId",
      "planNodeId");
  to_json_key(j, "split", p.split, "ScheduledSplit", "Split", "split");
}

void from_json(const json& j, ScheduledSplit& p) {
  from_json_key(
      j, "sequenceId", p.sequenceId, "ScheduledSplit", "int64_t", "sequenceId");
  from_json_key(
      j,
      "planNodeId",
      p.planNodeId,
      "ScheduledSplit",
      "PlanNodeId",
      "planNodeId");
  from_json_key(j, "split", p.split, "ScheduledSplit", "Split", "split");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const TaskSource& p) {
  j = json::object();
  to_json_key(
      j, "planNodeId", p.planNodeId, "TaskSource", "PlanNodeId", "planNodeId");
  to_json_key(
      j, "splits", p.splits, "TaskSource", "List<ScheduledSplit>", "splits");
  to_json_key(
      j,
      "noMoreSplitsForLifespan",
      p.noMoreSplitsForLifespan,
      "TaskSource",
      "List<Lifespan>",
      "noMoreSplitsForLifespan");
  to_json_key(
      j, "noMoreSplits", p.noMoreSplits, "TaskSource", "bool", "noMoreSplits");
}

void from_json(const json& j, TaskSource& p) {
  from_json_key(
      j, "planNodeId", p.planNodeId, "TaskSource", "PlanNodeId", "planNodeId");
  from_json_key(
      j, "splits", p.splits, "TaskSource", "List<ScheduledSplit>", "splits");
  from_json_key(
      j,
      "noMoreSplitsForLifespan",
      p.noMoreSplitsForLifespan,
      "TaskSource",
      "List<Lifespan>",
      "noMoreSplitsForLifespan");
  from_json_key(
      j, "noMoreSplits", p.noMoreSplits, "TaskSource", "bool", "noMoreSplits");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const TaskUpdateRequest& p) {
  j = json::object();
  to_json_key(
      j,
      "session",
      p.session,
      "TaskUpdateRequest",
      "SessionRepresentation",
      "session");
  to_json_key(
      j,
      "extraCredentials",
      p.extraCredentials,
      "TaskUpdateRequest",
      "Map<String, String>",
      "extraCredentials");
  to_json_key(
      j, "fragment", p.fragment, "TaskUpdateRequest", "String", "fragment");
  to_json_key(
      j,
      "sources",
      p.sources,
      "TaskUpdateRequest",
      "List<TaskSource>",
      "sources");
  to_json_key(
      j,
      "outputIds",
      p.outputIds,
      "TaskUpdateRequest",
      "OutputBuffers",
      "outputIds");
  to_json_key(
      j,
      "tableWriteInfo",
      p.tableWriteInfo,
      "TaskUpdateRequest",
      "TableWriteInfo",
      "tableWriteInfo");
}

void from_json(const json& j, TaskUpdateRequest& p) {
  from_json_key(
      j,
      "session",
      p.session,
      "TaskUpdateRequest",
      "SessionRepresentation",
      "session");
  from_json_key(
      j,
      "extraCredentials",
      p.extraCredentials,
      "TaskUpdateRequest",
      "Map<String, String>",
      "extraCredentials");
  from_json_key(
      j, "fragment", p.fragment, "TaskUpdateRequest", "String", "fragment");
  from_json_key(
      j,
      "sources",
      p.sources,
      "TaskUpdateRequest",
      "List<TaskSource>",
      "sources");
  from_json_key(
      j,
      "outputIds",
      p.outputIds,
      "TaskUpdateRequest",
      "OutputBuffers",
      "outputIds");
  from_json_key(
      j,
      "tableWriteInfo",
      p.tableWriteInfo,
      "TaskUpdateRequest",
      "TableWriteInfo",
      "tableWriteInfo");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const BatchTaskUpdateRequest& p) {
  j = json::object();
  to_json_key(
      j,
      "taskUpdateRequest",
      p.taskUpdateRequest,
      "BatchTaskUpdateRequest",
      "TaskUpdateRequest",
      "taskUpdateRequest");
  to_json_key(
      j,
      "shuffleWriteInfo",
      p.shuffleWriteInfo,
      "BatchTaskUpdateRequest",
      "String",
      "shuffleWriteInfo");
  to_json_key(
      j,
      "broadcastBasePath",
      p.broadcastBasePath,
      "BatchTaskUpdateRequest",
      "String",
      "broadcastBasePath");
}

void from_json(const json& j, BatchTaskUpdateRequest& p) {
  from_json_key(
      j,
      "taskUpdateRequest",
      p.taskUpdateRequest,
      "BatchTaskUpdateRequest",
      "TaskUpdateRequest",
      "taskUpdateRequest");
  from_json_key(
      j,
      "shuffleWriteInfo",
      p.shuffleWriteInfo,
      "BatchTaskUpdateRequest",
      "String",
      "shuffleWriteInfo");
  from_json_key(
      j,
      "broadcastBasePath",
      p.broadcastBasePath,
      "BatchTaskUpdateRequest",
      "String",
      "broadcastBasePath");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const PageBufferInfo& p) {
  j = json::object();
  to_json_key(
      j, "partition", p.partition, "PageBufferInfo", "int", "partition");
  to_json_key(
      j,
      "bufferedPages",
      p.bufferedPages,
      "PageBufferInfo",
      "int64_t",
      "bufferedPages");
  to_json_key(
      j,
      "bufferedBytes",
      p.bufferedBytes,
      "PageBufferInfo",
      "int64_t",
      "bufferedBytes");
  to_json_key(
      j, "rowsAdded", p.rowsAdded, "PageBufferInfo", "int64_t", "rowsAdded");
  to_json_key(
      j, "pagesAdded", p.pagesAdded, "PageBufferInfo", "int64_t", "pagesAdded");
}

void from_json(const json& j, PageBufferInfo& p) {
  from_json_key(
      j, "partition", p.partition, "PageBufferInfo", "int", "partition");
  from_json_key(
      j,
      "bufferedPages",
      p.bufferedPages,
      "PageBufferInfo",
      "int64_t",
      "bufferedPages");
  from_json_key(
      j,
      "bufferedBytes",
      p.bufferedBytes,
      "PageBufferInfo",
      "int64_t",
      "bufferedBytes");
  from_json_key(
      j, "rowsAdded", p.rowsAdded, "PageBufferInfo", "int64_t", "rowsAdded");
  from_json_key(
      j, "pagesAdded", p.pagesAdded, "PageBufferInfo", "int64_t", "pagesAdded");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const BufferInfo& p) {
  j = json::object();
  to_json_key(
      j, "bufferId", p.bufferId, "BufferInfo", "OutputBufferId", "bufferId");
  to_json_key(j, "finished", p.finished, "BufferInfo", "bool", "finished");
  to_json_key(
      j,
      "bufferedPages",
      p.bufferedPages,
      "BufferInfo",
      "int",
      "bufferedPages");
  to_json_key(
      j, "pagesSent", p.pagesSent, "BufferInfo", "int64_t", "pagesSent");
  to_json_key(
      j,
      "pageBufferInfo",
      p.pageBufferInfo,
      "BufferInfo",
      "PageBufferInfo",
      "pageBufferInfo");
}

void from_json(const json& j, BufferInfo& p) {
  from_json_key(
      j, "bufferId", p.bufferId, "BufferInfo", "OutputBufferId", "bufferId");
  from_json_key(j, "finished", p.finished, "BufferInfo", "bool", "finished");
  from_json_key(
      j,
      "bufferedPages",
      p.bufferedPages,
      "BufferInfo",
      "int",
      "bufferedPages");
  from_json_key(
      j, "pagesSent", p.pagesSent, "BufferInfo", "int64_t", "pagesSent");
  from_json_key(
      j,
      "pageBufferInfo",
      p.pageBufferInfo,
      "BufferInfo",
      "PageBufferInfo",
      "pageBufferInfo");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<BuiltInFunctionKind, json>
    BuiltInFunctionKind_enum_table[] =
        { // NOLINT: cert-err58-cpp
            {BuiltInFunctionKind::ENGINE, "ENGINE"},
            {BuiltInFunctionKind::PLUGIN, "PLUGIN"},
            {BuiltInFunctionKind::WORKER, "WORKER"}};
void to_json(json& j, const BuiltInFunctionKind& e) {
  static_assert(
      std::is_enum<BuiltInFunctionKind>::value,
      "BuiltInFunctionKind must be an enum!");
  const auto* it = std::find_if(
      std::begin(BuiltInFunctionKind_enum_table),
      std::end(BuiltInFunctionKind_enum_table),
      [e](const std::pair<BuiltInFunctionKind, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(BuiltInFunctionKind_enum_table))
           ? it
           : std::begin(BuiltInFunctionKind_enum_table))
          ->second;
}
void from_json(const json& j, BuiltInFunctionKind& e) {
  static_assert(
      std::is_enum<BuiltInFunctionKind>::value,
      "BuiltInFunctionKind must be an enum!");
  const auto* it = std::find_if(
      std::begin(BuiltInFunctionKind_enum_table),
      std::end(BuiltInFunctionKind_enum_table),
      [&j](const std::pair<BuiltInFunctionKind, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(BuiltInFunctionKind_enum_table))
           ? it
           : std::begin(BuiltInFunctionKind_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
BuiltInFunctionHandle::BuiltInFunctionHandle() noexcept {
  _type = "$static";
}

void to_json(json& j, const BuiltInFunctionHandle& p) {
  j = json::object();
  j["@type"] = "$static";
  to_json_key(
      j,
      "signature",
      p.signature,
      "BuiltInFunctionHandle",
      "Signature",
      "signature");
  to_json_key(
      j,
      "builtInFunctionKind",
      p.builtInFunctionKind,
      "BuiltInFunctionHandle",
      "BuiltInFunctionKind",
      "builtInFunctionKind");
}

void from_json(const json& j, BuiltInFunctionHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "signature",
      p.signature,
      "BuiltInFunctionHandle",
      "Signature",
      "signature");
  from_json_key(
      j,
      "builtInFunctionKind",
      p.builtInFunctionKind,
      "BuiltInFunctionHandle",
      "BuiltInFunctionKind",
      "builtInFunctionKind");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<CacheQuotaScope, json> CacheQuotaScope_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {CacheQuotaScope::GLOBAL, "GLOBAL"},
        {CacheQuotaScope::SCHEMA, "SCHEMA"},
        {CacheQuotaScope::TABLE, "TABLE"},
        {CacheQuotaScope::PARTITION, "PARTITION"}};
void to_json(json& j, const CacheQuotaScope& e) {
  static_assert(
      std::is_enum<CacheQuotaScope>::value, "CacheQuotaScope must be an enum!");
  const auto* it = std::find_if(
      std::begin(CacheQuotaScope_enum_table),
      std::end(CacheQuotaScope_enum_table),
      [e](const std::pair<CacheQuotaScope, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(CacheQuotaScope_enum_table))
           ? it
           : std::begin(CacheQuotaScope_enum_table))
          ->second;
}
void from_json(const json& j, CacheQuotaScope& e) {
  static_assert(
      std::is_enum<CacheQuotaScope>::value, "CacheQuotaScope must be an enum!");
  const auto* it = std::find_if(
      std::begin(CacheQuotaScope_enum_table),
      std::end(CacheQuotaScope_enum_table),
      [&j](const std::pair<CacheQuotaScope, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(CacheQuotaScope_enum_table))
           ? it
           : std::begin(CacheQuotaScope_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const CacheQuotaRequirement& p) {
  j = json::object();
  to_json_key(
      j,
      "cacheQuotaScope",
      p.cacheQuotaScope,
      "CacheQuotaRequirement",
      "CacheQuotaScope",
      "cacheQuotaScope");
  to_json_key(
      j, "quota", p.quota, "CacheQuotaRequirement", "DataSize", "quota");
}

void from_json(const json& j, CacheQuotaRequirement& p) {
  from_json_key(
      j,
      "cacheQuotaScope",
      p.cacheQuotaScope,
      "CacheQuotaRequirement",
      "CacheQuotaScope",
      "cacheQuotaScope");
  from_json_key(
      j, "quota", p.quota, "CacheQuotaRequirement", "DataSize", "quota");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<ExchangeEncoding, json> ExchangeEncoding_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {ExchangeEncoding::COLUMNAR, "COLUMNAR"},
        {ExchangeEncoding::ROW_WISE, "ROW_WISE"}};
void to_json(json& j, const ExchangeEncoding& e) {
  static_assert(
      std::is_enum<ExchangeEncoding>::value,
      "ExchangeEncoding must be an enum!");
  const auto* it = std::find_if(
      std::begin(ExchangeEncoding_enum_table),
      std::end(ExchangeEncoding_enum_table),
      [e](const std::pair<ExchangeEncoding, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(ExchangeEncoding_enum_table))
           ? it
           : std::begin(ExchangeEncoding_enum_table))
          ->second;
}
void from_json(const json& j, ExchangeEncoding& e) {
  static_assert(
      std::is_enum<ExchangeEncoding>::value,
      "ExchangeEncoding must be an enum!");
  const auto* it = std::find_if(
      std::begin(ExchangeEncoding_enum_table),
      std::end(ExchangeEncoding_enum_table),
      [&j](const std::pair<ExchangeEncoding, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(ExchangeEncoding_enum_table))
           ? it
           : std::begin(ExchangeEncoding_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ConnectorPartitioningHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "$remote") {
    j = *std::static_pointer_cast<SystemPartitioningHandle>(p);
    return;
  }
  getConnectorProtocol(type).to_json(j, p);
}

void from_json(const json& j, std::shared_ptr<ConnectorPartitioningHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " ConnectorPartitioningHandle");
  }

  if (type == "$remote") {
    auto k = std::make_shared<SystemPartitioningHandle>();
    j.get_to(*k);
    p = k;
    return;
  }
  getConnectorProtocol(type).from_json(j, p);
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const PartitioningHandle& p) {
  j = json::object();
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "PartitioningHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "PartitioningHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  to_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "PartitioningHandle",
      "ConnectorPartitioningHandle",
      "connectorHandle");
}

void from_json(const json& j, PartitioningHandle& p) {
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "PartitioningHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "PartitioningHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  from_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "PartitioningHandle",
      "ConnectorPartitioningHandle",
      "connectorHandle");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Partitioning& p) {
  j = json::object();
  to_json_key(
      j, "handle", p.handle, "Partitioning", "PartitioningHandle", "handle");
  to_json_key(
      j,
      "arguments",
      p.arguments,
      "Partitioning",
      "List<std::shared_ptr<RowExpression>>",
      "arguments");
}

void from_json(const json& j, Partitioning& p) {
  from_json_key(
      j, "handle", p.handle, "Partitioning", "PartitioningHandle", "handle");
  from_json_key(
      j,
      "arguments",
      p.arguments,
      "Partitioning",
      "List<std::shared_ptr<RowExpression>>",
      "arguments");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const PartitioningScheme& p) {
  j = json::object();
  to_json_key(
      j,
      "partitioning",
      p.partitioning,
      "PartitioningScheme",
      "Partitioning",
      "partitioning");
  to_json_key(
      j,
      "outputLayout",
      p.outputLayout,
      "PartitioningScheme",
      "List<VariableReferenceExpression>",
      "outputLayout");
  to_json_key(
      j,
      "hashColumn",
      p.hashColumn,
      "PartitioningScheme",
      "VariableReferenceExpression",
      "hashColumn");
  to_json_key(
      j,
      "replicateNullsAndAny",
      p.replicateNullsAndAny,
      "PartitioningScheme",
      "bool",
      "replicateNullsAndAny");
  to_json_key(
      j,
      "scaleWriters",
      p.scaleWriters,
      "PartitioningScheme",
      "bool",
      "scaleWriters");
  to_json_key(
      j,
      "encoding",
      p.encoding,
      "PartitioningScheme",
      "ExchangeEncoding",
      "encoding");
  to_json_key(
      j,
      "bucketToPartition",
      p.bucketToPartition,
      "PartitioningScheme",
      "List<int>",
      "bucketToPartition");
}

void from_json(const json& j, PartitioningScheme& p) {
  from_json_key(
      j,
      "partitioning",
      p.partitioning,
      "PartitioningScheme",
      "Partitioning",
      "partitioning");
  from_json_key(
      j,
      "outputLayout",
      p.outputLayout,
      "PartitioningScheme",
      "List<VariableReferenceExpression>",
      "outputLayout");
  from_json_key(
      j,
      "hashColumn",
      p.hashColumn,
      "PartitioningScheme",
      "VariableReferenceExpression",
      "hashColumn");
  from_json_key(
      j,
      "replicateNullsAndAny",
      p.replicateNullsAndAny,
      "PartitioningScheme",
      "bool",
      "replicateNullsAndAny");
  from_json_key(
      j,
      "scaleWriters",
      p.scaleWriters,
      "PartitioningScheme",
      "bool",
      "scaleWriters");
  from_json_key(
      j,
      "encoding",
      p.encoding,
      "PartitioningScheme",
      "ExchangeEncoding",
      "encoding");
  from_json_key(
      j,
      "bucketToPartition",
      p.bucketToPartition,
      "PartitioningScheme",
      "List<int>",
      "bucketToPartition");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
CallDistributedProcedureNode::CallDistributedProcedureNode() noexcept {
  _type = "com.facebook.presto.sql.planner.plan.CallDistributedProcedureNode";
}

void to_json(json& j, const CallDistributedProcedureNode& p) {
  j = json::object();
  j["@type"] =
      "com.facebook.presto.sql.planner.plan.CallDistributedProcedureNode";
  to_json_key(
      j, "id", p.id, "CallDistributedProcedureNode", "PlanNodeId", "id");
  to_json_key(
      j,
      "source",
      p.source,
      "CallDistributedProcedureNode",
      "PlanNode",
      "source");
  to_json_key(
      j,
      "rowCountVariable",
      p.rowCountVariable,
      "CallDistributedProcedureNode",
      "VariableReferenceExpression",
      "rowCountVariable");
  to_json_key(
      j,
      "fragmentVariable",
      p.fragmentVariable,
      "CallDistributedProcedureNode",
      "VariableReferenceExpression",
      "fragmentVariable");
  to_json_key(
      j,
      "tableCommitContextVariable",
      p.tableCommitContextVariable,
      "CallDistributedProcedureNode",
      "VariableReferenceExpression",
      "tableCommitContextVariable");
  to_json_key(
      j,
      "columns",
      p.columns,
      "CallDistributedProcedureNode",
      "List<VariableReferenceExpression>",
      "columns");
  to_json_key(
      j,
      "columnNames",
      p.columnNames,
      "CallDistributedProcedureNode",
      "List<String>",
      "columnNames");
  to_json_key(
      j,
      "notNullColumnVariables",
      p.notNullColumnVariables,
      "CallDistributedProcedureNode",
      "List<VariableReferenceExpression>",
      "notNullColumnVariables");
  to_json_key(
      j,
      "partitioningScheme",
      p.partitioningScheme,
      "CallDistributedProcedureNode",
      "PartitioningScheme",
      "partitioningScheme");
}

void from_json(const json& j, CallDistributedProcedureNode& p) {
  p._type = j["@type"];
  from_json_key(
      j, "id", p.id, "CallDistributedProcedureNode", "PlanNodeId", "id");
  from_json_key(
      j,
      "source",
      p.source,
      "CallDistributedProcedureNode",
      "PlanNode",
      "source");
  from_json_key(
      j,
      "rowCountVariable",
      p.rowCountVariable,
      "CallDistributedProcedureNode",
      "VariableReferenceExpression",
      "rowCountVariable");
  from_json_key(
      j,
      "fragmentVariable",
      p.fragmentVariable,
      "CallDistributedProcedureNode",
      "VariableReferenceExpression",
      "fragmentVariable");
  from_json_key(
      j,
      "tableCommitContextVariable",
      p.tableCommitContextVariable,
      "CallDistributedProcedureNode",
      "VariableReferenceExpression",
      "tableCommitContextVariable");
  from_json_key(
      j,
      "columns",
      p.columns,
      "CallDistributedProcedureNode",
      "List<VariableReferenceExpression>",
      "columns");
  from_json_key(
      j,
      "columnNames",
      p.columnNames,
      "CallDistributedProcedureNode",
      "List<String>",
      "columnNames");
  from_json_key(
      j,
      "notNullColumnVariables",
      p.notNullColumnVariables,
      "CallDistributedProcedureNode",
      "List<VariableReferenceExpression>",
      "notNullColumnVariables");
  from_json_key(
      j,
      "partitioningScheme",
      p.partitioningScheme,
      "CallDistributedProcedureNode",
      "PartitioningScheme",
      "partitioningScheme");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Column& p) {
  j = json::object();
  to_json_key(j, "name", p.name, "Column", "String", "name");
  to_json_key(j, "type", p.type, "Column", "String", "type");
}

void from_json(const json& j, Column& p) {
  from_json_key(j, "name", p.name, "Column", "String", "name");
  from_json_key(j, "type", p.type, "Column", "String", "type");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<Argument>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "descriptor") {
    j = *std::static_pointer_cast<DescriptorArgument>(p);
    return;
  }
  if (type == "scalar") {
    j = *std::static_pointer_cast<ScalarArgument>(p);
    return;
  }
  if (type == "table") {
    j = *std::static_pointer_cast<TableArgument>(p);
    return;
  }

  throw TypeError(type + " no abstract type Argument ");
}

void from_json(const json& j, std::shared_ptr<Argument>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " Argument  Argument");
  }

  if (type == "descriptor") {
    std::shared_ptr<DescriptorArgument> k =
        std::make_shared<DescriptorArgument>();
    j.get_to(*k);
    p = std::static_pointer_cast<Argument>(k);
    return;
  }
  if (type == "scalar") {
    std::shared_ptr<ScalarArgument> k = std::make_shared<ScalarArgument>();
    j.get_to(*k);
    p = std::static_pointer_cast<Argument>(k);
    return;
  }
  if (type == "table") {
    std::shared_ptr<TableArgument> k = std::make_shared<TableArgument>();
    j.get_to(*k);
    p = std::static_pointer_cast<Argument>(k);
    return;
  }

  throw TypeError(type + " no abstract type Argument ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const ConnectorTableMetadata& p) {
  j = json::object();
  to_json_key(
      j,
      "functionName",
      p.functionName,
      "ConnectorTableMetadata",
      "QualifiedObjectName",
      "functionName");
  to_json_key(
      j,
      "arguments",
      p.arguments,
      "ConnectorTableMetadata",
      "Map<String, std::shared_ptr<Argument>>",
      "arguments");
}

void from_json(const json& j, ConnectorTableMetadata& p) {
  from_json_key(
      j,
      "functionName",
      p.functionName,
      "ConnectorTableMetadata",
      "QualifiedObjectName",
      "functionName");
  from_json_key(
      j,
      "arguments",
      p.arguments,
      "ConnectorTableMetadata",
      "Map<String, std::shared_ptr<Argument>>",
      "arguments");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Block& p) {
  j = p.data;
}

void from_json(const json& j, Block& p) {
  p.data = std::string(j);
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
ConstantExpression::ConstantExpression() noexcept {
  _type = "constant";
}

void to_json(json& j, const ConstantExpression& p) {
  j = json::object();
  j["@type"] = "constant";
  to_json_key(
      j,
      "valueBlock",
      p.valueBlock,
      "ConstantExpression",
      "Block",
      "valueBlock");
  to_json_key(j, "type", p.type, "ConstantExpression", "Type", "type");
}

void from_json(const json& j, ConstantExpression& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "valueBlock",
      p.valueBlock,
      "ConstantExpression",
      "Block",
      "valueBlock");
  from_json_key(j, "type", p.type, "ConstantExpression", "Type", "type");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ConnectorOutputTableHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;
  getConnectorProtocol(type).to_json(j, p);
}

void from_json(const json& j, std::shared_ptr<ConnectorOutputTableHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) +
        " ConnectorOutputTableHandle  ConnectorOutputTableHandle");
  }
  getConnectorProtocol(type).from_json(j, p);
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const OutputTableHandle& p) {
  j = json::object();
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "OutputTableHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "OutputTableHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  to_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "OutputTableHandle",
      "ConnectorOutputTableHandle",
      "connectorHandle");
}

void from_json(const json& j, OutputTableHandle& p) {
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "OutputTableHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "OutputTableHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  from_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "OutputTableHandle",
      "ConnectorOutputTableHandle",
      "connectorHandle");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const SchemaTableName& p) {
  j = json::object();
  to_json_key(j, "schema", p.schema, "SchemaTableName", "String", "schema");
  to_json_key(j, "table", p.table, "SchemaTableName", "String", "table");
}

void from_json(const json& j, SchemaTableName& p) {
  from_json_key(j, "schema", p.schema, "SchemaTableName", "String", "schema");
  from_json_key(j, "table", p.table, "SchemaTableName", "String", "table");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
CreateHandle::CreateHandle() noexcept {
  _type = "CreateHandle";
}

void to_json(json& j, const CreateHandle& p) {
  j = json::object();
  j["@type"] = "CreateHandle";
  to_json_key(
      j, "handle", p.handle, "CreateHandle", "OutputTableHandle", "handle");
  to_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "CreateHandle",
      "SchemaTableName",
      "schemaTableName");
}

void from_json(const json& j, CreateHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j, "handle", p.handle, "CreateHandle", "OutputTableHandle", "handle");
  from_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "CreateHandle",
      "SchemaTableName",
      "schemaTableName");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const DataOrganizationSpecification& p) {
  j = json::object();
  to_json_key(
      j,
      "partitionBy",
      p.partitionBy,
      "DataOrganizationSpecification",
      "List<VariableReferenceExpression>",
      "partitionBy");
  to_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "DataOrganizationSpecification",
      "OrderingScheme",
      "orderingScheme");
}

void from_json(const json& j, DataOrganizationSpecification& p) {
  from_json_key(
      j,
      "partitionBy",
      p.partitionBy,
      "DataOrganizationSpecification",
      "List<VariableReferenceExpression>",
      "partitionBy");
  from_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "DataOrganizationSpecification",
      "OrderingScheme",
      "orderingScheme");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ConnectorDeleteTableHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;
  getConnectorProtocol(type).to_json(j, p);
}

void from_json(const json& j, std::shared_ptr<ConnectorDeleteTableHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) +
        " ConnectorDeleteTableHandle  ConnectorDeleteTableHandle");
  }
  getConnectorProtocol(type).from_json(j, p);
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const DeleteTableHandle& p) {
  j = json::object();
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "DeleteTableHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "DeleteTableHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  to_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "DeleteTableHandle",
      "ConnectorDeleteTableHandle",
      "connectorHandle");
}

void from_json(const json& j, DeleteTableHandle& p) {
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "DeleteTableHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "DeleteTableHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  from_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "DeleteTableHandle",
      "ConnectorDeleteTableHandle",
      "connectorHandle");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
DeleteHandle::DeleteHandle() noexcept {
  _type = "DeleteHandle";
}

void to_json(json& j, const DeleteHandle& p) {
  j = json::object();
  j["@type"] = "DeleteHandle";
  to_json_key(
      j, "handle", p.handle, "DeleteHandle", "DeleteTableHandle", "handle");
  to_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "DeleteHandle",
      "SchemaTableName",
      "schemaTableName");
}

void from_json(const json& j, DeleteHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j, "handle", p.handle, "DeleteHandle", "DeleteTableHandle", "handle");
  from_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "DeleteHandle",
      "SchemaTableName",
      "schemaTableName");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<InputDistribution>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == ".BaseInputDistribution") {
    j = *std::static_pointer_cast<BaseInputDistribution>(p);
    return;
  }

  throw TypeError(type + " no abstract type InputDistribution ");
}

void from_json(const json& j, std::shared_ptr<InputDistribution>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) + " InputDistribution  InputDistribution");
  }

  if (type == ".BaseInputDistribution") {
    std::shared_ptr<BaseInputDistribution> k =
        std::make_shared<BaseInputDistribution>();
    j.get_to(*k);
    p = std::static_pointer_cast<InputDistribution>(k);
    return;
  }

  throw TypeError(type + " no abstract type InputDistribution ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
DeleteNode::DeleteNode() noexcept {
  _type = ".DeleteNode";
}

void to_json(json& j, const DeleteNode& p) {
  j = json::object();
  j["@type"] = ".DeleteNode";
  to_json_key(j, "id", p.id, "DeleteNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "DeleteNode", "PlanNode", "source");
  to_json_key(
      j,
      "rowId",
      p.rowId,
      "DeleteNode",
      "VariableReferenceExpression",
      "rowId");
  to_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "DeleteNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  to_json_key(
      j,
      "inputDistribution",
      p.inputDistribution,
      "DeleteNode",
      "InputDistribution",
      "inputDistribution");
}

void from_json(const json& j, DeleteNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "DeleteNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "DeleteNode", "PlanNode", "source");
  from_json_key(
      j,
      "rowId",
      p.rowId,
      "DeleteNode",
      "VariableReferenceExpression",
      "rowId");
  from_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "DeleteNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  from_json_key(
      j,
      "inputDistribution",
      p.inputDistribution,
      "DeleteNode",
      "InputDistribution",
      "inputDistribution");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Field& p) {
  j = json::object();
  to_json_key(j, "name", p.name, "Field", "String", "name");
  to_json_key(j, "type", p.type, "Field", "Type", "type");
}

void from_json(const json& j, Field& p) {
  from_json_key(j, "name", p.name, "Field", "String", "name");
  from_json_key(j, "type", p.type, "Field", "Type", "type");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Descriptor& p) {
  j = json::object();
  to_json_key(j, "fields", p.fields, "Descriptor", "List<Field>", "fields");
}

void from_json(const json& j, Descriptor& p) {
  from_json_key(j, "fields", p.fields, "Descriptor", "List<Field>", "fields");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
DescribedTableReturnTypeSpecification::
    DescribedTableReturnTypeSpecification() noexcept {
  _type = "described_table";
}

void to_json(json& j, const DescribedTableReturnTypeSpecification& p) {
  j = json::object();
  j["@type"] = "described_table";
  to_json_key(
      j,
      "descriptor",
      p.descriptor,
      "DescribedTableReturnTypeSpecification",
      "Descriptor",
      "descriptor");
}

void from_json(const json& j, DescribedTableReturnTypeSpecification& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "descriptor",
      p.descriptor,
      "DescribedTableReturnTypeSpecification",
      "Descriptor",
      "descriptor");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
DescriptorArgument::DescriptorArgument() noexcept {
  _type = "descriptor";
}

void to_json(json& j, const DescriptorArgument& p) {
  j = json::object();
  j["@type"] = "descriptor";
  to_json_key(
      j,
      "descriptor",
      p.descriptor,
      "DescriptorArgument",
      "Descriptor",
      "descriptor");
}

void from_json(const json& j, DescriptorArgument& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "descriptor",
      p.descriptor,
      "DescriptorArgument",
      "Descriptor",
      "descriptor");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
DescriptorArgumentSpecification::DescriptorArgumentSpecification() noexcept {
  _type = "descriptor";
}

void to_json(json& j, const DescriptorArgumentSpecification& p) {
  j = json::object();
  j["@type"] = "descriptor";
  to_json_key(
      j, "name", p.name, "DescriptorArgumentSpecification", "String", "name");
  to_json_key(
      j,
      "required",
      p.required,
      "DescriptorArgumentSpecification",
      "bool",
      "required");
  to_json_key(
      j,
      "defaultValue",
      p.defaultValue,
      "DescriptorArgumentSpecification",
      "Descriptor",
      "defaultValue");
}

void from_json(const json& j, DescriptorArgumentSpecification& p) {
  p._type = j["@type"];
  from_json_key(
      j, "name", p.name, "DescriptorArgumentSpecification", "String", "name");
  from_json_key(
      j,
      "required",
      p.required,
      "DescriptorArgumentSpecification",
      "bool",
      "required");
  from_json_key(
      j,
      "defaultValue",
      p.defaultValue,
      "DescriptorArgumentSpecification",
      "Descriptor",
      "defaultValue");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
DistinctLimitNode::DistinctLimitNode() noexcept {
  _type = ".DistinctLimitNode";
}

void to_json(json& j, const DistinctLimitNode& p) {
  j = json::object();
  j["@type"] = ".DistinctLimitNode";
  to_json_key(j, "id", p.id, "DistinctLimitNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "DistinctLimitNode", "PlanNode", "source");
  to_json_key(j, "limit", p.limit, "DistinctLimitNode", "int64_t", "limit");
  to_json_key(j, "partial", p.partial, "DistinctLimitNode", "bool", "partial");
  to_json_key(
      j,
      "distinctVariables",
      p.distinctVariables,
      "DistinctLimitNode",
      "List<VariableReferenceExpression>",
      "distinctVariables");
  to_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "DistinctLimitNode",
      "VariableReferenceExpression",
      "hashVariable");
  to_json_key(
      j,
      "timeoutMillis",
      p.timeoutMillis,
      "DistinctLimitNode",
      "int",
      "timeoutMillis");
}

void from_json(const json& j, DistinctLimitNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "DistinctLimitNode", "PlanNodeId", "id");
  from_json_key(
      j, "source", p.source, "DistinctLimitNode", "PlanNode", "source");
  from_json_key(j, "limit", p.limit, "DistinctLimitNode", "int64_t", "limit");
  from_json_key(
      j, "partial", p.partial, "DistinctLimitNode", "bool", "partial");
  from_json_key(
      j,
      "distinctVariables",
      p.distinctVariables,
      "DistinctLimitNode",
      "List<VariableReferenceExpression>",
      "distinctVariables");
  from_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "DistinctLimitNode",
      "VariableReferenceExpression",
      "hashVariable");
  from_json_key(
      j,
      "timeoutMillis",
      p.timeoutMillis,
      "DistinctLimitNode",
      "int",
      "timeoutMillis");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(
    json& j,
    const std::shared_ptr<ConnectorDistributedProcedureHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;
  getConnectorProtocol(type).to_json(j, p);
}

void from_json(
    const json& j,
    std::shared_ptr<ConnectorDistributedProcedureHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) +
        " ConnectorDistributedProcedureHandle  ConnectorDistributedProcedureHandle");
  }
  getConnectorProtocol(type).from_json(j, p);
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const DistributedProcedureHandle& p) {
  j = json::object();
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "DistributedProcedureHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "DistributedProcedureHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  to_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "DistributedProcedureHandle",
      "ConnectorDistributedProcedureHandle",
      "connectorHandle");
}

void from_json(const json& j, DistributedProcedureHandle& p) {
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "DistributedProcedureHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "DistributedProcedureHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  from_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "DistributedProcedureHandle",
      "ConnectorDistributedProcedureHandle",
      "connectorHandle");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const DistributionSnapshot& p) {
  j = json::object();
  to_json_key(
      j, "maxError", p.maxError, "DistributionSnapshot", "double", "maxError");
  to_json_key(j, "count", p.count, "DistributionSnapshot", "double", "count");
  to_json_key(j, "total", p.total, "DistributionSnapshot", "double", "total");
  to_json_key(j, "p01", p.p01, "DistributionSnapshot", "int64_t", "p01");
  to_json_key(j, "p05", p.p05, "DistributionSnapshot", "int64_t", "p05");
  to_json_key(j, "p10", p.p10, "DistributionSnapshot", "int64_t", "p10");
  to_json_key(j, "p25", p.p25, "DistributionSnapshot", "int64_t", "p25");
  to_json_key(j, "p50", p.p50, "DistributionSnapshot", "int64_t", "p50");
  to_json_key(j, "p75", p.p75, "DistributionSnapshot", "int64_t", "p75");
  to_json_key(j, "p90", p.p90, "DistributionSnapshot", "int64_t", "p90");
  to_json_key(j, "p95", p.p95, "DistributionSnapshot", "int64_t", "p95");
  to_json_key(j, "p99", p.p99, "DistributionSnapshot", "int64_t", "p99");
  to_json_key(j, "min", p.min, "DistributionSnapshot", "int64_t", "min");
  to_json_key(j, "max", p.max, "DistributionSnapshot", "int64_t", "max");
  to_json_key(j, "avg", p.avg, "DistributionSnapshot", "double", "avg");
}

void from_json(const json& j, DistributionSnapshot& p) {
  from_json_key(
      j, "maxError", p.maxError, "DistributionSnapshot", "double", "maxError");
  from_json_key(j, "count", p.count, "DistributionSnapshot", "double", "count");
  from_json_key(j, "total", p.total, "DistributionSnapshot", "double", "total");
  from_json_key(j, "p01", p.p01, "DistributionSnapshot", "int64_t", "p01");
  from_json_key(j, "p05", p.p05, "DistributionSnapshot", "int64_t", "p05");
  from_json_key(j, "p10", p.p10, "DistributionSnapshot", "int64_t", "p10");
  from_json_key(j, "p25", p.p25, "DistributionSnapshot", "int64_t", "p25");
  from_json_key(j, "p50", p.p50, "DistributionSnapshot", "int64_t", "p50");
  from_json_key(j, "p75", p.p75, "DistributionSnapshot", "int64_t", "p75");
  from_json_key(j, "p90", p.p90, "DistributionSnapshot", "int64_t", "p90");
  from_json_key(j, "p95", p.p95, "DistributionSnapshot", "int64_t", "p95");
  from_json_key(j, "p99", p.p99, "DistributionSnapshot", "int64_t", "p99");
  from_json_key(j, "min", p.min, "DistributionSnapshot", "int64_t", "min");
  from_json_key(j, "max", p.max, "DistributionSnapshot", "int64_t", "max");
  from_json_key(j, "avg", p.avg, "DistributionSnapshot", "double", "avg");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ValueSet>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  if (type == "equatable") {
    j = *std::static_pointer_cast<EquatableValueSet>(p);
    return;
  }
  if (type == "sortable") {
    j = *std::static_pointer_cast<SortedRangeSet>(p);
    return;
  }
  if (type == "allOrNone") {
    j = *std::static_pointer_cast<AllOrNoneValueSet>(p);
    return;
  }

  throw TypeError(type + " no abstract type ValueSet ");
}

void from_json(const json& j, std::shared_ptr<ValueSet>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " ValueSet  ValueSet");
  }

  if (type == "equatable") {
    std::shared_ptr<EquatableValueSet> k =
        std::make_shared<EquatableValueSet>();
    j.get_to(*k);
    p = std::static_pointer_cast<ValueSet>(k);
    return;
  }
  if (type == "sortable") {
    std::shared_ptr<SortedRangeSet> k = std::make_shared<SortedRangeSet>();
    j.get_to(*k);
    p = std::static_pointer_cast<ValueSet>(k);
    return;
  }
  if (type == "allOrNone") {
    std::shared_ptr<AllOrNoneValueSet> k =
        std::make_shared<AllOrNoneValueSet>();
    j.get_to(*k);
    p = std::static_pointer_cast<ValueSet>(k);
    return;
  }

  throw TypeError(type + " no abstract type ValueSet ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Domain& p) {
  j = json::object();
  to_json_key(j, "values", p.values, "Domain", "ValueSet", "values");
  to_json_key(j, "nullAllowed", p.nullAllowed, "Domain", "bool", "nullAllowed");
}

void from_json(const json& j, Domain& p) {
  from_json_key(j, "values", p.values, "Domain", "ValueSet", "values");
  from_json_key(
      j, "nullAllowed", p.nullAllowed, "Domain", "bool", "nullAllowed");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<BlockedReason, json> BlockedReason_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {BlockedReason::WAITING_FOR_MEMORY, "WAITING_FOR_MEMORY"}};
void to_json(json& j, const BlockedReason& e) {
  static_assert(
      std::is_enum<BlockedReason>::value, "BlockedReason must be an enum!");
  const auto* it = std::find_if(
      std::begin(BlockedReason_enum_table),
      std::end(BlockedReason_enum_table),
      [e](const std::pair<BlockedReason, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(BlockedReason_enum_table))
           ? it
           : std::begin(BlockedReason_enum_table))
          ->second;
}
void from_json(const json& j, BlockedReason& e) {
  static_assert(
      std::is_enum<BlockedReason>::value, "BlockedReason must be an enum!");
  const auto* it = std::find_if(
      std::begin(BlockedReason_enum_table),
      std::end(BlockedReason_enum_table),
      [&j](const std::pair<BlockedReason, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(BlockedReason_enum_table))
           ? it
           : std::begin(BlockedReason_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const DynamicFilterStats& p) {
  j = json::object();
  to_json_key(
      j,
      "producerNodeIds",
      p.producerNodeIds,
      "DynamicFilterStats",
      "List<PlanNodeId>",
      "producerNodeIds");
}

void from_json(const json& j, DynamicFilterStats& p) {
  from_json_key(
      j,
      "producerNodeIds",
      p.producerNodeIds,
      "DynamicFilterStats",
      "List<PlanNodeId>",
      "producerNodeIds");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const OperatorInfo& p) {}
void from_json(const json& j, OperatorInfo& p) {}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const OperatorStats& p) {
  j = json::object();
  to_json_key(j, "stageId", p.stageId, "OperatorStats", "int", "stageId");
  to_json_key(
      j,
      "stageExecutionId",
      p.stageExecutionId,
      "OperatorStats",
      "int",
      "stageExecutionId");
  to_json_key(
      j, "pipelineId", p.pipelineId, "OperatorStats", "int", "pipelineId");
  to_json_key(
      j, "operatorId", p.operatorId, "OperatorStats", "int", "operatorId");
  to_json_key(
      j,
      "planNodeId",
      p.planNodeId,
      "OperatorStats",
      "PlanNodeId",
      "planNodeId");
  to_json_key(
      j,
      "operatorType",
      p.operatorType,
      "OperatorStats",
      "String",
      "operatorType");
  to_json_key(
      j,
      "totalDrivers",
      p.totalDrivers,
      "OperatorStats",
      "int64_t",
      "totalDrivers");
  to_json_key(
      j,
      "isBlockedCalls",
      p.isBlockedCalls,
      "OperatorStats",
      "int64_t",
      "isBlockedCalls");
  to_json_key(
      j,
      "isBlockedWall",
      p.isBlockedWall,
      "OperatorStats",
      "Duration",
      "isBlockedWall");
  to_json_key(
      j,
      "isBlockedCpu",
      p.isBlockedCpu,
      "OperatorStats",
      "Duration",
      "isBlockedCpu");
  to_json_key(
      j,
      "isBlockedAllocationInBytes",
      p.isBlockedAllocationInBytes,
      "OperatorStats",
      "int64_t",
      "isBlockedAllocationInBytes");
  to_json_key(
      j,
      "addInputCalls",
      p.addInputCalls,
      "OperatorStats",
      "int64_t",
      "addInputCalls");
  to_json_key(
      j,
      "addInputWall",
      p.addInputWall,
      "OperatorStats",
      "Duration",
      "addInputWall");
  to_json_key(
      j,
      "addInputCpu",
      p.addInputCpu,
      "OperatorStats",
      "Duration",
      "addInputCpu");
  to_json_key(
      j,
      "addInputAllocationInBytes",
      p.addInputAllocationInBytes,
      "OperatorStats",
      "int64_t",
      "addInputAllocationInBytes");
  to_json_key(
      j,
      "rawInputDataSizeInBytes",
      p.rawInputDataSizeInBytes,
      "OperatorStats",
      "int64_t",
      "rawInputDataSizeInBytes");
  to_json_key(
      j,
      "rawInputPositions",
      p.rawInputPositions,
      "OperatorStats",
      "int64_t",
      "rawInputPositions");
  to_json_key(
      j,
      "inputDataSizeInBytes",
      p.inputDataSizeInBytes,
      "OperatorStats",
      "int64_t",
      "inputDataSizeInBytes");
  to_json_key(
      j,
      "inputPositions",
      p.inputPositions,
      "OperatorStats",
      "int64_t",
      "inputPositions");
  to_json_key(
      j,
      "sumSquaredInputPositions",
      p.sumSquaredInputPositions,
      "OperatorStats",
      "double",
      "sumSquaredInputPositions");
  to_json_key(
      j,
      "getOutputCalls",
      p.getOutputCalls,
      "OperatorStats",
      "int64_t",
      "getOutputCalls");
  to_json_key(
      j,
      "getOutputWall",
      p.getOutputWall,
      "OperatorStats",
      "Duration",
      "getOutputWall");
  to_json_key(
      j,
      "getOutputCpu",
      p.getOutputCpu,
      "OperatorStats",
      "Duration",
      "getOutputCpu");
  to_json_key(
      j,
      "getOutputAllocationInBytes",
      p.getOutputAllocationInBytes,
      "OperatorStats",
      "int64_t",
      "getOutputAllocationInBytes");
  to_json_key(
      j,
      "outputDataSizeInBytes",
      p.outputDataSizeInBytes,
      "OperatorStats",
      "int64_t",
      "outputDataSizeInBytes");
  to_json_key(
      j,
      "outputPositions",
      p.outputPositions,
      "OperatorStats",
      "int64_t",
      "outputPositions");
  to_json_key(
      j,
      "physicalWrittenDataSizeInBytes",
      p.physicalWrittenDataSizeInBytes,
      "OperatorStats",
      "int64_t",
      "physicalWrittenDataSizeInBytes");
  to_json_key(
      j,
      "additionalCpu",
      p.additionalCpu,
      "OperatorStats",
      "Duration",
      "additionalCpu");
  to_json_key(
      j,
      "blockedWall",
      p.blockedWall,
      "OperatorStats",
      "Duration",
      "blockedWall");
  to_json_key(
      j,
      "finishCalls",
      p.finishCalls,
      "OperatorStats",
      "int64_t",
      "finishCalls");
  to_json_key(
      j, "finishWall", p.finishWall, "OperatorStats", "Duration", "finishWall");
  to_json_key(
      j, "finishCpu", p.finishCpu, "OperatorStats", "Duration", "finishCpu");
  to_json_key(
      j,
      "finishAllocationInBytes",
      p.finishAllocationInBytes,
      "OperatorStats",
      "int64_t",
      "finishAllocationInBytes");
  to_json_key(
      j,
      "userMemoryReservationInBytes",
      p.userMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "userMemoryReservationInBytes");
  to_json_key(
      j,
      "revocableMemoryReservationInBytes",
      p.revocableMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "revocableMemoryReservationInBytes");
  to_json_key(
      j,
      "systemMemoryReservationInBytes",
      p.systemMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "systemMemoryReservationInBytes");
  to_json_key(
      j,
      "peakUserMemoryReservationInBytes",
      p.peakUserMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "peakUserMemoryReservationInBytes");
  to_json_key(
      j,
      "peakSystemMemoryReservationInBytes",
      p.peakSystemMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "peakSystemMemoryReservationInBytes");
  to_json_key(
      j,
      "peakTotalMemoryReservationInBytes",
      p.peakTotalMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "peakTotalMemoryReservationInBytes");
  to_json_key(
      j,
      "spilledDataSizeInBytes",
      p.spilledDataSizeInBytes,
      "OperatorStats",
      "int64_t",
      "spilledDataSizeInBytes");
  to_json_key(
      j,
      "blockedReason",
      p.blockedReason,
      "OperatorStats",
      "BlockedReason",
      "blockedReason");
  to_json_key(j, "info", p.info, "OperatorStats", "OperatorInfo", "info");
  to_json_key(
      j,
      "runtimeStats",
      p.runtimeStats,
      "OperatorStats",
      "RuntimeStats",
      "runtimeStats");
  to_json_key(
      j,
      "dynamicFilterStats",
      p.dynamicFilterStats,
      "OperatorStats",
      "DynamicFilterStats",
      "dynamicFilterStats");
  to_json_key(
      j,
      "nullJoinBuildKeyCount",
      p.nullJoinBuildKeyCount,
      "OperatorStats",
      "int64_t",
      "nullJoinBuildKeyCount");
  to_json_key(
      j,
      "joinBuildKeyCount",
      p.joinBuildKeyCount,
      "OperatorStats",
      "int64_t",
      "joinBuildKeyCount");
  to_json_key(
      j,
      "nullJoinProbeKeyCount",
      p.nullJoinProbeKeyCount,
      "OperatorStats",
      "int64_t",
      "nullJoinProbeKeyCount");
  to_json_key(
      j,
      "joinProbeKeyCount",
      p.joinProbeKeyCount,
      "OperatorStats",
      "int64_t",
      "joinProbeKeyCount");
}

void from_json(const json& j, OperatorStats& p) {
  from_json_key(j, "stageId", p.stageId, "OperatorStats", "int", "stageId");
  from_json_key(
      j,
      "stageExecutionId",
      p.stageExecutionId,
      "OperatorStats",
      "int",
      "stageExecutionId");
  from_json_key(
      j, "pipelineId", p.pipelineId, "OperatorStats", "int", "pipelineId");
  from_json_key(
      j, "operatorId", p.operatorId, "OperatorStats", "int", "operatorId");
  from_json_key(
      j,
      "planNodeId",
      p.planNodeId,
      "OperatorStats",
      "PlanNodeId",
      "planNodeId");
  from_json_key(
      j,
      "operatorType",
      p.operatorType,
      "OperatorStats",
      "String",
      "operatorType");
  from_json_key(
      j,
      "totalDrivers",
      p.totalDrivers,
      "OperatorStats",
      "int64_t",
      "totalDrivers");
  from_json_key(
      j,
      "isBlockedCalls",
      p.isBlockedCalls,
      "OperatorStats",
      "int64_t",
      "isBlockedCalls");
  from_json_key(
      j,
      "isBlockedWall",
      p.isBlockedWall,
      "OperatorStats",
      "Duration",
      "isBlockedWall");
  from_json_key(
      j,
      "isBlockedCpu",
      p.isBlockedCpu,
      "OperatorStats",
      "Duration",
      "isBlockedCpu");
  from_json_key(
      j,
      "isBlockedAllocationInBytes",
      p.isBlockedAllocationInBytes,
      "OperatorStats",
      "int64_t",
      "isBlockedAllocationInBytes");
  from_json_key(
      j,
      "addInputCalls",
      p.addInputCalls,
      "OperatorStats",
      "int64_t",
      "addInputCalls");
  from_json_key(
      j,
      "addInputWall",
      p.addInputWall,
      "OperatorStats",
      "Duration",
      "addInputWall");
  from_json_key(
      j,
      "addInputCpu",
      p.addInputCpu,
      "OperatorStats",
      "Duration",
      "addInputCpu");
  from_json_key(
      j,
      "addInputAllocationInBytes",
      p.addInputAllocationInBytes,
      "OperatorStats",
      "int64_t",
      "addInputAllocationInBytes");
  from_json_key(
      j,
      "rawInputDataSizeInBytes",
      p.rawInputDataSizeInBytes,
      "OperatorStats",
      "int64_t",
      "rawInputDataSizeInBytes");
  from_json_key(
      j,
      "rawInputPositions",
      p.rawInputPositions,
      "OperatorStats",
      "int64_t",
      "rawInputPositions");
  from_json_key(
      j,
      "inputDataSizeInBytes",
      p.inputDataSizeInBytes,
      "OperatorStats",
      "int64_t",
      "inputDataSizeInBytes");
  from_json_key(
      j,
      "inputPositions",
      p.inputPositions,
      "OperatorStats",
      "int64_t",
      "inputPositions");
  from_json_key(
      j,
      "sumSquaredInputPositions",
      p.sumSquaredInputPositions,
      "OperatorStats",
      "double",
      "sumSquaredInputPositions");
  from_json_key(
      j,
      "getOutputCalls",
      p.getOutputCalls,
      "OperatorStats",
      "int64_t",
      "getOutputCalls");
  from_json_key(
      j,
      "getOutputWall",
      p.getOutputWall,
      "OperatorStats",
      "Duration",
      "getOutputWall");
  from_json_key(
      j,
      "getOutputCpu",
      p.getOutputCpu,
      "OperatorStats",
      "Duration",
      "getOutputCpu");
  from_json_key(
      j,
      "getOutputAllocationInBytes",
      p.getOutputAllocationInBytes,
      "OperatorStats",
      "int64_t",
      "getOutputAllocationInBytes");
  from_json_key(
      j,
      "outputDataSizeInBytes",
      p.outputDataSizeInBytes,
      "OperatorStats",
      "int64_t",
      "outputDataSizeInBytes");
  from_json_key(
      j,
      "outputPositions",
      p.outputPositions,
      "OperatorStats",
      "int64_t",
      "outputPositions");
  from_json_key(
      j,
      "physicalWrittenDataSizeInBytes",
      p.physicalWrittenDataSizeInBytes,
      "OperatorStats",
      "int64_t",
      "physicalWrittenDataSizeInBytes");
  from_json_key(
      j,
      "additionalCpu",
      p.additionalCpu,
      "OperatorStats",
      "Duration",
      "additionalCpu");
  from_json_key(
      j,
      "blockedWall",
      p.blockedWall,
      "OperatorStats",
      "Duration",
      "blockedWall");
  from_json_key(
      j,
      "finishCalls",
      p.finishCalls,
      "OperatorStats",
      "int64_t",
      "finishCalls");
  from_json_key(
      j, "finishWall", p.finishWall, "OperatorStats", "Duration", "finishWall");
  from_json_key(
      j, "finishCpu", p.finishCpu, "OperatorStats", "Duration", "finishCpu");
  from_json_key(
      j,
      "finishAllocationInBytes",
      p.finishAllocationInBytes,
      "OperatorStats",
      "int64_t",
      "finishAllocationInBytes");
  from_json_key(
      j,
      "userMemoryReservationInBytes",
      p.userMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "userMemoryReservationInBytes");
  from_json_key(
      j,
      "revocableMemoryReservationInBytes",
      p.revocableMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "revocableMemoryReservationInBytes");
  from_json_key(
      j,
      "systemMemoryReservationInBytes",
      p.systemMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "systemMemoryReservationInBytes");
  from_json_key(
      j,
      "peakUserMemoryReservationInBytes",
      p.peakUserMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "peakUserMemoryReservationInBytes");
  from_json_key(
      j,
      "peakSystemMemoryReservationInBytes",
      p.peakSystemMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "peakSystemMemoryReservationInBytes");
  from_json_key(
      j,
      "peakTotalMemoryReservationInBytes",
      p.peakTotalMemoryReservationInBytes,
      "OperatorStats",
      "int64_t",
      "peakTotalMemoryReservationInBytes");
  from_json_key(
      j,
      "spilledDataSizeInBytes",
      p.spilledDataSizeInBytes,
      "OperatorStats",
      "int64_t",
      "spilledDataSizeInBytes");
  from_json_key(
      j,
      "blockedReason",
      p.blockedReason,
      "OperatorStats",
      "BlockedReason",
      "blockedReason");
  from_json_key(j, "info", p.info, "OperatorStats", "OperatorInfo", "info");
  from_json_key(
      j,
      "runtimeStats",
      p.runtimeStats,
      "OperatorStats",
      "RuntimeStats",
      "runtimeStats");
  from_json_key(
      j,
      "dynamicFilterStats",
      p.dynamicFilterStats,
      "OperatorStats",
      "DynamicFilterStats",
      "dynamicFilterStats");
  from_json_key(
      j,
      "nullJoinBuildKeyCount",
      p.nullJoinBuildKeyCount,
      "OperatorStats",
      "int64_t",
      "nullJoinBuildKeyCount");
  from_json_key(
      j,
      "joinBuildKeyCount",
      p.joinBuildKeyCount,
      "OperatorStats",
      "int64_t",
      "joinBuildKeyCount");
  from_json_key(
      j,
      "nullJoinProbeKeyCount",
      p.nullJoinProbeKeyCount,
      "OperatorStats",
      "int64_t",
      "nullJoinProbeKeyCount");
  from_json_key(
      j,
      "joinProbeKeyCount",
      p.joinProbeKeyCount,
      "OperatorStats",
      "int64_t",
      "joinProbeKeyCount");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const DriverStats& p) {
  j = json::object();
  to_json_key(j, "lifespan", p.lifespan, "DriverStats", "Lifespan", "lifespan");
  to_json_key(
      j,
      "createTimeInMillis",
      p.createTimeInMillis,
      "DriverStats",
      "int64_t",
      "createTimeInMillis");
  to_json_key(
      j,
      "startTimeInMillis",
      p.startTimeInMillis,
      "DriverStats",
      "int64_t",
      "startTimeInMillis");
  to_json_key(
      j,
      "endTimeInMillis",
      p.endTimeInMillis,
      "DriverStats",
      "int64_t",
      "endTimeInMillis");
  to_json_key(
      j, "queuedTime", p.queuedTime, "DriverStats", "Duration", "queuedTime");
  to_json_key(
      j,
      "elapsedTime",
      p.elapsedTime,
      "DriverStats",
      "Duration",
      "elapsedTime");
  to_json_key(
      j,
      "userMemoryReservationInBytes",
      p.userMemoryReservationInBytes,
      "DriverStats",
      "int64_t",
      "userMemoryReservationInBytes");
  to_json_key(
      j,
      "revocableMemoryReservationInBytes",
      p.revocableMemoryReservationInBytes,
      "DriverStats",
      "int64_t",
      "revocableMemoryReservationInBytes");
  to_json_key(
      j,
      "systemMemoryReservationInBytes",
      p.systemMemoryReservationInBytes,
      "DriverStats",
      "int64_t",
      "systemMemoryReservationInBytes");
  to_json_key(
      j,
      "totalScheduledTime",
      p.totalScheduledTime,
      "DriverStats",
      "Duration",
      "totalScheduledTime");
  to_json_key(
      j,
      "totalCpuTime",
      p.totalCpuTime,
      "DriverStats",
      "Duration",
      "totalCpuTime");
  to_json_key(
      j,
      "totalBlockedTime",
      p.totalBlockedTime,
      "DriverStats",
      "Duration",
      "totalBlockedTime");
  to_json_key(
      j, "fullyBlocked", p.fullyBlocked, "DriverStats", "bool", "fullyBlocked");
  to_json_key(
      j,
      "blockedReasons",
      p.blockedReasons,
      "DriverStats",
      "List<BlockedReason>",
      "blockedReasons");
  to_json_key(
      j,
      "totalAllocationInBytes",
      p.totalAllocationInBytes,
      "DriverStats",
      "int64_t",
      "totalAllocationInBytes");
  to_json_key(
      j,
      "rawInputDataSizeInBytes",
      p.rawInputDataSizeInBytes,
      "DriverStats",
      "int64_t",
      "rawInputDataSizeInBytes");
  to_json_key(
      j,
      "rawInputPositions",
      p.rawInputPositions,
      "DriverStats",
      "int64_t",
      "rawInputPositions");
  to_json_key(
      j,
      "rawInputReadTime",
      p.rawInputReadTime,
      "DriverStats",
      "Duration",
      "rawInputReadTime");
  to_json_key(
      j,
      "processedInputDataSizeInBytes",
      p.processedInputDataSizeInBytes,
      "DriverStats",
      "int64_t",
      "processedInputDataSizeInBytes");
  to_json_key(
      j,
      "processedInputPositions",
      p.processedInputPositions,
      "DriverStats",
      "int64_t",
      "processedInputPositions");
  to_json_key(
      j,
      "outputDataSizeInBytes",
      p.outputDataSizeInBytes,
      "DriverStats",
      "int64_t",
      "outputDataSizeInBytes");
  to_json_key(
      j,
      "outputPositions",
      p.outputPositions,
      "DriverStats",
      "int64_t",
      "outputPositions");
  to_json_key(
      j,
      "physicalWrittenDataSizeInBytes",
      p.physicalWrittenDataSizeInBytes,
      "DriverStats",
      "int64_t",
      "physicalWrittenDataSizeInBytes");
  to_json_key(
      j,
      "operatorStats",
      p.operatorStats,
      "DriverStats",
      "List<OperatorStats>",
      "operatorStats");
}

void from_json(const json& j, DriverStats& p) {
  from_json_key(
      j, "lifespan", p.lifespan, "DriverStats", "Lifespan", "lifespan");
  from_json_key(
      j,
      "createTimeInMillis",
      p.createTimeInMillis,
      "DriverStats",
      "int64_t",
      "createTimeInMillis");
  from_json_key(
      j,
      "startTimeInMillis",
      p.startTimeInMillis,
      "DriverStats",
      "int64_t",
      "startTimeInMillis");
  from_json_key(
      j,
      "endTimeInMillis",
      p.endTimeInMillis,
      "DriverStats",
      "int64_t",
      "endTimeInMillis");
  from_json_key(
      j, "queuedTime", p.queuedTime, "DriverStats", "Duration", "queuedTime");
  from_json_key(
      j,
      "elapsedTime",
      p.elapsedTime,
      "DriverStats",
      "Duration",
      "elapsedTime");
  from_json_key(
      j,
      "userMemoryReservationInBytes",
      p.userMemoryReservationInBytes,
      "DriverStats",
      "int64_t",
      "userMemoryReservationInBytes");
  from_json_key(
      j,
      "revocableMemoryReservationInBytes",
      p.revocableMemoryReservationInBytes,
      "DriverStats",
      "int64_t",
      "revocableMemoryReservationInBytes");
  from_json_key(
      j,
      "systemMemoryReservationInBytes",
      p.systemMemoryReservationInBytes,
      "DriverStats",
      "int64_t",
      "systemMemoryReservationInBytes");
  from_json_key(
      j,
      "totalScheduledTime",
      p.totalScheduledTime,
      "DriverStats",
      "Duration",
      "totalScheduledTime");
  from_json_key(
      j,
      "totalCpuTime",
      p.totalCpuTime,
      "DriverStats",
      "Duration",
      "totalCpuTime");
  from_json_key(
      j,
      "totalBlockedTime",
      p.totalBlockedTime,
      "DriverStats",
      "Duration",
      "totalBlockedTime");
  from_json_key(
      j, "fullyBlocked", p.fullyBlocked, "DriverStats", "bool", "fullyBlocked");
  from_json_key(
      j,
      "blockedReasons",
      p.blockedReasons,
      "DriverStats",
      "List<BlockedReason>",
      "blockedReasons");
  from_json_key(
      j,
      "totalAllocationInBytes",
      p.totalAllocationInBytes,
      "DriverStats",
      "int64_t",
      "totalAllocationInBytes");
  from_json_key(
      j,
      "rawInputDataSizeInBytes",
      p.rawInputDataSizeInBytes,
      "DriverStats",
      "int64_t",
      "rawInputDataSizeInBytes");
  from_json_key(
      j,
      "rawInputPositions",
      p.rawInputPositions,
      "DriverStats",
      "int64_t",
      "rawInputPositions");
  from_json_key(
      j,
      "rawInputReadTime",
      p.rawInputReadTime,
      "DriverStats",
      "Duration",
      "rawInputReadTime");
  from_json_key(
      j,
      "processedInputDataSizeInBytes",
      p.processedInputDataSizeInBytes,
      "DriverStats",
      "int64_t",
      "processedInputDataSizeInBytes");
  from_json_key(
      j,
      "processedInputPositions",
      p.processedInputPositions,
      "DriverStats",
      "int64_t",
      "processedInputPositions");
  from_json_key(
      j,
      "outputDataSizeInBytes",
      p.outputDataSizeInBytes,
      "DriverStats",
      "int64_t",
      "outputDataSizeInBytes");
  from_json_key(
      j,
      "outputPositions",
      p.outputPositions,
      "DriverStats",
      "int64_t",
      "outputPositions");
  from_json_key(
      j,
      "physicalWrittenDataSizeInBytes",
      p.physicalWrittenDataSizeInBytes,
      "DriverStats",
      "int64_t",
      "physicalWrittenDataSizeInBytes");
  from_json_key(
      j,
      "operatorStats",
      p.operatorStats,
      "DriverStats",
      "List<OperatorStats>",
      "operatorStats");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
EmptySplit::EmptySplit() noexcept {
  _type = "$empty";
}

void to_json(json& j, const EmptySplit& p) {
  j = json::object();
  j["@type"] = "$empty";
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "EmptySplit",
      "ConnectorId",
      "connectorId");
}

void from_json(const json& j, EmptySplit& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "EmptySplit",
      "ConnectorId",
      "connectorId");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
EnforceSingleRowNode::EnforceSingleRowNode() noexcept {
  _type = "com.facebook.presto.sql.planner.plan.EnforceSingleRowNode";
}

void to_json(json& j, const EnforceSingleRowNode& p) {
  j = json::object();
  j["@type"] = "com.facebook.presto.sql.planner.plan.EnforceSingleRowNode";
  to_json_key(j, "id", p.id, "EnforceSingleRowNode", "PlanNodeId", "id");
  to_json_key(
      j, "source", p.source, "EnforceSingleRowNode", "PlanNode", "source");
}

void from_json(const json& j, EnforceSingleRowNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "EnforceSingleRowNode", "PlanNodeId", "id");
  from_json_key(
      j, "source", p.source, "EnforceSingleRowNode", "PlanNode", "source");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const ValueEntry& p) {
  j = json::object();
  to_json_key(j, "type", p.type, "ValueEntry", "Type", "type");
  to_json_key(j, "block", p.block, "ValueEntry", "Block", "block");
}

void from_json(const json& j, ValueEntry& p) {
  from_json_key(j, "type", p.type, "ValueEntry", "Type", "type");
  from_json_key(j, "block", p.block, "ValueEntry", "Block", "block");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
EquatableValueSet::EquatableValueSet() noexcept {
  _type = "equatable";
}

void to_json(json& j, const EquatableValueSet& p) {
  j = json::object();
  j["@type"] = "equatable";
  to_json_key(j, "type", p.type, "EquatableValueSet", "Type", "type");
  to_json_key(
      j, "whiteList", p.whiteList, "EquatableValueSet", "bool", "whiteList");
  to_json_key(
      j,
      "entries",
      p.entries,
      "EquatableValueSet",
      "List<ValueEntry>",
      "entries");
}

void from_json(const json& j, EquatableValueSet& p) {
  p._type = j["@type"];
  from_json_key(j, "type", p.type, "EquatableValueSet", "Type", "type");
  from_json_key(
      j, "whiteList", p.whiteList, "EquatableValueSet", "bool", "whiteList");
  from_json_key(
      j,
      "entries",
      p.entries,
      "EquatableValueSet",
      "List<ValueEntry>",
      "entries");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const EquiJoinClause& p) {
  j = json::object();
  to_json_key(
      j,
      "left",
      p.left,
      "EquiJoinClause",
      "VariableReferenceExpression",
      "left");
  to_json_key(
      j,
      "right",
      p.right,
      "EquiJoinClause",
      "VariableReferenceExpression",
      "right");
}

void from_json(const json& j, EquiJoinClause& p) {
  from_json_key(
      j,
      "left",
      p.left,
      "EquiJoinClause",
      "VariableReferenceExpression",
      "left");
  from_json_key(
      j,
      "right",
      p.right,
      "EquiJoinClause",
      "VariableReferenceExpression",
      "right");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<ErrorType, json> ErrorType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {ErrorType::USER_ERROR, "USER_ERROR"},
        {ErrorType::INTERNAL_ERROR, "INTERNAL_ERROR"},
        {ErrorType::INSUFFICIENT_RESOURCES, "INSUFFICIENT_RESOURCES"},
        {ErrorType::EXTERNAL, "EXTERNAL"}};
void to_json(json& j, const ErrorType& e) {
  static_assert(std::is_enum<ErrorType>::value, "ErrorType must be an enum!");
  const auto* it = std::find_if(
      std::begin(ErrorType_enum_table),
      std::end(ErrorType_enum_table),
      [e](const std::pair<ErrorType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(ErrorType_enum_table))
           ? it
           : std::begin(ErrorType_enum_table))
          ->second;
}
void from_json(const json& j, ErrorType& e) {
  static_assert(std::is_enum<ErrorType>::value, "ErrorType must be an enum!");
  const auto* it = std::find_if(
      std::begin(ErrorType_enum_table),
      std::end(ErrorType_enum_table),
      [&j](const std::pair<ErrorType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(ErrorType_enum_table))
           ? it
           : std::begin(ErrorType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const ErrorCode& p) {
  j = json::object();
  to_json_key(j, "code", p.code, "ErrorCode", "int", "code");
  to_json_key(j, "name", p.name, "ErrorCode", "String", "name");
  to_json_key(j, "type", p.type, "ErrorCode", "ErrorType", "type");
  to_json_key(j, "retriable", p.retriable, "ErrorCode", "bool", "retriable");
}

void from_json(const json& j, ErrorCode& p) {
  from_json_key(j, "code", p.code, "ErrorCode", "int", "code");
  from_json_key(j, "name", p.name, "ErrorCode", "String", "name");
  from_json_key(j, "type", p.type, "ErrorCode", "ErrorType", "type");
  from_json_key(j, "retriable", p.retriable, "ErrorCode", "bool", "retriable");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const ErrorLocation& p) {
  j = json::object();
  to_json_key(
      j, "lineNumber", p.lineNumber, "ErrorLocation", "int", "lineNumber");
  to_json_key(
      j,
      "columnNumber",
      p.columnNumber,
      "ErrorLocation",
      "int",
      "columnNumber");
}

void from_json(const json& j, ErrorLocation& p) {
  from_json_key(
      j, "lineNumber", p.lineNumber, "ErrorLocation", "int", "lineNumber");
  from_json_key(
      j,
      "columnNumber",
      p.columnNumber,
      "ErrorLocation",
      "int",
      "columnNumber");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<ExchangeNodeScope, json> ExchangeNodeScope_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {ExchangeNodeScope::LOCAL, "LOCAL"},
        {ExchangeNodeScope::REMOTE_STREAMING, "REMOTE_STREAMING"},
        {ExchangeNodeScope::REMOTE_MATERIALIZED, "REMOTE_MATERIALIZED"}};
void to_json(json& j, const ExchangeNodeScope& e) {
  static_assert(
      std::is_enum<ExchangeNodeScope>::value,
      "ExchangeNodeScope must be an enum!");
  const auto* it = std::find_if(
      std::begin(ExchangeNodeScope_enum_table),
      std::end(ExchangeNodeScope_enum_table),
      [e](const std::pair<ExchangeNodeScope, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(ExchangeNodeScope_enum_table))
           ? it
           : std::begin(ExchangeNodeScope_enum_table))
          ->second;
}
void from_json(const json& j, ExchangeNodeScope& e) {
  static_assert(
      std::is_enum<ExchangeNodeScope>::value,
      "ExchangeNodeScope must be an enum!");
  const auto* it = std::find_if(
      std::begin(ExchangeNodeScope_enum_table),
      std::end(ExchangeNodeScope_enum_table),
      [&j](const std::pair<ExchangeNodeScope, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(ExchangeNodeScope_enum_table))
           ? it
           : std::begin(ExchangeNodeScope_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<ExchangeNodeType, json> ExchangeNodeType_enum_table[] = {
    // NOLINT: cert-err58-cpp
    {ExchangeNodeType::GATHER, "GATHER"},
    {ExchangeNodeType::REPARTITION, "REPARTITION"},
    {ExchangeNodeType::REPLICATE, "REPLICATE"},
};
void to_json(json& j, const ExchangeNodeType& e) {
  static_assert(
      std::is_enum<ExchangeNodeType>::value,
      "ExchangeNodeType must be an enum!");
  const auto* it = std::find_if(
      std::begin(ExchangeNodeType_enum_table),
      std::end(ExchangeNodeType_enum_table),
      [e](const std::pair<ExchangeNodeType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(ExchangeNodeType_enum_table))
           ? it
           : std::begin(ExchangeNodeType_enum_table))
          ->second;
}
void from_json(const json& j, ExchangeNodeType& e) {
  static_assert(
      std::is_enum<ExchangeNodeType>::value,
      "ExchangeNodeType must be an enum!");
  const auto* it = std::find_if(
      std::begin(ExchangeNodeType_enum_table),
      std::end(ExchangeNodeType_enum_table),
      [&j](const std::pair<ExchangeNodeType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(ExchangeNodeType_enum_table))
           ? it
           : std::begin(ExchangeNodeType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
ExchangeNode::ExchangeNode() noexcept {
  _type = "com.facebook.presto.sql.planner.plan.ExchangeNode";
}

void to_json(json& j, const ExchangeNode& p) {
  j = json::object();
  j["@type"] = "com.facebook.presto.sql.planner.plan.ExchangeNode";
  to_json_key(j, "id", p.id, "ExchangeNode", "PlanNodeId", "id");
  to_json_key(j, "type", p.type, "ExchangeNode", "ExchangeNodeType", "type");
  to_json_key(
      j, "scope", p.scope, "ExchangeNode", "ExchangeNodeScope", "scope");
  to_json_key(
      j,
      "partitioningScheme",
      p.partitioningScheme,
      "ExchangeNode",
      "PartitioningScheme",
      "partitioningScheme");
  to_json_key(
      j,
      "sources",
      p.sources,
      "ExchangeNode",
      "List<std::shared_ptr<PlanNode>>",
      "sources");
  to_json_key(
      j,
      "inputs",
      p.inputs,
      "ExchangeNode",
      "List<List<VariableReferenceExpression>>",
      "inputs");
  to_json_key(
      j,
      "ensureSourceOrdering",
      p.ensureSourceOrdering,
      "ExchangeNode",
      "bool",
      "ensureSourceOrdering");
  to_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "ExchangeNode",
      "OrderingScheme",
      "orderingScheme");
}

void from_json(const json& j, ExchangeNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "ExchangeNode", "PlanNodeId", "id");
  from_json_key(j, "type", p.type, "ExchangeNode", "ExchangeNodeType", "type");
  from_json_key(
      j, "scope", p.scope, "ExchangeNode", "ExchangeNodeScope", "scope");
  from_json_key(
      j,
      "partitioningScheme",
      p.partitioningScheme,
      "ExchangeNode",
      "PartitioningScheme",
      "partitioningScheme");
  from_json_key(
      j,
      "sources",
      p.sources,
      "ExchangeNode",
      "List<std::shared_ptr<PlanNode>>",
      "sources");
  from_json_key(
      j,
      "inputs",
      p.inputs,
      "ExchangeNode",
      "List<List<VariableReferenceExpression>>",
      "inputs");
  from_json_key(
      j,
      "ensureSourceOrdering",
      p.ensureSourceOrdering,
      "ExchangeNode",
      "bool",
      "ensureSourceOrdering");
  from_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "ExchangeNode",
      "OrderingScheme",
      "orderingScheme");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
ExecuteProcedureHandle::ExecuteProcedureHandle() noexcept {
  _type = "ExecuteProcedureHandle";
}

void to_json(json& j, const ExecuteProcedureHandle& p) {
  j = json::object();
  j["@type"] = "ExecuteProcedureHandle";
  to_json_key(
      j,
      "handle",
      p.handle,
      "ExecuteProcedureHandle",
      "DistributedProcedureHandle",
      "handle");
  to_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "ExecuteProcedureHandle",
      "SchemaTableName",
      "schemaTableName");
  to_json_key(
      j,
      "procedureName",
      p.procedureName,
      "ExecuteProcedureHandle",
      "QualifiedObjectName",
      "procedureName");
}

void from_json(const json& j, ExecuteProcedureHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "handle",
      p.handle,
      "ExecuteProcedureHandle",
      "DistributedProcedureHandle",
      "handle");
  from_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "ExecuteProcedureHandle",
      "SchemaTableName",
      "schemaTableName");
  from_json_key(
      j,
      "procedureName",
      p.procedureName,
      "ExecuteProcedureHandle",
      "QualifiedObjectName",
      "procedureName");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<ErrorCause, json> ErrorCause_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {ErrorCause::UNKNOWN, "UNKNOWN"},
        {ErrorCause::LOW_PARTITION_COUNT, "LOW_PARTITION_COUNT"},
        {ErrorCause::EXCEEDS_BROADCAST_MEMORY_LIMIT,
         "EXCEEDS_BROADCAST_MEMORY_LIMIT"}};
void to_json(json& j, const ErrorCause& e) {
  static_assert(std::is_enum<ErrorCause>::value, "ErrorCause must be an enum!");
  const auto* it = std::find_if(
      std::begin(ErrorCause_enum_table),
      std::end(ErrorCause_enum_table),
      [e](const std::pair<ErrorCause, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(ErrorCause_enum_table))
           ? it
           : std::begin(ErrorCause_enum_table))
          ->second;
}
void from_json(const json& j, ErrorCause& e) {
  static_assert(std::is_enum<ErrorCause>::value, "ErrorCause must be an enum!");
  const auto* it = std::find_if(
      std::begin(ErrorCause_enum_table),
      std::end(ErrorCause_enum_table),
      [&j](const std::pair<ErrorCause, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(ErrorCause_enum_table))
           ? it
           : std::begin(ErrorCause_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const ExecutionFailureInfo& p) {
  j = json::object();
  to_json_key(j, "type", p.type, "ExecutionFailureInfo", "String", "type");
  to_json_key(
      j, "message", p.message, "ExecutionFailureInfo", "String", "message");
  to_json_key(
      j,
      "cause",
      p.cause,
      "ExecutionFailureInfo",
      "ExecutionFailureInfo",
      "cause");
  to_json_key(
      j,
      "suppressed",
      p.suppressed,
      "ExecutionFailureInfo",
      "List<ExecutionFailureInfo>",
      "suppressed");
  to_json_key(
      j, "stack", p.stack, "ExecutionFailureInfo", "List<String>", "stack");
  to_json_key(
      j,
      "errorLocation",
      p.errorLocation,
      "ExecutionFailureInfo",
      "ErrorLocation",
      "errorLocation");
  to_json_key(
      j,
      "errorCode",
      p.errorCode,
      "ExecutionFailureInfo",
      "ErrorCode",
      "errorCode");
  to_json_key(
      j,
      "remoteHost",
      p.remoteHost,
      "ExecutionFailureInfo",
      "HostAddress",
      "remoteHost");
  to_json_key(
      j,
      "errorCause",
      p.errorCause,
      "ExecutionFailureInfo",
      "ErrorCause",
      "errorCause");
}

void from_json(const json& j, ExecutionFailureInfo& p) {
  from_json_key(j, "type", p.type, "ExecutionFailureInfo", "String", "type");
  from_json_key(
      j, "message", p.message, "ExecutionFailureInfo", "String", "message");
  from_json_key(
      j,
      "cause",
      p.cause,
      "ExecutionFailureInfo",
      "ExecutionFailureInfo",
      "cause");
  from_json_key(
      j,
      "suppressed",
      p.suppressed,
      "ExecutionFailureInfo",
      "List<ExecutionFailureInfo>",
      "suppressed");
  from_json_key(
      j, "stack", p.stack, "ExecutionFailureInfo", "List<String>", "stack");
  from_json_key(
      j,
      "errorLocation",
      p.errorLocation,
      "ExecutionFailureInfo",
      "ErrorLocation",
      "errorLocation");
  from_json_key(
      j,
      "errorCode",
      p.errorCode,
      "ExecutionFailureInfo",
      "ErrorCode",
      "errorCode");
  from_json_key(
      j,
      "remoteHost",
      p.remoteHost,
      "ExecutionFailureInfo",
      "HostAddress",
      "remoteHost");
  from_json_key(
      j,
      "errorCause",
      p.errorCause,
      "ExecutionFailureInfo",
      "ErrorCause",
      "errorCause");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
FilterNode::FilterNode() noexcept {
  _type = ".FilterNode";
}

void to_json(json& j, const FilterNode& p) {
  j = json::object();
  j["@type"] = ".FilterNode";
  to_json_key(j, "id", p.id, "FilterNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "FilterNode", "PlanNode", "source");
  to_json_key(
      j, "predicate", p.predicate, "FilterNode", "RowExpression", "predicate");
}

void from_json(const json& j, FilterNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "FilterNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "FilterNode", "PlanNode", "source");
  from_json_key(
      j, "predicate", p.predicate, "FilterNode", "RowExpression", "predicate");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<BoundType, json> BoundType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {BoundType::UNBOUNDED_PRECEDING, "UNBOUNDED_PRECEDING"},
        {BoundType::PRECEDING, "PRECEDING"},
        {BoundType::CURRENT_ROW, "CURRENT_ROW"},
        {BoundType::FOLLOWING, "FOLLOWING"},
        {BoundType::UNBOUNDED_FOLLOWING, "UNBOUNDED_FOLLOWING"}};
void to_json(json& j, const BoundType& e) {
  static_assert(std::is_enum<BoundType>::value, "BoundType must be an enum!");
  const auto* it = std::find_if(
      std::begin(BoundType_enum_table),
      std::end(BoundType_enum_table),
      [e](const std::pair<BoundType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(BoundType_enum_table))
           ? it
           : std::begin(BoundType_enum_table))
          ->second;
}
void from_json(const json& j, BoundType& e) {
  static_assert(std::is_enum<BoundType>::value, "BoundType must be an enum!");
  const auto* it = std::find_if(
      std::begin(BoundType_enum_table),
      std::end(BoundType_enum_table),
      [&j](const std::pair<BoundType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(BoundType_enum_table))
           ? it
           : std::begin(BoundType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<WindowType, json> WindowType_enum_table[] = {
    // NOLINT: cert-err58-cpp
    {WindowType::RANGE, "RANGE"},
    {WindowType::ROWS, "ROWS"},
    {WindowType::GROUPS, "GROUPS"},
};
void to_json(json& j, const WindowType& e) {
  static_assert(std::is_enum<WindowType>::value, "WindowType must be an enum!");
  const auto* it = std::find_if(
      std::begin(WindowType_enum_table),
      std::end(WindowType_enum_table),
      [e](const std::pair<WindowType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(WindowType_enum_table))
           ? it
           : std::begin(WindowType_enum_table))
          ->second;
}
void from_json(const json& j, WindowType& e) {
  static_assert(std::is_enum<WindowType>::value, "WindowType must be an enum!");
  const auto* it = std::find_if(
      std::begin(WindowType_enum_table),
      std::end(WindowType_enum_table),
      [&j](const std::pair<WindowType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(WindowType_enum_table))
           ? it
           : std::begin(WindowType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Frame& p) {
  j = json::object();
  to_json_key(j, "type", p.type, "Frame", "WindowType", "type");
  to_json_key(j, "startType", p.startType, "Frame", "BoundType", "startType");
  to_json_key(
      j,
      "startValue",
      p.startValue,
      "Frame",
      "VariableReferenceExpression",
      "startValue");
  to_json_key(
      j,
      "sortKeyCoercedForFrameStartComparison",
      p.sortKeyCoercedForFrameStartComparison,
      "Frame",
      "VariableReferenceExpression",
      "sortKeyCoercedForFrameStartComparison");
  to_json_key(j, "endType", p.endType, "Frame", "BoundType", "endType");
  to_json_key(
      j,
      "endValue",
      p.endValue,
      "Frame",
      "VariableReferenceExpression",
      "endValue");
  to_json_key(
      j,
      "sortKeyCoercedForFrameEndComparison",
      p.sortKeyCoercedForFrameEndComparison,
      "Frame",
      "VariableReferenceExpression",
      "sortKeyCoercedForFrameEndComparison");
  to_json_key(
      j,
      "originalStartValue",
      p.originalStartValue,
      "Frame",
      "String",
      "originalStartValue");
  to_json_key(
      j,
      "originalEndValue",
      p.originalEndValue,
      "Frame",
      "String",
      "originalEndValue");
}

void from_json(const json& j, Frame& p) {
  from_json_key(j, "type", p.type, "Frame", "WindowType", "type");
  from_json_key(j, "startType", p.startType, "Frame", "BoundType", "startType");
  from_json_key(
      j,
      "startValue",
      p.startValue,
      "Frame",
      "VariableReferenceExpression",
      "startValue");
  from_json_key(
      j,
      "sortKeyCoercedForFrameStartComparison",
      p.sortKeyCoercedForFrameStartComparison,
      "Frame",
      "VariableReferenceExpression",
      "sortKeyCoercedForFrameStartComparison");
  from_json_key(j, "endType", p.endType, "Frame", "BoundType", "endType");
  from_json_key(
      j,
      "endValue",
      p.endValue,
      "Frame",
      "VariableReferenceExpression",
      "endValue");
  from_json_key(
      j,
      "sortKeyCoercedForFrameEndComparison",
      p.sortKeyCoercedForFrameEndComparison,
      "Frame",
      "VariableReferenceExpression",
      "sortKeyCoercedForFrameEndComparison");
  from_json_key(
      j,
      "originalStartValue",
      p.originalStartValue,
      "Frame",
      "String",
      "originalStartValue");
  from_json_key(
      j,
      "originalEndValue",
      p.originalEndValue,
      "Frame",
      "String",
      "originalEndValue");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Function& p) {
  j = json::object();
  to_json_key(
      j,
      "functionCall",
      p.functionCall,
      "Function",
      "CallExpression",
      "functionCall");
  to_json_key(j, "frame", p.frame, "Function", "Frame", "frame");
  to_json_key(
      j, "ignoreNulls", p.ignoreNulls, "Function", "bool", "ignoreNulls");
}

void from_json(const json& j, Function& p) {
  from_json_key(
      j,
      "functionCall",
      p.functionCall,
      "Function",
      "CallExpression",
      "functionCall");
  from_json_key(j, "frame", p.frame, "Function", "Frame", "frame");
  from_json_key(
      j, "ignoreNulls", p.ignoreNulls, "Function", "bool", "ignoreNulls");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
GenericTableReturnTypeSpecification::
    GenericTableReturnTypeSpecification() noexcept {
  _type = "generic_table";
}

void to_json(json& j, const GenericTableReturnTypeSpecification& p) {
  j = json::object();
  j["@type"] = "generic_table";
  to_json_key(
      j,
      "returnType",
      p.returnType,
      "GenericTableReturnTypeSpecification",
      "String",
      "returnType");
}

void from_json(const json& j, GenericTableReturnTypeSpecification& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "returnType",
      p.returnType,
      "GenericTableReturnTypeSpecification",
      "String",
      "returnType");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
GroupIdNode::GroupIdNode() noexcept {
  _type = "com.facebook.presto.sql.planner.plan.GroupIdNode";
}

void to_json(json& j, const GroupIdNode& p) {
  j = json::object();
  j["@type"] = "com.facebook.presto.sql.planner.plan.GroupIdNode";
  to_json_key(j, "id", p.id, "GroupIdNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "GroupIdNode", "PlanNode", "source");
  to_json_key(
      j,
      "groupingSets",
      p.groupingSets,
      "GroupIdNode",
      "List<List<VariableReferenceExpression>>",
      "groupingSets");
  to_json_key(
      j,
      "groupingColumns",
      p.groupingColumns,
      "GroupIdNode",
      "Map<VariableReferenceExpression, VariableReferenceExpression>",
      "groupingColumns");
  to_json_key(
      j,
      "aggregationArguments",
      p.aggregationArguments,
      "GroupIdNode",
      "List<VariableReferenceExpression>",
      "aggregationArguments");
  to_json_key(
      j,
      "groupIdVariable",
      p.groupIdVariable,
      "GroupIdNode",
      "VariableReferenceExpression",
      "groupIdVariable");
}

void from_json(const json& j, GroupIdNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "GroupIdNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "GroupIdNode", "PlanNode", "source");
  from_json_key(
      j,
      "groupingSets",
      p.groupingSets,
      "GroupIdNode",
      "List<List<VariableReferenceExpression>>",
      "groupingSets");
  from_json_key(
      j,
      "groupingColumns",
      p.groupingColumns,
      "GroupIdNode",
      "Map<VariableReferenceExpression, VariableReferenceExpression>",
      "groupingColumns");
  from_json_key(
      j,
      "aggregationArguments",
      p.aggregationArguments,
      "GroupIdNode",
      "List<VariableReferenceExpression>",
      "aggregationArguments");
  from_json_key(
      j,
      "groupIdVariable",
      p.groupIdVariable,
      "GroupIdNode",
      "VariableReferenceExpression",
      "groupIdVariable");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ConnectorIndexHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;
  getConnectorProtocol(type).to_json(j, p);
}

void from_json(const json& j, std::shared_ptr<ConnectorIndexHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) + " ConnectorIndexHandle ConnectorIndexHandle");
  }
  getConnectorProtocol(type).from_json(j, p);
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const IndexHandle& p) {
  j = json::object();
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "IndexHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "IndexHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  to_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "IndexHandle",
      "ConnectorIndexHandle",
      "connectorHandle");
}

void from_json(const json& j, IndexHandle& p) {
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "IndexHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "IndexHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  from_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "IndexHandle",
      "ConnectorIndexHandle",
      "connectorHandle");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<JoinType, json> JoinType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {JoinType::INNER, "INNER"},
        {JoinType::LEFT, "LEFT"},
        {JoinType::RIGHT, "RIGHT"},
        {JoinType::FULL, "FULL"},
        {JoinType::SOURCE_OUTER, "SOURCE_OUTER"}};
void to_json(json& j, const JoinType& e) {
  static_assert(std::is_enum<JoinType>::value, "JoinType must be an enum!");
  const auto* it = std::find_if(
      std::begin(JoinType_enum_table),
      std::end(JoinType_enum_table),
      [e](const std::pair<JoinType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(JoinType_enum_table)) ? it
                                             : std::begin(JoinType_enum_table))
          ->second;
}
void from_json(const json& j, JoinType& e) {
  static_assert(std::is_enum<JoinType>::value, "JoinType must be an enum!");
  const auto* it = std::find_if(
      std::begin(JoinType_enum_table),
      std::end(JoinType_enum_table),
      [&j](const std::pair<JoinType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(JoinType_enum_table)) ? it
                                             : std::begin(JoinType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
IndexJoinNode::IndexJoinNode() noexcept {
  _type = ".IndexJoinNode";
}

void to_json(json& j, const IndexJoinNode& p) {
  j = json::object();
  j["@type"] = ".IndexJoinNode";
  to_json_key(j, "id", p.id, "IndexJoinNode", "PlanNodeId", "id");
  to_json_key(j, "type", p.type, "IndexJoinNode", "JoinType", "type");
  to_json_key(
      j,
      "probeSource",
      p.probeSource,
      "IndexJoinNode",
      "PlanNode",
      "probeSource");
  to_json_key(
      j,
      "indexSource",
      p.indexSource,
      "IndexJoinNode",
      "PlanNode",
      "indexSource");
  to_json_key(
      j,
      "criteria",
      p.criteria,
      "IndexJoinNode",
      "List<EquiJoinClause>",
      "criteria");
  to_json_key(
      j,
      "filter",
      p.filter,
      "IndexJoinNode",
      "std::shared_ptr<RowExpression>",
      "filter");
  to_json_key(
      j,
      "probeHashVariable",
      p.probeHashVariable,
      "IndexJoinNode",
      "VariableReferenceExpression",
      "probeHashVariable");
  to_json_key(
      j,
      "indexHashVariable",
      p.indexHashVariable,
      "IndexJoinNode",
      "VariableReferenceExpression",
      "indexHashVariable");
  to_json_key(
      j,
      "lookupVariables",
      p.lookupVariables,
      "IndexJoinNode",
      "List<VariableReferenceExpression>",
      "lookupVariables");
}

void from_json(const json& j, IndexJoinNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "IndexJoinNode", "PlanNodeId", "id");
  from_json_key(j, "type", p.type, "IndexJoinNode", "JoinType", "type");
  from_json_key(
      j,
      "probeSource",
      p.probeSource,
      "IndexJoinNode",
      "PlanNode",
      "probeSource");
  from_json_key(
      j,
      "indexSource",
      p.indexSource,
      "IndexJoinNode",
      "PlanNode",
      "indexSource");
  from_json_key(
      j,
      "criteria",
      p.criteria,
      "IndexJoinNode",
      "List<EquiJoinClause>",
      "criteria");
  from_json_key(
      j,
      "filter",
      p.filter,
      "IndexJoinNode",
      "std::shared_ptr<RowExpression>",
      "filter");
  from_json_key(
      j,
      "probeHashVariable",
      p.probeHashVariable,
      "IndexJoinNode",
      "VariableReferenceExpression",
      "probeHashVariable");
  from_json_key(
      j,
      "indexHashVariable",
      p.indexHashVariable,
      "IndexJoinNode",
      "VariableReferenceExpression",
      "indexHashVariable");
  from_json_key(
      j,
      "lookupVariables",
      p.lookupVariables,
      "IndexJoinNode",
      "List<VariableReferenceExpression>",
      "lookupVariables");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ColumnHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;
  getConnectorProtocol(type).to_json(j, p);
}

void from_json(const json& j, std::shared_ptr<ColumnHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(std::string(e.what()) + " ColumnHandle  ColumnHandle");
  }
  getConnectorProtocol(type).from_json(j, p);
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ConnectorTableLayoutHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;
  getConnectorProtocol(type).to_json(j, p);
}

void from_json(const json& j, std::shared_ptr<ConnectorTableLayoutHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) +
        " ConnectorTableLayoutHandle  ConnectorTableLayoutHandle");
  }
  getConnectorProtocol(type).from_json(j, p);
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const TableHandle& p) {
  j = json::object();
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "TableHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "TableHandle",
      "ConnectorTableHandle",
      "connectorHandle");
  to_json_key(
      j,
      "transaction",
      p.transaction,
      "TableHandle",
      "ConnectorTransactionHandle",
      "transaction");
  to_json_key(
      j,
      "connectorTableLayout",
      p.connectorTableLayout,
      "TableHandle",
      "ConnectorTableLayoutHandle",
      "connectorTableLayout");
}

void from_json(const json& j, TableHandle& p) {
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "TableHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "TableHandle",
      "ConnectorTableHandle",
      "connectorHandle");
  from_json_key(
      j,
      "transaction",
      p.transaction,
      "TableHandle",
      "ConnectorTransactionHandle",
      "transaction");
  from_json_key(
      j,
      "connectorTableLayout",
      p.connectorTableLayout,
      "TableHandle",
      "ConnectorTableLayoutHandle",
      "connectorTableLayout");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
IndexSourceNode::IndexSourceNode() noexcept {
  _type = ".IndexSourceNode";
}

void to_json(json& j, const IndexSourceNode& p) {
  j = json::object();
  j["@type"] = ".IndexSourceNode";
  to_json_key(j, "id", p.id, "IndexSourceNode", "PlanNodeId", "id");
  to_json_key(
      j,
      "indexHandle",
      p.indexHandle,
      "IndexSourceNode",
      "IndexHandle",
      "indexHandle");
  to_json_key(
      j,
      "tableHandle",
      p.tableHandle,
      "IndexSourceNode",
      "TableHandle",
      "tableHandle");
  to_json_key(
      j,
      "lookupVariables",
      p.lookupVariables,
      "IndexSourceNode",
      "List<VariableReferenceExpression>",
      "lookupVariables");
  to_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "IndexSourceNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  to_json_key(
      j,
      "assignments",
      p.assignments,
      "IndexSourceNode",
      "Map<VariableReferenceExpression, std::shared_ptr<ColumnHandle>>",
      "assignments");
  to_json_key(
      j,
      "currentConstraint",
      p.currentConstraint,
      "IndexSourceNode",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "currentConstraint");
}

void from_json(const json& j, IndexSourceNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "IndexSourceNode", "PlanNodeId", "id");
  from_json_key(
      j,
      "indexHandle",
      p.indexHandle,
      "IndexSourceNode",
      "IndexHandle",
      "indexHandle");
  from_json_key(
      j,
      "tableHandle",
      p.tableHandle,
      "IndexSourceNode",
      "TableHandle",
      "tableHandle");
  from_json_key(
      j,
      "lookupVariables",
      p.lookupVariables,
      "IndexSourceNode",
      "List<VariableReferenceExpression>",
      "lookupVariables");
  from_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "IndexSourceNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  from_json_key(
      j,
      "assignments",
      p.assignments,
      "IndexSourceNode",
      "Map<VariableReferenceExpression, std::shared_ptr<ColumnHandle>>",
      "assignments");
  from_json_key(
      j,
      "currentConstraint",
      p.currentConstraint,
      "IndexSourceNode",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "currentConstraint");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ConnectorInsertTableHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;
  getConnectorProtocol(type).to_json(j, p);
}

void from_json(const json& j, std::shared_ptr<ConnectorInsertTableHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) +
        " ConnectorInsertTableHandle  ConnectorInsertTableHandle");
  }
  getConnectorProtocol(type).from_json(j, p);
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const InsertTableHandle& p) {
  j = json::object();
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "InsertTableHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "InsertTableHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  to_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "InsertTableHandle",
      "ConnectorInsertTableHandle",
      "connectorHandle");
}

void from_json(const json& j, InsertTableHandle& p) {
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "InsertTableHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "transactionHandle",
      p.transactionHandle,
      "InsertTableHandle",
      "ConnectorTransactionHandle",
      "transactionHandle");
  from_json_key(
      j,
      "connectorHandle",
      p.connectorHandle,
      "InsertTableHandle",
      "ConnectorInsertTableHandle",
      "connectorHandle");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
InsertHandle::InsertHandle() noexcept {
  _type = "InsertHandle";
}

void to_json(json& j, const InsertHandle& p) {
  j = json::object();
  j["@type"] = "InsertHandle";
  to_json_key(
      j, "handle", p.handle, "InsertHandle", "InsertTableHandle", "handle");
  to_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "InsertHandle",
      "SchemaTableName",
      "schemaTableName");
}

void from_json(const json& j, InsertHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j, "handle", p.handle, "InsertHandle", "InsertTableHandle", "handle");
  from_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "InsertHandle",
      "SchemaTableName",
      "schemaTableName");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<JoinDistributionType, json>
    JoinDistributionType_enum_table[] =
        { // NOLINT: cert-err58-cpp
            {JoinDistributionType::PARTITIONED, "PARTITIONED"},
            {JoinDistributionType::REPLICATED, "REPLICATED"}};
void to_json(json& j, const JoinDistributionType& e) {
  static_assert(
      std::is_enum<JoinDistributionType>::value,
      "JoinDistributionType must be an enum!");
  const auto* it = std::find_if(
      std::begin(JoinDistributionType_enum_table),
      std::end(JoinDistributionType_enum_table),
      [e](const std::pair<JoinDistributionType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(JoinDistributionType_enum_table))
           ? it
           : std::begin(JoinDistributionType_enum_table))
          ->second;
}
void from_json(const json& j, JoinDistributionType& e) {
  static_assert(
      std::is_enum<JoinDistributionType>::value,
      "JoinDistributionType must be an enum!");
  const auto* it = std::find_if(
      std::begin(JoinDistributionType_enum_table),
      std::end(JoinDistributionType_enum_table),
      [&j](const std::pair<JoinDistributionType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(JoinDistributionType_enum_table))
           ? it
           : std::begin(JoinDistributionType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
JoinNode::JoinNode() noexcept {
  _type = ".JoinNode";
}

void to_json(json& j, const JoinNode& p) {
  j = json::object();
  j["@type"] = ".JoinNode";
  to_json_key(j, "id", p.id, "JoinNode", "PlanNodeId", "id");
  to_json_key(j, "type", p.type, "JoinNode", "JoinType", "type");
  to_json_key(j, "left", p.left, "JoinNode", "PlanNode", "left");
  to_json_key(j, "right", p.right, "JoinNode", "PlanNode", "right");
  to_json_key(
      j,
      "criteria",
      p.criteria,
      "JoinNode",
      "List<EquiJoinClause>",
      "criteria");
  to_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "JoinNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  to_json_key(
      j,
      "filter",
      p.filter,
      "JoinNode",
      "std::shared_ptr<RowExpression>",
      "filter");
  to_json_key(
      j,
      "leftHashVariable",
      p.leftHashVariable,
      "JoinNode",
      "VariableReferenceExpression",
      "leftHashVariable");
  to_json_key(
      j,
      "rightHashVariable",
      p.rightHashVariable,
      "JoinNode",
      "VariableReferenceExpression",
      "rightHashVariable");
  to_json_key(
      j,
      "distributionType",
      p.distributionType,
      "JoinNode",
      "JoinDistributionType",
      "distributionType");
  to_json_key(
      j,
      "dynamicFilters",
      p.dynamicFilters,
      "JoinNode",
      "Map<String, VariableReferenceExpression>",
      "dynamicFilters");
}

void from_json(const json& j, JoinNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "JoinNode", "PlanNodeId", "id");
  from_json_key(j, "type", p.type, "JoinNode", "JoinType", "type");
  from_json_key(j, "left", p.left, "JoinNode", "PlanNode", "left");
  from_json_key(j, "right", p.right, "JoinNode", "PlanNode", "right");
  from_json_key(
      j,
      "criteria",
      p.criteria,
      "JoinNode",
      "List<EquiJoinClause>",
      "criteria");
  from_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "JoinNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  from_json_key(
      j,
      "filter",
      p.filter,
      "JoinNode",
      "std::shared_ptr<RowExpression>",
      "filter");
  from_json_key(
      j,
      "leftHashVariable",
      p.leftHashVariable,
      "JoinNode",
      "VariableReferenceExpression",
      "leftHashVariable");
  from_json_key(
      j,
      "rightHashVariable",
      p.rightHashVariable,
      "JoinNode",
      "VariableReferenceExpression",
      "rightHashVariable");
  from_json_key(
      j,
      "distributionType",
      p.distributionType,
      "JoinNode",
      "JoinDistributionType",
      "distributionType");
  from_json_key(
      j,
      "dynamicFilters",
      p.dynamicFilters,
      "JoinNode",
      "Map<String, VariableReferenceExpression>",
      "dynamicFilters");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const JoinNodeStatsEstimate& p) {
  j = json::object();
  to_json_key(
      j,
      "nullJoinBuildKeyCount",
      p.nullJoinBuildKeyCount,
      "JoinNodeStatsEstimate",
      "double",
      "nullJoinBuildKeyCount");
  to_json_key(
      j,
      "joinBuildKeyCount",
      p.joinBuildKeyCount,
      "JoinNodeStatsEstimate",
      "double",
      "joinBuildKeyCount");
  to_json_key(
      j,
      "nullJoinProbeKeyCount",
      p.nullJoinProbeKeyCount,
      "JoinNodeStatsEstimate",
      "double",
      "nullJoinProbeKeyCount");
  to_json_key(
      j,
      "joinProbeKeyCount",
      p.joinProbeKeyCount,
      "JoinNodeStatsEstimate",
      "double",
      "joinProbeKeyCount");
}

void from_json(const json& j, JoinNodeStatsEstimate& p) {
  from_json_key(
      j,
      "nullJoinBuildKeyCount",
      p.nullJoinBuildKeyCount,
      "JoinNodeStatsEstimate",
      "double",
      "nullJoinBuildKeyCount");
  from_json_key(
      j,
      "joinBuildKeyCount",
      p.joinBuildKeyCount,
      "JoinNodeStatsEstimate",
      "double",
      "joinBuildKeyCount");
  from_json_key(
      j,
      "nullJoinProbeKeyCount",
      p.nullJoinProbeKeyCount,
      "JoinNodeStatsEstimate",
      "double",
      "nullJoinProbeKeyCount");
  from_json_key(
      j,
      "joinProbeKeyCount",
      p.joinProbeKeyCount,
      "JoinNodeStatsEstimate",
      "double",
      "joinProbeKeyCount");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const JsonBasedTableFunctionMetadata& p) {
  j = json::object();
  to_json_key(
      j,
      "functionName",
      p.functionName,
      "JsonBasedTableFunctionMetadata",
      "QualifiedObjectName",
      "functionName");
  to_json_key(
      j,
      "arguments",
      p.arguments,
      "JsonBasedTableFunctionMetadata",
      "List<std::shared_ptr<ArgumentSpecification>>",
      "arguments");
  to_json_key(
      j,
      "returnTypeSpecification",
      p.returnTypeSpecification,
      "JsonBasedTableFunctionMetadata",
      "ReturnTypeSpecification",
      "returnTypeSpecification");
}

void from_json(const json& j, JsonBasedTableFunctionMetadata& p) {
  from_json_key(
      j,
      "functionName",
      p.functionName,
      "JsonBasedTableFunctionMetadata",
      "QualifiedObjectName",
      "functionName");
  from_json_key(
      j,
      "arguments",
      p.arguments,
      "JsonBasedTableFunctionMetadata",
      "List<std::shared_ptr<ArgumentSpecification>>",
      "arguments");
  from_json_key(
      j,
      "returnTypeSpecification",
      p.returnTypeSpecification,
      "JsonBasedTableFunctionMetadata",
      "ReturnTypeSpecification",
      "returnTypeSpecification");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const JsonBasedUdfFunctionMetadata& p) {
  j = json::object();
  to_json_key(
      j,
      "docString",
      p.docString,
      "JsonBasedUdfFunctionMetadata",
      "String",
      "docString");
  to_json_key(
      j,
      "functionKind",
      p.functionKind,
      "JsonBasedUdfFunctionMetadata",
      "FunctionKind",
      "functionKind");
  to_json_key(
      j,
      "outputType",
      p.outputType,
      "JsonBasedUdfFunctionMetadata",
      "TypeSignature",
      "outputType");
  to_json_key(
      j,
      "paramTypes",
      p.paramTypes,
      "JsonBasedUdfFunctionMetadata",
      "List<TypeSignature>",
      "paramTypes");
  to_json_key(
      j,
      "schema",
      p.schema,
      "JsonBasedUdfFunctionMetadata",
      "String",
      "schema");
  to_json_key(
      j,
      "variableArity",
      p.variableArity,
      "JsonBasedUdfFunctionMetadata",
      "bool",
      "variableArity");
  to_json_key(
      j,
      "routineCharacteristics",
      p.routineCharacteristics,
      "JsonBasedUdfFunctionMetadata",
      "RoutineCharacteristics",
      "routineCharacteristics");
  to_json_key(
      j,
      "aggregateMetadata",
      p.aggregateMetadata,
      "JsonBasedUdfFunctionMetadata",
      "AggregationFunctionMetadata",
      "aggregateMetadata");
  to_json_key(
      j,
      "functionId",
      p.functionId,
      "JsonBasedUdfFunctionMetadata",
      "SqlFunctionId",
      "functionId");
  to_json_key(
      j,
      "version",
      p.version,
      "JsonBasedUdfFunctionMetadata",
      "String",
      "version");
  to_json_key(
      j,
      "typeVariableConstraints",
      p.typeVariableConstraints,
      "JsonBasedUdfFunctionMetadata",
      "List<TypeVariableConstraint>",
      "typeVariableConstraints");
  to_json_key(
      j,
      "longVariableConstraints",
      p.longVariableConstraints,
      "JsonBasedUdfFunctionMetadata",
      "List<LongVariableConstraint>",
      "longVariableConstraints");
  to_json_key(
      j,
      "executionEndpoint",
      p.executionEndpoint,
      "JsonBasedUdfFunctionMetadata",
      "URI",
      "executionEndpoint");
}

void from_json(const json& j, JsonBasedUdfFunctionMetadata& p) {
  from_json_key(
      j,
      "docString",
      p.docString,
      "JsonBasedUdfFunctionMetadata",
      "String",
      "docString");
  from_json_key(
      j,
      "functionKind",
      p.functionKind,
      "JsonBasedUdfFunctionMetadata",
      "FunctionKind",
      "functionKind");
  from_json_key(
      j,
      "outputType",
      p.outputType,
      "JsonBasedUdfFunctionMetadata",
      "TypeSignature",
      "outputType");
  from_json_key(
      j,
      "paramTypes",
      p.paramTypes,
      "JsonBasedUdfFunctionMetadata",
      "List<TypeSignature>",
      "paramTypes");
  from_json_key(
      j,
      "schema",
      p.schema,
      "JsonBasedUdfFunctionMetadata",
      "String",
      "schema");
  from_json_key(
      j,
      "variableArity",
      p.variableArity,
      "JsonBasedUdfFunctionMetadata",
      "bool",
      "variableArity");
  from_json_key(
      j,
      "routineCharacteristics",
      p.routineCharacteristics,
      "JsonBasedUdfFunctionMetadata",
      "RoutineCharacteristics",
      "routineCharacteristics");
  from_json_key(
      j,
      "aggregateMetadata",
      p.aggregateMetadata,
      "JsonBasedUdfFunctionMetadata",
      "AggregationFunctionMetadata",
      "aggregateMetadata");
  from_json_key(
      j,
      "functionId",
      p.functionId,
      "JsonBasedUdfFunctionMetadata",
      "SqlFunctionId",
      "functionId");
  from_json_key(
      j,
      "version",
      p.version,
      "JsonBasedUdfFunctionMetadata",
      "String",
      "version");
  from_json_key(
      j,
      "typeVariableConstraints",
      p.typeVariableConstraints,
      "JsonBasedUdfFunctionMetadata",
      "List<TypeVariableConstraint>",
      "typeVariableConstraints");
  from_json_key(
      j,
      "longVariableConstraints",
      p.longVariableConstraints,
      "JsonBasedUdfFunctionMetadata",
      "List<LongVariableConstraint>",
      "longVariableConstraints");
  from_json_key(
      j,
      "executionEndpoint",
      p.executionEndpoint,
      "JsonBasedUdfFunctionMetadata",
      "URI",
      "executionEndpoint");
}
} // namespace facebook::presto::protocol
// dependency KeyedSubclass

namespace facebook::presto::protocol {

std::string JsonEncodedSubclass::getSubclassKey(const nlohmann::json& j) {
  if (j.is_array()) {
    // enum is serialized as an array: ["type","instance"]
    return j[0];
  } else {
    return j["@type"];
  }
}

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
LambdaDefinitionExpression::LambdaDefinitionExpression() noexcept {
  _type = "lambda";
}

void to_json(json& j, const LambdaDefinitionExpression& p) {
  j = json::object();
  j["@type"] = "lambda";
  to_json_key(
      j,
      "sourceLocation",
      p.sourceLocation,
      "LambdaDefinitionExpression",
      "SourceLocation",
      "sourceLocation");
  to_json_key(
      j,
      "argumentTypes",
      p.argumentTypes,
      "LambdaDefinitionExpression",
      "List<Type>",
      "argumentTypes");
  to_json_key(
      j,
      "arguments",
      p.arguments,
      "LambdaDefinitionExpression",
      "List<String>",
      "arguments");
  to_json_key(
      j, "body", p.body, "LambdaDefinitionExpression", "RowExpression", "body");
}

void from_json(const json& j, LambdaDefinitionExpression& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "sourceLocation",
      p.sourceLocation,
      "LambdaDefinitionExpression",
      "SourceLocation",
      "sourceLocation");
  from_json_key(
      j,
      "argumentTypes",
      p.argumentTypes,
      "LambdaDefinitionExpression",
      "List<Type>",
      "argumentTypes");
  from_json_key(
      j,
      "arguments",
      p.arguments,
      "LambdaDefinitionExpression",
      "List<String>",
      "arguments");
  from_json_key(
      j, "body", p.body, "LambdaDefinitionExpression", "RowExpression", "body");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<LimitNodeStep, json> LimitNodeStep_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {LimitNodeStep::PARTIAL, "PARTIAL"},
        {LimitNodeStep::FINAL, "FINAL"}};
void to_json(json& j, const LimitNodeStep& e) {
  static_assert(
      std::is_enum<LimitNodeStep>::value, "LimitNodeStep must be an enum!");
  const auto* it = std::find_if(
      std::begin(LimitNodeStep_enum_table),
      std::end(LimitNodeStep_enum_table),
      [e](const std::pair<LimitNodeStep, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(LimitNodeStep_enum_table))
           ? it
           : std::begin(LimitNodeStep_enum_table))
          ->second;
}
void from_json(const json& j, LimitNodeStep& e) {
  static_assert(
      std::is_enum<LimitNodeStep>::value, "LimitNodeStep must be an enum!");
  const auto* it = std::find_if(
      std::begin(LimitNodeStep_enum_table),
      std::end(LimitNodeStep_enum_table),
      [&j](const std::pair<LimitNodeStep, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(LimitNodeStep_enum_table))
           ? it
           : std::begin(LimitNodeStep_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
LimitNode::LimitNode() noexcept {
  _type = ".LimitNode";
}

void to_json(json& j, const LimitNode& p) {
  j = json::object();
  j["@type"] = ".LimitNode";
  to_json_key(j, "id", p.id, "LimitNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "LimitNode", "PlanNode", "source");
  to_json_key(j, "count", p.count, "LimitNode", "int64_t", "count");
  to_json_key(j, "step", p.step, "LimitNode", "LimitNodeStep", "step");
}

void from_json(const json& j, LimitNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "LimitNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "LimitNode", "PlanNode", "source");
  from_json_key(j, "count", p.count, "LimitNode", "int64_t", "count");
  from_json_key(j, "step", p.step, "LimitNode", "LimitNodeStep", "step");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Location& p) {
  j = json::object();
  to_json_key(j, "location", p.location, "Location", "String", "location");
}

void from_json(const json& j, Location& p) {
  from_json_key(j, "location", p.location, "Location", "String", "location");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
MarkDistinctNode::MarkDistinctNode() noexcept {
  _type = ".MarkDistinctNode";
}

void to_json(json& j, const MarkDistinctNode& p) {
  j = json::object();
  j["@type"] = ".MarkDistinctNode";
  to_json_key(j, "id", p.id, "MarkDistinctNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "MarkDistinctNode", "PlanNode", "source");
  to_json_key(
      j,
      "markerVariable",
      p.markerVariable,
      "MarkDistinctNode",
      "VariableReferenceExpression",
      "markerVariable");
  to_json_key(
      j,
      "distinctVariables",
      p.distinctVariables,
      "MarkDistinctNode",
      "List<VariableReferenceExpression>",
      "distinctVariables");
  to_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "MarkDistinctNode",
      "VariableReferenceExpression",
      "hashVariable");
}

void from_json(const json& j, MarkDistinctNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "MarkDistinctNode", "PlanNodeId", "id");
  from_json_key(
      j, "source", p.source, "MarkDistinctNode", "PlanNode", "source");
  from_json_key(
      j,
      "markerVariable",
      p.markerVariable,
      "MarkDistinctNode",
      "VariableReferenceExpression",
      "markerVariable");
  from_json_key(
      j,
      "distinctVariables",
      p.distinctVariables,
      "MarkDistinctNode",
      "List<VariableReferenceExpression>",
      "distinctVariables");
  from_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "MarkDistinctNode",
      "VariableReferenceExpression",
      "hashVariable");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<Bound, json> Bound_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {Bound::BELOW, "BELOW"},
        {Bound::EXACTLY, "EXACTLY"},
        {Bound::ABOVE, "ABOVE"}};
void to_json(json& j, const Bound& e) {
  static_assert(std::is_enum<Bound>::value, "Bound must be an enum!");
  const auto* it = std::find_if(
      std::begin(Bound_enum_table),
      std::end(Bound_enum_table),
      [e](const std::pair<Bound, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(Bound_enum_table)) ? it : std::begin(Bound_enum_table))
          ->second;
}
void from_json(const json& j, Bound& e) {
  static_assert(std::is_enum<Bound>::value, "Bound must be an enum!");
  const auto* it = std::find_if(
      std::begin(Bound_enum_table),
      std::end(Bound_enum_table),
      [&j](const std::pair<Bound, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(Bound_enum_table)) ? it : std::begin(Bound_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Marker& p) {
  j = json::object();
  to_json_key(j, "type", p.type, "Marker", "Type", "type");
  to_json_key(j, "valueBlock", p.valueBlock, "Marker", "Block", "valueBlock");
  to_json_key(j, "bound", p.bound, "Marker", "Bound", "bound");
}

void from_json(const json& j, Marker& p) {
  from_json_key(j, "type", p.type, "Marker", "Type", "type");
  from_json_key(j, "valueBlock", p.valueBlock, "Marker", "Block", "valueBlock");
  from_json_key(j, "bound", p.bound, "Marker", "Bound", "bound");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const MemoryAllocation& p) {
  j = json::object();
  to_json_key(j, "tag", p.tag, "MemoryAllocation", "String", "tag");
  to_json_key(
      j,
      "allocation",
      p.allocation,
      "MemoryAllocation",
      "int64_t",
      "allocation");
}

void from_json(const json& j, MemoryAllocation& p) {
  from_json_key(j, "tag", p.tag, "MemoryAllocation", "String", "tag");
  from_json_key(
      j,
      "allocation",
      p.allocation,
      "MemoryAllocation",
      "int64_t",
      "allocation");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const MemoryPoolInfo& p) {
  j = json::object();
  to_json_key(
      j, "maxBytes", p.maxBytes, "MemoryPoolInfo", "int64_t", "maxBytes");
  to_json_key(
      j,
      "reservedBytes",
      p.reservedBytes,
      "MemoryPoolInfo",
      "int64_t",
      "reservedBytes");
  to_json_key(
      j,
      "reservedRevocableBytes",
      p.reservedRevocableBytes,
      "MemoryPoolInfo",
      "int64_t",
      "reservedRevocableBytes");
  to_json_key(
      j,
      "queryMemoryReservations",
      p.queryMemoryReservations,
      "MemoryPoolInfo",
      "Map<QueryId, Long>",
      "queryMemoryReservations");
  to_json_key(
      j,
      "queryMemoryAllocations",
      p.queryMemoryAllocations,
      "MemoryPoolInfo",
      "Map<QueryId, List<MemoryAllocation>>",
      "queryMemoryAllocations");
  to_json_key(
      j,
      "queryMemoryRevocableReservations",
      p.queryMemoryRevocableReservations,
      "MemoryPoolInfo",
      "Map<QueryId, Long>",
      "queryMemoryRevocableReservations");
}

void from_json(const json& j, MemoryPoolInfo& p) {
  from_json_key(
      j, "maxBytes", p.maxBytes, "MemoryPoolInfo", "int64_t", "maxBytes");
  from_json_key(
      j,
      "reservedBytes",
      p.reservedBytes,
      "MemoryPoolInfo",
      "int64_t",
      "reservedBytes");
  from_json_key(
      j,
      "reservedRevocableBytes",
      p.reservedRevocableBytes,
      "MemoryPoolInfo",
      "int64_t",
      "reservedRevocableBytes");
  from_json_key(
      j,
      "queryMemoryReservations",
      p.queryMemoryReservations,
      "MemoryPoolInfo",
      "Map<QueryId, Long>",
      "queryMemoryReservations");
  from_json_key(
      j,
      "queryMemoryAllocations",
      p.queryMemoryAllocations,
      "MemoryPoolInfo",
      "Map<QueryId, List<MemoryAllocation>>",
      "queryMemoryAllocations");
  from_json_key(
      j,
      "queryMemoryRevocableReservations",
      p.queryMemoryRevocableReservations,
      "MemoryPoolInfo",
      "Map<QueryId, Long>",
      "queryMemoryRevocableReservations");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const MemoryInfo& p) {
  j = json::object();
  to_json_key(
      j,
      "totalNodeMemory",
      p.totalNodeMemory,
      "MemoryInfo",
      "DataSize",
      "totalNodeMemory");
  to_json_key(
      j,
      "pools",
      p.pools,
      "MemoryInfo",
      "Map<MemoryPoolId, MemoryPoolInfo>",
      "pools");
}

void from_json(const json& j, MemoryInfo& p) {
  from_json_key(
      j,
      "totalNodeMemory",
      p.totalNodeMemory,
      "MemoryInfo",
      "DataSize",
      "totalNodeMemory");
  from_json_key(
      j,
      "pools",
      p.pools,
      "MemoryInfo",
      "Map<MemoryPoolId, MemoryPoolInfo>",
      "pools");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
void to_json(json& j, const std::shared_ptr<ConnectorMergeTableHandle>& p) {
  if (p == nullptr) {
    return;
  }
  String type = p->_type;

  throw TypeError(type + " no abstract type ConnectorMergeTableHandle ");
}

void from_json(const json& j, std::shared_ptr<ConnectorMergeTableHandle>& p) {
  String type;
  try {
    type = p->getSubclassKey(j);
  } catch (json::parse_error& e) {
    throw ParseError(
        std::string(e.what()) +
        " ConnectorMergeTableHandle  ConnectorMergeTableHandle");
  }

  throw TypeError(type + " no abstract type ConnectorMergeTableHandle ");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
MergeHandle::MergeHandle() noexcept {
  _type = "MergeHandle";
}

void to_json(json& j, const MergeHandle& p) {
  j = json::object();
  j["@type"] = "MergeHandle";
  to_json_key(
      j,
      "tableHandle",
      p.tableHandle,
      "MergeHandle",
      "TableHandle",
      "tableHandle");
  to_json_key(
      j,
      "connectorMergeTableHandle",
      p.connectorMergeTableHandle,
      "MergeHandle",
      "ConnectorMergeTableHandle",
      "connectorMergeTableHandle");
}

void from_json(const json& j, MergeHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "tableHandle",
      p.tableHandle,
      "MergeHandle",
      "TableHandle",
      "tableHandle");
  from_json_key(
      j,
      "connectorMergeTableHandle",
      p.connectorMergeTableHandle,
      "MergeHandle",
      "ConnectorMergeTableHandle",
      "connectorMergeTableHandle");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
MergeJoinNode::MergeJoinNode() noexcept {
  _type = ".MergeJoinNode";
}

void to_json(json& j, const MergeJoinNode& p) {
  j = json::object();
  j["@type"] = ".MergeJoinNode";
  to_json_key(j, "id", p.id, "MergeJoinNode", "PlanNodeId", "id");
  to_json_key(j, "type", p.type, "MergeJoinNode", "JoinType", "type");
  to_json_key(j, "left", p.left, "MergeJoinNode", "PlanNode", "left");
  to_json_key(j, "right", p.right, "MergeJoinNode", "PlanNode", "right");
  to_json_key(
      j,
      "criteria",
      p.criteria,
      "MergeJoinNode",
      "List<EquiJoinClause>",
      "criteria");
  to_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "MergeJoinNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  to_json_key(
      j,
      "filter",
      p.filter,
      "MergeJoinNode",
      "std::shared_ptr<RowExpression>",
      "filter");
  to_json_key(
      j,
      "leftHashVariable",
      p.leftHashVariable,
      "MergeJoinNode",
      "VariableReferenceExpression",
      "leftHashVariable");
  to_json_key(
      j,
      "rightHashVariable",
      p.rightHashVariable,
      "MergeJoinNode",
      "VariableReferenceExpression",
      "rightHashVariable");
}

void from_json(const json& j, MergeJoinNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "MergeJoinNode", "PlanNodeId", "id");
  from_json_key(j, "type", p.type, "MergeJoinNode", "JoinType", "type");
  from_json_key(j, "left", p.left, "MergeJoinNode", "PlanNode", "left");
  from_json_key(j, "right", p.right, "MergeJoinNode", "PlanNode", "right");
  from_json_key(
      j,
      "criteria",
      p.criteria,
      "MergeJoinNode",
      "List<EquiJoinClause>",
      "criteria");
  from_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "MergeJoinNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  from_json_key(
      j,
      "filter",
      p.filter,
      "MergeJoinNode",
      "std::shared_ptr<RowExpression>",
      "filter");
  from_json_key(
      j,
      "leftHashVariable",
      p.leftHashVariable,
      "MergeJoinNode",
      "VariableReferenceExpression",
      "leftHashVariable");
  from_json_key(
      j,
      "rightHashVariable",
      p.rightHashVariable,
      "MergeJoinNode",
      "VariableReferenceExpression",
      "rightHashVariable");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<RowChangeParadigm, json> RowChangeParadigm_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {RowChangeParadigm::CHANGE_ONLY_UPDATED_COLUMNS,
         "CHANGE_ONLY_UPDATED_COLUMNS"},
        {RowChangeParadigm::DELETE_ROW_AND_INSERT_ROW,
         "DELETE_ROW_AND_INSERT_ROW"}};
void to_json(json& j, const RowChangeParadigm& e) {
  static_assert(
      std::is_enum<RowChangeParadigm>::value,
      "RowChangeParadigm must be an enum!");
  const auto* it = std::find_if(
      std::begin(RowChangeParadigm_enum_table),
      std::end(RowChangeParadigm_enum_table),
      [e](const std::pair<RowChangeParadigm, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(RowChangeParadigm_enum_table))
           ? it
           : std::begin(RowChangeParadigm_enum_table))
          ->second;
}
void from_json(const json& j, RowChangeParadigm& e) {
  static_assert(
      std::is_enum<RowChangeParadigm>::value,
      "RowChangeParadigm must be an enum!");
  const auto* it = std::find_if(
      std::begin(RowChangeParadigm_enum_table),
      std::end(RowChangeParadigm_enum_table),
      [&j](const std::pair<RowChangeParadigm, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(RowChangeParadigm_enum_table))
           ? it
           : std::begin(RowChangeParadigm_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const MergeParadigmAndTypes& p) {
  j = json::object();
  to_json_key(
      j,
      "paradigm",
      p.paradigm,
      "MergeParadigmAndTypes",
      "RowChangeParadigm",
      "paradigm");
  to_json_key(
      j,
      "columnTypes",
      p.columnTypes,
      "MergeParadigmAndTypes",
      "List<Type>",
      "columnTypes");
  to_json_key(
      j,
      "targetTableRowIdColumnType",
      p.targetTableRowIdColumnType,
      "MergeParadigmAndTypes",
      "Type",
      "targetTableRowIdColumnType");
}

void from_json(const json& j, MergeParadigmAndTypes& p) {
  from_json_key(
      j,
      "paradigm",
      p.paradigm,
      "MergeParadigmAndTypes",
      "RowChangeParadigm",
      "paradigm");
  from_json_key(
      j,
      "columnTypes",
      p.columnTypes,
      "MergeParadigmAndTypes",
      "List<Type>",
      "columnTypes");
  from_json_key(
      j,
      "targetTableRowIdColumnType",
      p.targetTableRowIdColumnType,
      "MergeParadigmAndTypes",
      "Type",
      "targetTableRowIdColumnType");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const MergeTarget& p) {
  j = json::object();
  to_json_key(j, "handle", p.handle, "MergeTarget", "TableHandle", "handle");
  to_json_key(
      j,
      "mergeHandle",
      p.mergeHandle,
      "MergeTarget",
      "MergeHandle",
      "mergeHandle");
  to_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "MergeTarget",
      "SchemaTableName",
      "schemaTableName");
  to_json_key(
      j,
      "mergeParadigmAndTypes",
      p.mergeParadigmAndTypes,
      "MergeTarget",
      "MergeParadigmAndTypes",
      "mergeParadigmAndTypes");
}

void from_json(const json& j, MergeTarget& p) {
  from_json_key(j, "handle", p.handle, "MergeTarget", "TableHandle", "handle");
  from_json_key(
      j,
      "mergeHandle",
      p.mergeHandle,
      "MergeTarget",
      "MergeHandle",
      "mergeHandle");
  from_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "MergeTarget",
      "SchemaTableName",
      "schemaTableName");
  from_json_key(
      j,
      "mergeParadigmAndTypes",
      p.mergeParadigmAndTypes,
      "MergeTarget",
      "MergeParadigmAndTypes",
      "mergeParadigmAndTypes");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const NativeField& p) {
  j = json::object();
  to_json_key(j, "name", p.name, "NativeField", "String", "name");
  to_json_key(
      j,
      "typeSignature",
      p.typeSignature,
      "NativeField",
      "TypeSignature",
      "typeSignature");
}

void from_json(const json& j, NativeField& p) {
  from_json_key(j, "name", p.name, "NativeField", "String", "name");
  from_json_key(
      j,
      "typeSignature",
      p.typeSignature,
      "NativeField",
      "TypeSignature",
      "typeSignature");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const NativeDescriptor& p) {
  j = json::object();
  to_json_key(
      j, "fields", p.fields, "NativeDescriptor", "List<NativeField>", "fields");
}

void from_json(const json& j, NativeDescriptor& p) {
  from_json_key(
      j, "fields", p.fields, "NativeDescriptor", "List<NativeField>", "fields");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const NativeSidecarFailureInfo& p) {
  j = json::object();
  to_json_key(j, "type", p.type, "NativeSidecarFailureInfo", "String", "type");
  to_json_key(
      j, "message", p.message, "NativeSidecarFailureInfo", "String", "message");
  to_json_key(
      j,
      "cause",
      p.cause,
      "NativeSidecarFailureInfo",
      "NativeSidecarFailureInfo",
      "cause");
  to_json_key(
      j,
      "suppressed",
      p.suppressed,
      "NativeSidecarFailureInfo",
      "List<NativeSidecarFailureInfo>",
      "suppressed");
  to_json_key(
      j, "stack", p.stack, "NativeSidecarFailureInfo", "List<String>", "stack");
  to_json_key(
      j,
      "errorCode",
      p.errorCode,
      "NativeSidecarFailureInfo",
      "ErrorCode",
      "errorCode");
}

void from_json(const json& j, NativeSidecarFailureInfo& p) {
  from_json_key(
      j, "type", p.type, "NativeSidecarFailureInfo", "String", "type");
  from_json_key(
      j, "message", p.message, "NativeSidecarFailureInfo", "String", "message");
  from_json_key(
      j,
      "cause",
      p.cause,
      "NativeSidecarFailureInfo",
      "NativeSidecarFailureInfo",
      "cause");
  from_json_key(
      j,
      "suppressed",
      p.suppressed,
      "NativeSidecarFailureInfo",
      "List<NativeSidecarFailureInfo>",
      "suppressed");
  from_json_key(
      j, "stack", p.stack, "NativeSidecarFailureInfo", "List<String>", "stack");
  from_json_key(
      j,
      "errorCode",
      p.errorCode,
      "NativeSidecarFailureInfo",
      "ErrorCode",
      "errorCode");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const NativeTableFunctionHandle& p) {
  j = json::object();
  to_json_key(
      j,
      "serializedTableFunctionHandle",
      p.serializedTableFunctionHandle,
      "NativeTableFunctionHandle",
      "String",
      "serializedTableFunctionHandle");
  to_json_key(
      j,
      "functionName",
      p.functionName,
      "NativeTableFunctionHandle",
      "QualifiedObjectName",
      "functionName");
}

void from_json(const json& j, NativeTableFunctionHandle& p) {
  from_json_key(
      j,
      "serializedTableFunctionHandle",
      p.serializedTableFunctionHandle,
      "NativeTableFunctionHandle",
      "String",
      "serializedTableFunctionHandle");
  from_json_key(
      j,
      "functionName",
      p.functionName,
      "NativeTableFunctionHandle",
      "QualifiedObjectName",
      "functionName");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const NativeTableFunctionAnalysis& p) {
  j = json::object();
  to_json_key(
      j,
      "returnedType",
      p.returnedType,
      "NativeTableFunctionAnalysis",
      "NativeDescriptor",
      "returnedType");
  to_json_key(
      j,
      "requiredColumns",
      p.requiredColumns,
      "NativeTableFunctionAnalysis",
      "Map<String, List<Integer>>",
      "requiredColumns");
  to_json_key(
      j,
      "handle",
      p.handle,
      "NativeTableFunctionAnalysis",
      "NativeTableFunctionHandle",
      "handle");
}

void from_json(const json& j, NativeTableFunctionAnalysis& p) {
  from_json_key(
      j,
      "returnedType",
      p.returnedType,
      "NativeTableFunctionAnalysis",
      "NativeDescriptor",
      "returnedType");
  from_json_key(
      j,
      "requiredColumns",
      p.requiredColumns,
      "NativeTableFunctionAnalysis",
      "Map<String, List<Integer>>",
      "requiredColumns");
  from_json_key(
      j,
      "handle",
      p.handle,
      "NativeTableFunctionAnalysis",
      "NativeTableFunctionHandle",
      "handle");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const NodeLoadMetrics& p) {
  j = json::object();
  to_json_key(
      j,
      "cpuUsedPercent",
      p.cpuUsedPercent,
      "NodeLoadMetrics",
      "double",
      "cpuUsedPercent");
  to_json_key(
      j,
      "memoryUsedInBytes",
      p.memoryUsedInBytes,
      "NodeLoadMetrics",
      "double",
      "memoryUsedInBytes");
  to_json_key(
      j,
      "numQueuedDrivers",
      p.numQueuedDrivers,
      "NodeLoadMetrics",
      "int",
      "numQueuedDrivers");
  to_json_key(
      j,
      "cpuOverload",
      p.cpuOverload,
      "NodeLoadMetrics",
      "bool",
      "cpuOverload");
  to_json_key(
      j,
      "memoryOverload",
      p.memoryOverload,
      "NodeLoadMetrics",
      "bool",
      "memoryOverload");
}

void from_json(const json& j, NodeLoadMetrics& p) {
  from_json_key(
      j,
      "cpuUsedPercent",
      p.cpuUsedPercent,
      "NodeLoadMetrics",
      "double",
      "cpuUsedPercent");
  from_json_key(
      j,
      "memoryUsedInBytes",
      p.memoryUsedInBytes,
      "NodeLoadMetrics",
      "double",
      "memoryUsedInBytes");
  from_json_key(
      j,
      "numQueuedDrivers",
      p.numQueuedDrivers,
      "NodeLoadMetrics",
      "int",
      "numQueuedDrivers");
  from_json_key(
      j,
      "cpuOverload",
      p.cpuOverload,
      "NodeLoadMetrics",
      "bool",
      "cpuOverload");
  from_json_key(
      j,
      "memoryOverload",
      p.memoryOverload,
      "NodeLoadMetrics",
      "bool",
      "memoryOverload");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<NodeState, json> NodeState_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {NodeState::ACTIVE, "ACTIVE"},
        {NodeState::INACTIVE, "INACTIVE"},
        {NodeState::SHUTTING_DOWN, "SHUTTING_DOWN"}};
void to_json(json& j, const NodeState& e) {
  static_assert(std::is_enum<NodeState>::value, "NodeState must be an enum!");
  const auto* it = std::find_if(
      std::begin(NodeState_enum_table),
      std::end(NodeState_enum_table),
      [e](const std::pair<NodeState, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(NodeState_enum_table))
           ? it
           : std::begin(NodeState_enum_table))
          ->second;
}
void from_json(const json& j, NodeState& e) {
  static_assert(std::is_enum<NodeState>::value, "NodeState must be an enum!");
  const auto* it = std::find_if(
      std::begin(NodeState_enum_table),
      std::end(NodeState_enum_table),
      [&j](const std::pair<NodeState, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(NodeState_enum_table))
           ? it
           : std::begin(NodeState_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const NodeStats& p) {
  j = json::object();
  to_json_key(
      j, "nodeState", p.nodeState, "NodeStats", "NodeState", "nodeState");
  to_json_key(
      j,
      "loadMetrics",
      p.loadMetrics,
      "NodeStats",
      "NodeLoadMetrics",
      "loadMetrics");
}

void from_json(const json& j, NodeStats& p) {
  from_json_key(
      j, "nodeState", p.nodeState, "NodeStats", "NodeState", "nodeState");
  from_json_key(
      j,
      "loadMetrics",
      p.loadMetrics,
      "NodeStats",
      "NodeLoadMetrics",
      "loadMetrics");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const NodeVersion& p) {
  j = json::object();
  to_json_key(j, "version", p.version, "NodeVersion", "String", "version");
}

void from_json(const json& j, NodeVersion& p) {
  from_json_key(j, "version", p.version, "NodeVersion", "String", "version");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const NodeStatus& p) {
  j = json::object();
  to_json_key(j, "nodeId", p.nodeId, "NodeStatus", "String", "nodeId");
  to_json_key(
      j,
      "nodeVersion",
      p.nodeVersion,
      "NodeStatus",
      "NodeVersion",
      "nodeVersion");
  to_json_key(
      j, "environment", p.environment, "NodeStatus", "String", "environment");
  to_json_key(
      j, "coordinator", p.coordinator, "NodeStatus", "bool", "coordinator");
  to_json_key(j, "uptime", p.uptime, "NodeStatus", "Duration", "uptime");
  to_json_key(
      j,
      "externalAddress",
      p.externalAddress,
      "NodeStatus",
      "String",
      "externalAddress");
  to_json_key(
      j,
      "internalAddress",
      p.internalAddress,
      "NodeStatus",
      "String",
      "internalAddress");
  to_json_key(
      j, "memoryInfo", p.memoryInfo, "NodeStatus", "MemoryInfo", "memoryInfo");
  to_json_key(j, "processors", p.processors, "NodeStatus", "int", "processors");
  to_json_key(
      j,
      "processCpuLoad",
      p.processCpuLoad,
      "NodeStatus",
      "double",
      "processCpuLoad");
  to_json_key(
      j,
      "systemCpuLoad",
      p.systemCpuLoad,
      "NodeStatus",
      "double",
      "systemCpuLoad");
  to_json_key(j, "heapUsed", p.heapUsed, "NodeStatus", "int64_t", "heapUsed");
  to_json_key(
      j,
      "heapAvailable",
      p.heapAvailable,
      "NodeStatus",
      "int64_t",
      "heapAvailable");
  to_json_key(
      j, "nonHeapUsed", p.nonHeapUsed, "NodeStatus", "int64_t", "nonHeapUsed");
}

void from_json(const json& j, NodeStatus& p) {
  from_json_key(j, "nodeId", p.nodeId, "NodeStatus", "String", "nodeId");
  from_json_key(
      j,
      "nodeVersion",
      p.nodeVersion,
      "NodeStatus",
      "NodeVersion",
      "nodeVersion");
  from_json_key(
      j, "environment", p.environment, "NodeStatus", "String", "environment");
  from_json_key(
      j, "coordinator", p.coordinator, "NodeStatus", "bool", "coordinator");
  from_json_key(j, "uptime", p.uptime, "NodeStatus", "Duration", "uptime");
  from_json_key(
      j,
      "externalAddress",
      p.externalAddress,
      "NodeStatus",
      "String",
      "externalAddress");
  from_json_key(
      j,
      "internalAddress",
      p.internalAddress,
      "NodeStatus",
      "String",
      "internalAddress");
  from_json_key(
      j, "memoryInfo", p.memoryInfo, "NodeStatus", "MemoryInfo", "memoryInfo");
  from_json_key(
      j, "processors", p.processors, "NodeStatus", "int", "processors");
  from_json_key(
      j,
      "processCpuLoad",
      p.processCpuLoad,
      "NodeStatus",
      "double",
      "processCpuLoad");
  from_json_key(
      j,
      "systemCpuLoad",
      p.systemCpuLoad,
      "NodeStatus",
      "double",
      "systemCpuLoad");
  from_json_key(j, "heapUsed", p.heapUsed, "NodeStatus", "int64_t", "heapUsed");
  from_json_key(
      j,
      "heapAvailable",
      p.heapAvailable,
      "NodeStatus",
      "int64_t",
      "heapAvailable");
  from_json_key(
      j, "nonHeapUsed", p.nonHeapUsed, "NodeStatus", "int64_t", "nonHeapUsed");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Serializable& p) {
  j = json::object();
  to_json_key(j, "type", p.type, "Serializable", "Type", "type");
  to_json_key(j, "block", p.block, "Serializable", "Block", "block");
}

void from_json(const json& j, Serializable& p) {
  from_json_key(j, "type", p.type, "Serializable", "Type", "type");
  from_json_key(j, "block", p.block, "Serializable", "Block", "block");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const NullableValue& p) {
  j = json::object();
  to_json_key(
      j,
      "serializable",
      p.serializable,
      "NullableValue",
      "Serializable",
      "serializable");
}

void from_json(const json& j, NullableValue& p) {
  from_json_key(
      j,
      "serializable",
      p.serializable,
      "NullableValue",
      "Serializable",
      "serializable");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
OnlyPassThroughReturnTypeSpecification::
    OnlyPassThroughReturnTypeSpecification() noexcept {
  _type = "only_pass_through_table";
}

void to_json(json& j, const OnlyPassThroughReturnTypeSpecification& p) {
  j = json::object();
  j["@type"] = "only_pass_through_table";
  to_json_key(
      j,
      "returnType",
      p.returnType,
      "OnlyPassThroughReturnTypeSpecification",
      "String",
      "returnType");
}

void from_json(const json& j, OnlyPassThroughReturnTypeSpecification& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "returnType",
      p.returnType,
      "OnlyPassThroughReturnTypeSpecification",
      "String",
      "returnType");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<BufferState, json> BufferState_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {BufferState::OPEN, "OPEN"},
        {BufferState::NO_MORE_BUFFERS, "NO_MORE_BUFFERS"},
        {BufferState::NO_MORE_PAGES, "NO_MORE_PAGES"},
        {BufferState::FLUSHING, "FLUSHING"},
        {BufferState::FINISHED, "FINISHED"},
        {BufferState::FAILED, "FAILED"}};
void to_json(json& j, const BufferState& e) {
  static_assert(
      std::is_enum<BufferState>::value, "BufferState must be an enum!");
  const auto* it = std::find_if(
      std::begin(BufferState_enum_table),
      std::end(BufferState_enum_table),
      [e](const std::pair<BufferState, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(BufferState_enum_table))
           ? it
           : std::begin(BufferState_enum_table))
          ->second;
}
void from_json(const json& j, BufferState& e) {
  static_assert(
      std::is_enum<BufferState>::value, "BufferState must be an enum!");
  const auto* it = std::find_if(
      std::begin(BufferState_enum_table),
      std::end(BufferState_enum_table),
      [&j](const std::pair<BufferState, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(BufferState_enum_table))
           ? it
           : std::begin(BufferState_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const OutputBufferInfo& p) {
  j = json::object();
  to_json_key(j, "type", p.type, "OutputBufferInfo", "String", "type");
  to_json_key(j, "state", p.state, "OutputBufferInfo", "BufferState", "state");
  to_json_key(
      j,
      "canAddBuffers",
      p.canAddBuffers,
      "OutputBufferInfo",
      "bool",
      "canAddBuffers");
  to_json_key(
      j,
      "canAddPages",
      p.canAddPages,
      "OutputBufferInfo",
      "bool",
      "canAddPages");
  to_json_key(
      j,
      "totalBufferedBytes",
      p.totalBufferedBytes,
      "OutputBufferInfo",
      "int64_t",
      "totalBufferedBytes");
  to_json_key(
      j,
      "totalBufferedPages",
      p.totalBufferedPages,
      "OutputBufferInfo",
      "int64_t",
      "totalBufferedPages");
  to_json_key(
      j,
      "totalRowsSent",
      p.totalRowsSent,
      "OutputBufferInfo",
      "int64_t",
      "totalRowsSent");
  to_json_key(
      j,
      "totalPagesSent",
      p.totalPagesSent,
      "OutputBufferInfo",
      "int64_t",
      "totalPagesSent");
  to_json_key(
      j,
      "buffers",
      p.buffers,
      "OutputBufferInfo",
      "List<BufferInfo>",
      "buffers");
}

void from_json(const json& j, OutputBufferInfo& p) {
  from_json_key(j, "type", p.type, "OutputBufferInfo", "String", "type");
  from_json_key(
      j, "state", p.state, "OutputBufferInfo", "BufferState", "state");
  from_json_key(
      j,
      "canAddBuffers",
      p.canAddBuffers,
      "OutputBufferInfo",
      "bool",
      "canAddBuffers");
  from_json_key(
      j,
      "canAddPages",
      p.canAddPages,
      "OutputBufferInfo",
      "bool",
      "canAddPages");
  from_json_key(
      j,
      "totalBufferedBytes",
      p.totalBufferedBytes,
      "OutputBufferInfo",
      "int64_t",
      "totalBufferedBytes");
  from_json_key(
      j,
      "totalBufferedPages",
      p.totalBufferedPages,
      "OutputBufferInfo",
      "int64_t",
      "totalBufferedPages");
  from_json_key(
      j,
      "totalRowsSent",
      p.totalRowsSent,
      "OutputBufferInfo",
      "int64_t",
      "totalRowsSent");
  from_json_key(
      j,
      "totalPagesSent",
      p.totalPagesSent,
      "OutputBufferInfo",
      "int64_t",
      "totalPagesSent");
  from_json_key(
      j,
      "buffers",
      p.buffers,
      "OutputBufferInfo",
      "List<BufferInfo>",
      "buffers");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
OutputNode::OutputNode() noexcept {
  _type = ".OutputNode";
}

void to_json(json& j, const OutputNode& p) {
  j = json::object();
  j["@type"] = ".OutputNode";
  to_json_key(j, "id", p.id, "OutputNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "OutputNode", "PlanNode", "source");
  to_json_key(
      j,
      "columnNames",
      p.columnNames,
      "OutputNode",
      "List<String>",
      "columnNames");
  to_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "OutputNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
}

void from_json(const json& j, OutputNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "OutputNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "OutputNode", "PlanNode", "source");
  from_json_key(
      j,
      "columnNames",
      p.columnNames,
      "OutputNode",
      "List<String>",
      "columnNames");
  from_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "OutputNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const PartialAggregationStatsEstimate& p) {
  j = json::object();
  to_json_key(
      j,
      "inputBytes",
      p.inputBytes,
      "PartialAggregationStatsEstimate",
      "double",
      "inputBytes");
  to_json_key(
      j,
      "outputBytes",
      p.outputBytes,
      "PartialAggregationStatsEstimate",
      "double",
      "outputBytes");
  to_json_key(
      j,
      "inputRowCount",
      p.inputRowCount,
      "PartialAggregationStatsEstimate",
      "double",
      "inputRowCount");
  to_json_key(
      j,
      "outputRowCount",
      p.outputRowCount,
      "PartialAggregationStatsEstimate",
      "double",
      "outputRowCount");
}

void from_json(const json& j, PartialAggregationStatsEstimate& p) {
  from_json_key(
      j,
      "inputBytes",
      p.inputBytes,
      "PartialAggregationStatsEstimate",
      "double",
      "inputBytes");
  from_json_key(
      j,
      "outputBytes",
      p.outputBytes,
      "PartialAggregationStatsEstimate",
      "double",
      "outputBytes");
  from_json_key(
      j,
      "inputRowCount",
      p.inputRowCount,
      "PartialAggregationStatsEstimate",
      "double",
      "inputRowCount");
  from_json_key(
      j,
      "outputRowCount",
      p.outputRowCount,
      "PartialAggregationStatsEstimate",
      "double",
      "outputRowCount");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const PipelineStats& p) {
  j = json::object();
  to_json_key(
      j, "pipelineId", p.pipelineId, "PipelineStats", "int", "pipelineId");
  to_json_key(
      j,
      "firstStartTimeInMillis",
      p.firstStartTimeInMillis,
      "PipelineStats",
      "int64_t",
      "firstStartTimeInMillis");
  to_json_key(
      j,
      "lastStartTimeInMillis",
      p.lastStartTimeInMillis,
      "PipelineStats",
      "int64_t",
      "lastStartTimeInMillis");
  to_json_key(
      j,
      "lastEndTimeInMillis",
      p.lastEndTimeInMillis,
      "PipelineStats",
      "int64_t",
      "lastEndTimeInMillis");
  to_json_key(
      j,
      "inputPipeline",
      p.inputPipeline,
      "PipelineStats",
      "bool",
      "inputPipeline");
  to_json_key(
      j,
      "outputPipeline",
      p.outputPipeline,
      "PipelineStats",
      "bool",
      "outputPipeline");
  to_json_key(
      j,
      "totalDrivers",
      p.totalDrivers,
      "PipelineStats",
      "int",
      "totalDrivers");
  to_json_key(
      j,
      "queuedDrivers",
      p.queuedDrivers,
      "PipelineStats",
      "int",
      "queuedDrivers");
  to_json_key(
      j,
      "queuedPartitionedDrivers",
      p.queuedPartitionedDrivers,
      "PipelineStats",
      "int",
      "queuedPartitionedDrivers");
  to_json_key(
      j,
      "queuedPartitionedSplitsWeight",
      p.queuedPartitionedSplitsWeight,
      "PipelineStats",
      "int64_t",
      "queuedPartitionedSplitsWeight");
  to_json_key(
      j,
      "runningDrivers",
      p.runningDrivers,
      "PipelineStats",
      "int",
      "runningDrivers");
  to_json_key(
      j,
      "runningPartitionedDrivers",
      p.runningPartitionedDrivers,
      "PipelineStats",
      "int",
      "runningPartitionedDrivers");
  to_json_key(
      j,
      "runningPartitionedSplitsWeight",
      p.runningPartitionedSplitsWeight,
      "PipelineStats",
      "int64_t",
      "runningPartitionedSplitsWeight");
  to_json_key(
      j,
      "blockedDrivers",
      p.blockedDrivers,
      "PipelineStats",
      "int",
      "blockedDrivers");
  to_json_key(
      j,
      "completedDrivers",
      p.completedDrivers,
      "PipelineStats",
      "int",
      "completedDrivers");
  to_json_key(
      j,
      "userMemoryReservationInBytes",
      p.userMemoryReservationInBytes,
      "PipelineStats",
      "int64_t",
      "userMemoryReservationInBytes");
  to_json_key(
      j,
      "revocableMemoryReservationInBytes",
      p.revocableMemoryReservationInBytes,
      "PipelineStats",
      "int64_t",
      "revocableMemoryReservationInBytes");
  to_json_key(
      j,
      "systemMemoryReservationInBytes",
      p.systemMemoryReservationInBytes,
      "PipelineStats",
      "int64_t",
      "systemMemoryReservationInBytes");
  to_json_key(
      j,
      "queuedTime",
      p.queuedTime,
      "PipelineStats",
      "DistributionSnapshot",
      "queuedTime");
  to_json_key(
      j,
      "elapsedTime",
      p.elapsedTime,
      "PipelineStats",
      "DistributionSnapshot",
      "elapsedTime");
  to_json_key(
      j,
      "totalScheduledTimeInNanos",
      p.totalScheduledTimeInNanos,
      "PipelineStats",
      "int64_t",
      "totalScheduledTimeInNanos");
  to_json_key(
      j,
      "totalCpuTimeInNanos",
      p.totalCpuTimeInNanos,
      "PipelineStats",
      "int64_t",
      "totalCpuTimeInNanos");
  to_json_key(
      j,
      "totalBlockedTimeInNanos",
      p.totalBlockedTimeInNanos,
      "PipelineStats",
      "int64_t",
      "totalBlockedTimeInNanos");
  to_json_key(
      j,
      "fullyBlocked",
      p.fullyBlocked,
      "PipelineStats",
      "bool",
      "fullyBlocked");
  to_json_key(
      j,
      "blockedReasons",
      p.blockedReasons,
      "PipelineStats",
      "List<BlockedReason>",
      "blockedReasons");
  to_json_key(
      j,
      "totalAllocationInBytes",
      p.totalAllocationInBytes,
      "PipelineStats",
      "int64_t",
      "totalAllocationInBytes");
  to_json_key(
      j,
      "rawInputDataSizeInBytes",
      p.rawInputDataSizeInBytes,
      "PipelineStats",
      "int64_t",
      "rawInputDataSizeInBytes");
  to_json_key(
      j,
      "rawInputPositions",
      p.rawInputPositions,
      "PipelineStats",
      "int64_t",
      "rawInputPositions");
  to_json_key(
      j,
      "processedInputDataSizeInBytes",
      p.processedInputDataSizeInBytes,
      "PipelineStats",
      "int64_t",
      "processedInputDataSizeInBytes");
  to_json_key(
      j,
      "processedInputPositions",
      p.processedInputPositions,
      "PipelineStats",
      "int64_t",
      "processedInputPositions");
  to_json_key(
      j,
      "outputDataSizeInBytes",
      p.outputDataSizeInBytes,
      "PipelineStats",
      "int64_t",
      "outputDataSizeInBytes");
  to_json_key(
      j,
      "outputPositions",
      p.outputPositions,
      "PipelineStats",
      "int64_t",
      "outputPositions");
  to_json_key(
      j,
      "physicalWrittenDataSizeInBytes",
      p.physicalWrittenDataSizeInBytes,
      "PipelineStats",
      "int64_t",
      "physicalWrittenDataSizeInBytes");
  to_json_key(
      j,
      "operatorSummaries",
      p.operatorSummaries,
      "PipelineStats",
      "List<OperatorStats>",
      "operatorSummaries");
  to_json_key(
      j, "drivers", p.drivers, "PipelineStats", "List<DriverStats>", "drivers");
}

void from_json(const json& j, PipelineStats& p) {
  from_json_key(
      j, "pipelineId", p.pipelineId, "PipelineStats", "int", "pipelineId");
  from_json_key(
      j,
      "firstStartTimeInMillis",
      p.firstStartTimeInMillis,
      "PipelineStats",
      "int64_t",
      "firstStartTimeInMillis");
  from_json_key(
      j,
      "lastStartTimeInMillis",
      p.lastStartTimeInMillis,
      "PipelineStats",
      "int64_t",
      "lastStartTimeInMillis");
  from_json_key(
      j,
      "lastEndTimeInMillis",
      p.lastEndTimeInMillis,
      "PipelineStats",
      "int64_t",
      "lastEndTimeInMillis");
  from_json_key(
      j,
      "inputPipeline",
      p.inputPipeline,
      "PipelineStats",
      "bool",
      "inputPipeline");
  from_json_key(
      j,
      "outputPipeline",
      p.outputPipeline,
      "PipelineStats",
      "bool",
      "outputPipeline");
  from_json_key(
      j,
      "totalDrivers",
      p.totalDrivers,
      "PipelineStats",
      "int",
      "totalDrivers");
  from_json_key(
      j,
      "queuedDrivers",
      p.queuedDrivers,
      "PipelineStats",
      "int",
      "queuedDrivers");
  from_json_key(
      j,
      "queuedPartitionedDrivers",
      p.queuedPartitionedDrivers,
      "PipelineStats",
      "int",
      "queuedPartitionedDrivers");
  from_json_key(
      j,
      "queuedPartitionedSplitsWeight",
      p.queuedPartitionedSplitsWeight,
      "PipelineStats",
      "int64_t",
      "queuedPartitionedSplitsWeight");
  from_json_key(
      j,
      "runningDrivers",
      p.runningDrivers,
      "PipelineStats",
      "int",
      "runningDrivers");
  from_json_key(
      j,
      "runningPartitionedDrivers",
      p.runningPartitionedDrivers,
      "PipelineStats",
      "int",
      "runningPartitionedDrivers");
  from_json_key(
      j,
      "runningPartitionedSplitsWeight",
      p.runningPartitionedSplitsWeight,
      "PipelineStats",
      "int64_t",
      "runningPartitionedSplitsWeight");
  from_json_key(
      j,
      "blockedDrivers",
      p.blockedDrivers,
      "PipelineStats",
      "int",
      "blockedDrivers");
  from_json_key(
      j,
      "completedDrivers",
      p.completedDrivers,
      "PipelineStats",
      "int",
      "completedDrivers");
  from_json_key(
      j,
      "userMemoryReservationInBytes",
      p.userMemoryReservationInBytes,
      "PipelineStats",
      "int64_t",
      "userMemoryReservationInBytes");
  from_json_key(
      j,
      "revocableMemoryReservationInBytes",
      p.revocableMemoryReservationInBytes,
      "PipelineStats",
      "int64_t",
      "revocableMemoryReservationInBytes");
  from_json_key(
      j,
      "systemMemoryReservationInBytes",
      p.systemMemoryReservationInBytes,
      "PipelineStats",
      "int64_t",
      "systemMemoryReservationInBytes");
  from_json_key(
      j,
      "queuedTime",
      p.queuedTime,
      "PipelineStats",
      "DistributionSnapshot",
      "queuedTime");
  from_json_key(
      j,
      "elapsedTime",
      p.elapsedTime,
      "PipelineStats",
      "DistributionSnapshot",
      "elapsedTime");
  from_json_key(
      j,
      "totalScheduledTimeInNanos",
      p.totalScheduledTimeInNanos,
      "PipelineStats",
      "int64_t",
      "totalScheduledTimeInNanos");
  from_json_key(
      j,
      "totalCpuTimeInNanos",
      p.totalCpuTimeInNanos,
      "PipelineStats",
      "int64_t",
      "totalCpuTimeInNanos");
  from_json_key(
      j,
      "totalBlockedTimeInNanos",
      p.totalBlockedTimeInNanos,
      "PipelineStats",
      "int64_t",
      "totalBlockedTimeInNanos");
  from_json_key(
      j,
      "fullyBlocked",
      p.fullyBlocked,
      "PipelineStats",
      "bool",
      "fullyBlocked");
  from_json_key(
      j,
      "blockedReasons",
      p.blockedReasons,
      "PipelineStats",
      "List<BlockedReason>",
      "blockedReasons");
  from_json_key(
      j,
      "totalAllocationInBytes",
      p.totalAllocationInBytes,
      "PipelineStats",
      "int64_t",
      "totalAllocationInBytes");
  from_json_key(
      j,
      "rawInputDataSizeInBytes",
      p.rawInputDataSizeInBytes,
      "PipelineStats",
      "int64_t",
      "rawInputDataSizeInBytes");
  from_json_key(
      j,
      "rawInputPositions",
      p.rawInputPositions,
      "PipelineStats",
      "int64_t",
      "rawInputPositions");
  from_json_key(
      j,
      "processedInputDataSizeInBytes",
      p.processedInputDataSizeInBytes,
      "PipelineStats",
      "int64_t",
      "processedInputDataSizeInBytes");
  from_json_key(
      j,
      "processedInputPositions",
      p.processedInputPositions,
      "PipelineStats",
      "int64_t",
      "processedInputPositions");
  from_json_key(
      j,
      "outputDataSizeInBytes",
      p.outputDataSizeInBytes,
      "PipelineStats",
      "int64_t",
      "outputDataSizeInBytes");
  from_json_key(
      j,
      "outputPositions",
      p.outputPositions,
      "PipelineStats",
      "int64_t",
      "outputPositions");
  from_json_key(
      j,
      "physicalWrittenDataSizeInBytes",
      p.physicalWrittenDataSizeInBytes,
      "PipelineStats",
      "int64_t",
      "physicalWrittenDataSizeInBytes");
  from_json_key(
      j,
      "operatorSummaries",
      p.operatorSummaries,
      "PipelineStats",
      "List<OperatorStats>",
      "operatorSummaries");
  from_json_key(
      j, "drivers", p.drivers, "PipelineStats", "List<DriverStats>", "drivers");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const PlanConversionResponse& p) {
  j = json::object();
  to_json_key(
      j,
      "failures",
      p.failures,
      "PlanConversionResponse",
      "List<NativeSidecarFailureInfo>",
      "failures");
}

void from_json(const json& j, PlanConversionResponse& p) {
  from_json_key(
      j,
      "failures",
      p.failures,
      "PlanConversionResponse",
      "List<NativeSidecarFailureInfo>",
      "failures");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const PlanCostEstimate& p) {
  j = json::object();
  to_json_key(j, "cpuCost", p.cpuCost, "PlanCostEstimate", "double", "cpuCost");
  to_json_key(
      j, "maxMemory", p.maxMemory, "PlanCostEstimate", "double", "maxMemory");
  to_json_key(
      j,
      "maxMemoryWhenOutputting",
      p.maxMemoryWhenOutputting,
      "PlanCostEstimate",
      "double",
      "maxMemoryWhenOutputting");
  to_json_key(
      j,
      "networkCost",
      p.networkCost,
      "PlanCostEstimate",
      "double",
      "networkCost");
}

void from_json(const json& j, PlanCostEstimate& p) {
  from_json_key(
      j, "cpuCost", p.cpuCost, "PlanCostEstimate", "double", "cpuCost");
  from_json_key(
      j, "maxMemory", p.maxMemory, "PlanCostEstimate", "double", "maxMemory");
  from_json_key(
      j,
      "maxMemoryWhenOutputting",
      p.maxMemoryWhenOutputting,
      "PlanCostEstimate",
      "double",
      "maxMemoryWhenOutputting");
  from_json_key(
      j,
      "networkCost",
      p.networkCost,
      "PlanCostEstimate",
      "double",
      "networkCost");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<StageExecutionStrategy, json>
    StageExecutionStrategy_enum_table[] =
        { // NOLINT: cert-err58-cpp
            {StageExecutionStrategy::UNGROUPED_EXECUTION,
             "UNGROUPED_EXECUTION"},
            {StageExecutionStrategy::FIXED_LIFESPAN_SCHEDULE_GROUPED_EXECUTION,
             "FIXED_LIFESPAN_SCHEDULE_GROUPED_EXECUTION"},
            {StageExecutionStrategy::
                 DYNAMIC_LIFESPAN_SCHEDULE_GROUPED_EXECUTION,
             "DYNAMIC_LIFESPAN_SCHEDULE_GROUPED_EXECUTION"},
            {StageExecutionStrategy::RECOVERABLE_GROUPED_EXECUTION,
             "RECOVERABLE_GROUPED_EXECUTION"}};
void to_json(json& j, const StageExecutionStrategy& e) {
  static_assert(
      std::is_enum<StageExecutionStrategy>::value,
      "StageExecutionStrategy must be an enum!");
  const auto* it = std::find_if(
      std::begin(StageExecutionStrategy_enum_table),
      std::end(StageExecutionStrategy_enum_table),
      [e](const std::pair<StageExecutionStrategy, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(StageExecutionStrategy_enum_table))
           ? it
           : std::begin(StageExecutionStrategy_enum_table))
          ->second;
}
void from_json(const json& j, StageExecutionStrategy& e) {
  static_assert(
      std::is_enum<StageExecutionStrategy>::value,
      "StageExecutionStrategy must be an enum!");
  const auto* it = std::find_if(
      std::begin(StageExecutionStrategy_enum_table),
      std::end(StageExecutionStrategy_enum_table),
      [&j](const std::pair<StageExecutionStrategy, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(StageExecutionStrategy_enum_table))
           ? it
           : std::begin(StageExecutionStrategy_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const StageExecutionDescriptor& p) {
  j = json::object();
  to_json_key(
      j,
      "stageExecutionStrategy",
      p.stageExecutionStrategy,
      "StageExecutionDescriptor",
      "StageExecutionStrategy",
      "stageExecutionStrategy");
  to_json_key(
      j,
      "groupedExecutionScanNodes",
      p.groupedExecutionScanNodes,
      "StageExecutionDescriptor",
      "List<PlanNodeId>",
      "groupedExecutionScanNodes");
  to_json_key(
      j,
      "totalLifespans",
      p.totalLifespans,
      "StageExecutionDescriptor",
      "int",
      "totalLifespans");
}

void from_json(const json& j, StageExecutionDescriptor& p) {
  from_json_key(
      j,
      "stageExecutionStrategy",
      p.stageExecutionStrategy,
      "StageExecutionDescriptor",
      "StageExecutionStrategy",
      "stageExecutionStrategy");
  from_json_key(
      j,
      "groupedExecutionScanNodes",
      p.groupedExecutionScanNodes,
      "StageExecutionDescriptor",
      "List<PlanNodeId>",
      "groupedExecutionScanNodes");
  from_json_key(
      j,
      "totalLifespans",
      p.totalLifespans,
      "StageExecutionDescriptor",
      "int",
      "totalLifespans");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<ConfidenceLevel, json> ConfidenceLevel_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {ConfidenceLevel::LOW, "LOW"},
        {ConfidenceLevel::HIGH, "HIGH"},
        {ConfidenceLevel::FACT, "FACT"}};
void to_json(json& j, const ConfidenceLevel& e) {
  static_assert(
      std::is_enum<ConfidenceLevel>::value, "ConfidenceLevel must be an enum!");
  const auto* it = std::find_if(
      std::begin(ConfidenceLevel_enum_table),
      std::end(ConfidenceLevel_enum_table),
      [e](const std::pair<ConfidenceLevel, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(ConfidenceLevel_enum_table))
           ? it
           : std::begin(ConfidenceLevel_enum_table))
          ->second;
}
void from_json(const json& j, ConfidenceLevel& e) {
  static_assert(
      std::is_enum<ConfidenceLevel>::value, "ConfidenceLevel must be an enum!");
  const auto* it = std::find_if(
      std::begin(ConfidenceLevel_enum_table),
      std::end(ConfidenceLevel_enum_table),
      [&j](const std::pair<ConfidenceLevel, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(ConfidenceLevel_enum_table))
           ? it
           : std::begin(ConfidenceLevel_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const TableWriterNodeStatsEstimate& p) {
  j = json::object();
  to_json_key(
      j,
      "taskCountIfScaledWriter",
      p.taskCountIfScaledWriter,
      "TableWriterNodeStatsEstimate",
      "double",
      "taskCountIfScaledWriter");
}

void from_json(const json& j, TableWriterNodeStatsEstimate& p) {
  from_json_key(
      j,
      "taskCountIfScaledWriter",
      p.taskCountIfScaledWriter,
      "TableWriterNodeStatsEstimate",
      "double",
      "taskCountIfScaledWriter");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const VariableStatsEstimate& p) {
  j = json::object();
  to_json_key(
      j, "lowValue", p.lowValue, "VariableStatsEstimate", "double", "lowValue");
  to_json_key(
      j,
      "highValue",
      p.highValue,
      "VariableStatsEstimate",
      "double",
      "highValue");
  to_json_key(
      j,
      "nullsFraction",
      p.nullsFraction,
      "VariableStatsEstimate",
      "double",
      "nullsFraction");
  to_json_key(
      j,
      "averageRowSize",
      p.averageRowSize,
      "VariableStatsEstimate",
      "double",
      "averageRowSize");
  to_json_key(
      j,
      "distinctValuesCount",
      p.distinctValuesCount,
      "VariableStatsEstimate",
      "double",
      "distinctValuesCount");
}

void from_json(const json& j, VariableStatsEstimate& p) {
  from_json_key(
      j, "lowValue", p.lowValue, "VariableStatsEstimate", "double", "lowValue");
  from_json_key(
      j,
      "highValue",
      p.highValue,
      "VariableStatsEstimate",
      "double",
      "highValue");
  from_json_key(
      j,
      "nullsFraction",
      p.nullsFraction,
      "VariableStatsEstimate",
      "double",
      "nullsFraction");
  from_json_key(
      j,
      "averageRowSize",
      p.averageRowSize,
      "VariableStatsEstimate",
      "double",
      "averageRowSize");
  from_json_key(
      j,
      "distinctValuesCount",
      p.distinctValuesCount,
      "VariableStatsEstimate",
      "double",
      "distinctValuesCount");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const PlanNodeStatsEstimate& p) {
  j = json::object();
  to_json_key(
      j,
      "outputRowCount",
      p.outputRowCount,
      "PlanNodeStatsEstimate",
      "double",
      "outputRowCount");
  to_json_key(
      j,
      "totalSize",
      p.totalSize,
      "PlanNodeStatsEstimate",
      "double",
      "totalSize");
  to_json_key(
      j,
      "confident",
      p.confident,
      "PlanNodeStatsEstimate",
      "ConfidenceLevel",
      "confident");
  to_json_key(
      j,
      "variableStatistics",
      p.variableStatistics,
      "PlanNodeStatsEstimate",
      "Map<VariableReferenceExpression, VariableStatsEstimate>",
      "variableStatistics");
  to_json_key(
      j,
      "joinNodeStatsEstimate",
      p.joinNodeStatsEstimate,
      "PlanNodeStatsEstimate",
      "JoinNodeStatsEstimate",
      "joinNodeStatsEstimate");
  to_json_key(
      j,
      "tableWriterNodeStatsEstimate",
      p.tableWriterNodeStatsEstimate,
      "PlanNodeStatsEstimate",
      "TableWriterNodeStatsEstimate",
      "tableWriterNodeStatsEstimate");
  to_json_key(
      j,
      "partialAggregationStatsEstimate",
      p.partialAggregationStatsEstimate,
      "PlanNodeStatsEstimate",
      "PartialAggregationStatsEstimate",
      "partialAggregationStatsEstimate");
}

void from_json(const json& j, PlanNodeStatsEstimate& p) {
  from_json_key(
      j,
      "outputRowCount",
      p.outputRowCount,
      "PlanNodeStatsEstimate",
      "double",
      "outputRowCount");
  from_json_key(
      j,
      "totalSize",
      p.totalSize,
      "PlanNodeStatsEstimate",
      "double",
      "totalSize");
  from_json_key(
      j,
      "confident",
      p.confident,
      "PlanNodeStatsEstimate",
      "ConfidenceLevel",
      "confident");
  from_json_key(
      j,
      "variableStatistics",
      p.variableStatistics,
      "PlanNodeStatsEstimate",
      "Map<VariableReferenceExpression, VariableStatsEstimate>",
      "variableStatistics");
  from_json_key(
      j,
      "joinNodeStatsEstimate",
      p.joinNodeStatsEstimate,
      "PlanNodeStatsEstimate",
      "JoinNodeStatsEstimate",
      "joinNodeStatsEstimate");
  from_json_key(
      j,
      "tableWriterNodeStatsEstimate",
      p.tableWriterNodeStatsEstimate,
      "PlanNodeStatsEstimate",
      "TableWriterNodeStatsEstimate",
      "tableWriterNodeStatsEstimate");
  from_json_key(
      j,
      "partialAggregationStatsEstimate",
      p.partialAggregationStatsEstimate,
      "PlanNodeStatsEstimate",
      "PartialAggregationStatsEstimate",
      "partialAggregationStatsEstimate");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const StatsAndCosts& p) {
  j = json::object();
  to_json_key(
      j,
      "stats",
      p.stats,
      "StatsAndCosts",
      "Map<PlanNodeId, PlanNodeStatsEstimate>",
      "stats");
  to_json_key(
      j,
      "costs",
      p.costs,
      "StatsAndCosts",
      "Map<PlanNodeId, PlanCostEstimate>",
      "costs");
}

void from_json(const json& j, StatsAndCosts& p) {
  from_json_key(
      j,
      "stats",
      p.stats,
      "StatsAndCosts",
      "Map<PlanNodeId, PlanNodeStatsEstimate>",
      "stats");
  from_json_key(
      j,
      "costs",
      p.costs,
      "StatsAndCosts",
      "Map<PlanNodeId, PlanCostEstimate>",
      "costs");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const PlanFragment& p) {
  j = json::object();
  to_json_key(j, "id", p.id, "PlanFragment", "PlanFragmentId", "id");
  to_json_key(j, "root", p.root, "PlanFragment", "PlanNode", "root");
  to_json_key(
      j,
      "variables",
      p.variables,
      "PlanFragment",
      "List<VariableReferenceExpression>",
      "variables");
  to_json_key(
      j,
      "partitioning",
      p.partitioning,
      "PlanFragment",
      "PartitioningHandle",
      "partitioning");
  to_json_key(
      j,
      "tableScanSchedulingOrder",
      p.tableScanSchedulingOrder,
      "PlanFragment",
      "List<PlanNodeId>",
      "tableScanSchedulingOrder");
  to_json_key(
      j,
      "partitioningScheme",
      p.partitioningScheme,
      "PlanFragment",
      "PartitioningScheme",
      "partitioningScheme");
  to_json_key(
      j,
      "stageExecutionDescriptor",
      p.stageExecutionDescriptor,
      "PlanFragment",
      "StageExecutionDescriptor",
      "stageExecutionDescriptor");
  to_json_key(
      j,
      "outputOrderingScheme",
      p.outputOrderingScheme,
      "PlanFragment",
      "OrderingScheme",
      "outputOrderingScheme");
  to_json_key(
      j,
      "outputTableWriterFragment",
      p.outputTableWriterFragment,
      "PlanFragment",
      "bool",
      "outputTableWriterFragment");
  to_json_key(
      j,
      "jsonRepresentation",
      p.jsonRepresentation,
      "PlanFragment",
      "String",
      "jsonRepresentation");
}

void from_json(const json& j, PlanFragment& p) {
  from_json_key(j, "id", p.id, "PlanFragment", "PlanFragmentId", "id");
  from_json_key(j, "root", p.root, "PlanFragment", "PlanNode", "root");
  from_json_key(
      j,
      "variables",
      p.variables,
      "PlanFragment",
      "List<VariableReferenceExpression>",
      "variables");
  from_json_key(
      j,
      "partitioning",
      p.partitioning,
      "PlanFragment",
      "PartitioningHandle",
      "partitioning");
  from_json_key(
      j,
      "tableScanSchedulingOrder",
      p.tableScanSchedulingOrder,
      "PlanFragment",
      "List<PlanNodeId>",
      "tableScanSchedulingOrder");
  from_json_key(
      j,
      "partitioningScheme",
      p.partitioningScheme,
      "PlanFragment",
      "PartitioningScheme",
      "partitioningScheme");
  from_json_key(
      j,
      "stageExecutionDescriptor",
      p.stageExecutionDescriptor,
      "PlanFragment",
      "StageExecutionDescriptor",
      "stageExecutionDescriptor");
  from_json_key(
      j,
      "outputOrderingScheme",
      p.outputOrderingScheme,
      "PlanFragment",
      "OrderingScheme",
      "outputOrderingScheme");
  from_json_key(
      j,
      "outputTableWriterFragment",
      p.outputTableWriterFragment,
      "PlanFragment",
      "bool",
      "outputTableWriterFragment");
  from_json_key(
      j,
      "jsonRepresentation",
      p.jsonRepresentation,
      "PlanFragment",
      "String",
      "jsonRepresentation");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<Locality, json> Locality_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {Locality::UNKNOWN, "UNKNOWN"},
        {Locality::LOCAL, "LOCAL"},
        {Locality::REMOTE, "REMOTE"}};
void to_json(json& j, const Locality& e) {
  static_assert(std::is_enum<Locality>::value, "Locality must be an enum!");
  const auto* it = std::find_if(
      std::begin(Locality_enum_table),
      std::end(Locality_enum_table),
      [e](const std::pair<Locality, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(Locality_enum_table)) ? it
                                             : std::begin(Locality_enum_table))
          ->second;
}
void from_json(const json& j, Locality& e) {
  static_assert(std::is_enum<Locality>::value, "Locality must be an enum!");
  const auto* it = std::find_if(
      std::begin(Locality_enum_table),
      std::end(Locality_enum_table),
      [&j](const std::pair<Locality, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(Locality_enum_table)) ? it
                                             : std::begin(Locality_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
ProjectNode::ProjectNode() noexcept {
  _type = ".ProjectNode";
}

void to_json(json& j, const ProjectNode& p) {
  j = json::object();
  j["@type"] = ".ProjectNode";
  to_json_key(j, "id", p.id, "ProjectNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "ProjectNode", "PlanNode", "source");
  to_json_key(
      j,
      "assignments",
      p.assignments,
      "ProjectNode",
      "Assignments",
      "assignments");
  to_json_key(j, "locality", p.locality, "ProjectNode", "Locality", "locality");
}

void from_json(const json& j, ProjectNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "ProjectNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "ProjectNode", "PlanNode", "source");
  from_json_key(
      j,
      "assignments",
      p.assignments,
      "ProjectNode",
      "Assignments",
      "assignments");
  from_json_key(
      j, "locality", p.locality, "ProjectNode", "Locality", "locality");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const Range& p) {
  j = json::object();
  to_json_key(j, "low", p.low, "Range", "Marker", "low");
  to_json_key(j, "high", p.high, "Range", "Marker", "high");
}

void from_json(const json& j, Range& p) {
  from_json_key(j, "low", p.low, "Range", "Marker", "low");
  from_json_key(j, "high", p.high, "Range", "Marker", "high");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const RefreshMaterializedViewHandle& p) {
  j = json::object();
  to_json_key(
      j,
      "handle",
      p.handle,
      "RefreshMaterializedViewHandle",
      "InsertTableHandle",
      "handle");
  to_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "RefreshMaterializedViewHandle",
      "SchemaTableName",
      "schemaTableName");
}

void from_json(const json& j, RefreshMaterializedViewHandle& p) {
  from_json_key(
      j,
      "handle",
      p.handle,
      "RefreshMaterializedViewHandle",
      "InsertTableHandle",
      "handle");
  from_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "RefreshMaterializedViewHandle",
      "SchemaTableName",
      "schemaTableName");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
RemoteSourceNode::RemoteSourceNode() noexcept {
  _type = "com.facebook.presto.sql.planner.plan.RemoteSourceNode";
}

void to_json(json& j, const RemoteSourceNode& p) {
  j = json::object();
  j["@type"] = "com.facebook.presto.sql.planner.plan.RemoteSourceNode";
  to_json_key(j, "id", p.id, "RemoteSourceNode", "PlanNodeId", "id");
  to_json_key(
      j,
      "sourceFragmentIds",
      p.sourceFragmentIds,
      "RemoteSourceNode",
      "List<PlanFragmentId>",
      "sourceFragmentIds");
  to_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "RemoteSourceNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  to_json_key(
      j,
      "ensureSourceOrdering",
      p.ensureSourceOrdering,
      "RemoteSourceNode",
      "bool",
      "ensureSourceOrdering");
  to_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "RemoteSourceNode",
      "OrderingScheme",
      "orderingScheme");
  to_json_key(
      j,
      "exchangeType",
      p.exchangeType,
      "RemoteSourceNode",
      "ExchangeNodeType",
      "exchangeType");
  to_json_key(
      j,
      "encoding",
      p.encoding,
      "RemoteSourceNode",
      "ExchangeEncoding",
      "encoding");
}

void from_json(const json& j, RemoteSourceNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "RemoteSourceNode", "PlanNodeId", "id");
  from_json_key(
      j,
      "sourceFragmentIds",
      p.sourceFragmentIds,
      "RemoteSourceNode",
      "List<PlanFragmentId>",
      "sourceFragmentIds");
  from_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "RemoteSourceNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  from_json_key(
      j,
      "ensureSourceOrdering",
      p.ensureSourceOrdering,
      "RemoteSourceNode",
      "bool",
      "ensureSourceOrdering");
  from_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "RemoteSourceNode",
      "OrderingScheme",
      "orderingScheme");
  from_json_key(
      j,
      "exchangeType",
      p.exchangeType,
      "RemoteSourceNode",
      "ExchangeNodeType",
      "exchangeType");
  from_json_key(
      j,
      "encoding",
      p.encoding,
      "RemoteSourceNode",
      "ExchangeEncoding",
      "encoding");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
RemoteSplit::RemoteSplit() noexcept {
  _type = "$remote";
}

void to_json(json& j, const RemoteSplit& p) {
  j = json::object();
  j["@type"] = "$remote";
  to_json_key(j, "location", p.location, "RemoteSplit", "Location", "location");
  to_json_key(
      j,
      "remoteSourceTaskId",
      p.remoteSourceTaskId,
      "RemoteSplit",
      "TaskId",
      "remoteSourceTaskId");
}

void from_json(const json& j, RemoteSplit& p) {
  p._type = j["@type"];
  from_json_key(
      j, "location", p.location, "RemoteSplit", "Location", "location");
  from_json_key(
      j,
      "remoteSourceTaskId",
      p.remoteSourceTaskId,
      "RemoteSplit",
      "TaskId",
      "remoteSourceTaskId");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
RemoteTransactionHandle::RemoteTransactionHandle() noexcept {
  _type = "$remote";
}

void to_json(json& j, const RemoteTransactionHandle& p) {
  j = json::object();
  j["@type"] = "$remote";
  to_json_key(
      j, "dummy", p.dummy, "RemoteTransactionHandle", "String", "dummy");
}

void from_json(const json& j, RemoteTransactionHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j, "dummy", p.dummy, "RemoteTransactionHandle", "String", "dummy");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
RestFunctionHandle::RestFunctionHandle() noexcept {
  _type = "rest";
}

void to_json(json& j, const RestFunctionHandle& p) {
  j = json::object();
  j["@type"] = "rest";
  to_json_key(
      j,
      "functionId",
      p.functionId,
      "RestFunctionHandle",
      "SqlFunctionId",
      "functionId");
  to_json_key(
      j, "version", p.version, "RestFunctionHandle", "String", "version");
  to_json_key(
      j,
      "signature",
      p.signature,
      "RestFunctionHandle",
      "Signature",
      "signature");
  to_json_key(
      j,
      "executionEndpoint",
      p.executionEndpoint,
      "RestFunctionHandle",
      "URI",
      "executionEndpoint");
}

void from_json(const json& j, RestFunctionHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "functionId",
      p.functionId,
      "RestFunctionHandle",
      "SqlFunctionId",
      "functionId");
  from_json_key(
      j, "version", p.version, "RestFunctionHandle", "String", "version");
  from_json_key(
      j,
      "signature",
      p.signature,
      "RestFunctionHandle",
      "Signature",
      "signature");
  from_json_key(
      j,
      "executionEndpoint",
      p.executionEndpoint,
      "RestFunctionHandle",
      "URI",
      "executionEndpoint");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const RowExpressionOptimizationResult& p) {
  j = json::object();
  to_json_key(
      j,
      "optimizedExpression",
      p.optimizedExpression,
      "RowExpressionOptimizationResult",
      "RowExpression",
      "optimizedExpression");
  to_json_key(
      j,
      "expressionFailureInfo",
      p.expressionFailureInfo,
      "RowExpressionOptimizationResult",
      "NativeSidecarFailureInfo",
      "expressionFailureInfo");
}

void from_json(const json& j, RowExpressionOptimizationResult& p) {
  from_json_key(
      j,
      "optimizedExpression",
      p.optimizedExpression,
      "RowExpressionOptimizationResult",
      "RowExpression",
      "optimizedExpression");
  from_json_key(
      j,
      "expressionFailureInfo",
      p.expressionFailureInfo,
      "RowExpressionOptimizationResult",
      "NativeSidecarFailureInfo",
      "expressionFailureInfo");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
RowNumberNode::RowNumberNode() noexcept {
  _type = "com.facebook.presto.sql.planner.plan.RowNumberNode";
}

void to_json(json& j, const RowNumberNode& p) {
  j = json::object();
  j["@type"] = "com.facebook.presto.sql.planner.plan.RowNumberNode";
  to_json_key(j, "id", p.id, "RowNumberNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "RowNumberNode", "PlanNode", "source");
  to_json_key(
      j,
      "partitionBy",
      p.partitionBy,
      "RowNumberNode",
      "List<VariableReferenceExpression>",
      "partitionBy");
  to_json_key(
      j,
      "rowNumberVariable",
      p.rowNumberVariable,
      "RowNumberNode",
      "VariableReferenceExpression",
      "rowNumberVariable");
  to_json_key(
      j,
      "maxRowCountPerPartition",
      p.maxRowCountPerPartition,
      "RowNumberNode",
      "Integer",
      "maxRowCountPerPartition");
  to_json_key(j, "partial", p.partial, "RowNumberNode", "bool", "partial");
  to_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "RowNumberNode",
      "VariableReferenceExpression",
      "hashVariable");
}

void from_json(const json& j, RowNumberNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "RowNumberNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "RowNumberNode", "PlanNode", "source");
  from_json_key(
      j,
      "partitionBy",
      p.partitionBy,
      "RowNumberNode",
      "List<VariableReferenceExpression>",
      "partitionBy");
  from_json_key(
      j,
      "rowNumberVariable",
      p.rowNumberVariable,
      "RowNumberNode",
      "VariableReferenceExpression",
      "rowNumberVariable");
  from_json_key(
      j,
      "maxRowCountPerPartition",
      p.maxRowCountPerPartition,
      "RowNumberNode",
      "Integer",
      "maxRowCountPerPartition");
  from_json_key(j, "partial", p.partial, "RowNumberNode", "bool", "partial");
  from_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "RowNumberNode",
      "VariableReferenceExpression",
      "hashVariable");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const RowType& p) {
  j = json::object();
  to_json_key(
      j,
      "typeSignature",
      p.typeSignature,
      "RowType",
      "TypeSignature",
      "typeSignature");
}

void from_json(const json& j, RowType& p) {
  from_json_key(
      j,
      "typeSignature",
      p.typeSignature,
      "RowType",
      "TypeSignature",
      "typeSignature");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<RuntimeUnit, json> RuntimeUnit_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {RuntimeUnit::NONE, "NONE"},
        {RuntimeUnit::NANO, "NANO"},
        {RuntimeUnit::BYTE, "BYTE"}};
void to_json(json& j, const RuntimeUnit& e) {
  static_assert(
      std::is_enum<RuntimeUnit>::value, "RuntimeUnit must be an enum!");
  const auto* it = std::find_if(
      std::begin(RuntimeUnit_enum_table),
      std::end(RuntimeUnit_enum_table),
      [e](const std::pair<RuntimeUnit, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(RuntimeUnit_enum_table))
           ? it
           : std::begin(RuntimeUnit_enum_table))
          ->second;
}
void from_json(const json& j, RuntimeUnit& e) {
  static_assert(
      std::is_enum<RuntimeUnit>::value, "RuntimeUnit must be an enum!");
  const auto* it = std::find_if(
      std::begin(RuntimeUnit_enum_table),
      std::end(RuntimeUnit_enum_table),
      [&j](const std::pair<RuntimeUnit, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(RuntimeUnit_enum_table))
           ? it
           : std::begin(RuntimeUnit_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const RuntimeMetric& p) {
  j = json::object();
  to_json_key(j, "name", p.name, "RuntimeMetric", "String", "name");
  to_json_key(j, "unit", p.unit, "RuntimeMetric", "RuntimeUnit", "unit");
  to_json_key(j, "sum", p.sum, "RuntimeMetric", "int64_t", "sum");
  to_json_key(j, "count", p.count, "RuntimeMetric", "int64_t", "count");
  to_json_key(j, "max", p.max, "RuntimeMetric", "int64_t", "max");
  to_json_key(j, "min", p.min, "RuntimeMetric", "int64_t", "min");
}

void from_json(const json& j, RuntimeMetric& p) {
  from_json_key(j, "name", p.name, "RuntimeMetric", "String", "name");
  from_json_key(j, "unit", p.unit, "RuntimeMetric", "RuntimeUnit", "unit");
  from_json_key(j, "sum", p.sum, "RuntimeMetric", "int64_t", "sum");
  from_json_key(j, "count", p.count, "RuntimeMetric", "int64_t", "count");
  from_json_key(j, "max", p.max, "RuntimeMetric", "int64_t", "max");
  from_json_key(j, "min", p.min, "RuntimeMetric", "int64_t", "min");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<SampleNodeType, json> SampleNodeType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {SampleNodeType::BERNOULLI, "BERNOULLI"},
        {SampleNodeType::SYSTEM, "SYSTEM"}};
void to_json(json& j, const SampleNodeType& e) {
  static_assert(
      std::is_enum<SampleNodeType>::value, "SampleNodeType must be an enum!");
  const auto* it = std::find_if(
      std::begin(SampleNodeType_enum_table),
      std::end(SampleNodeType_enum_table),
      [e](const std::pair<SampleNodeType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(SampleNodeType_enum_table))
           ? it
           : std::begin(SampleNodeType_enum_table))
          ->second;
}
void from_json(const json& j, SampleNodeType& e) {
  static_assert(
      std::is_enum<SampleNodeType>::value, "SampleNodeType must be an enum!");
  const auto* it = std::find_if(
      std::begin(SampleNodeType_enum_table),
      std::end(SampleNodeType_enum_table),
      [&j](const std::pair<SampleNodeType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(SampleNodeType_enum_table))
           ? it
           : std::begin(SampleNodeType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SampleNode::SampleNode() noexcept {
  _type = "com.facebook.presto.sql.planner.plan.SampleNode";
}

void to_json(json& j, const SampleNode& p) {
  j = json::object();
  j["@type"] = "com.facebook.presto.sql.planner.plan.SampleNode";
  to_json_key(j, "id", p.id, "SampleNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "SampleNode", "PlanNode", "source");
  to_json_key(
      j, "sampleRatio", p.sampleRatio, "SampleNode", "double", "sampleRatio");
  to_json_key(
      j,
      "sampleType",
      p.sampleType,
      "SampleNode",
      "SampleNodeType",
      "sampleType");
}

void from_json(const json& j, SampleNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "SampleNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "SampleNode", "PlanNode", "source");
  from_json_key(
      j, "sampleRatio", p.sampleRatio, "SampleNode", "double", "sampleRatio");
  from_json_key(
      j,
      "sampleType",
      p.sampleType,
      "SampleNode",
      "SampleNodeType",
      "sampleType");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
ScalarArgument::ScalarArgument() noexcept {
  _type = "scalar";
}

void to_json(json& j, const ScalarArgument& p) {
  j = json::object();
  j["@type"] = "scalar";
  to_json_key(
      j,
      "nullableValue",
      p.nullableValue,
      "ScalarArgument",
      "NullableValue",
      "nullableValue");
}

void from_json(const json& j, ScalarArgument& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "nullableValue",
      p.nullableValue,
      "ScalarArgument",
      "NullableValue",
      "nullableValue");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
ScalarArgumentSpecification::ScalarArgumentSpecification() noexcept {
  _type = "scalar";
}

void to_json(json& j, const ScalarArgumentSpecification& p) {
  j = json::object();
  j["@type"] = "scalar";
  to_json_key(
      j, "name", p.name, "ScalarArgumentSpecification", "String", "name");
  to_json_key(j, "type", p.type, "ScalarArgumentSpecification", "Type", "type");
  to_json_key(
      j,
      "required",
      p.required,
      "ScalarArgumentSpecification",
      "bool",
      "required");
}

void from_json(const json& j, ScalarArgumentSpecification& p) {
  p._type = j["@type"];
  from_json_key(
      j, "name", p.name, "ScalarArgumentSpecification", "String", "name");
  from_json_key(
      j, "type", p.type, "ScalarArgumentSpecification", "Type", "type");
  from_json_key(
      j,
      "required",
      p.required,
      "ScalarArgumentSpecification",
      "bool",
      "required");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<DistributionType, json> DistributionType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {DistributionType::PARTITIONED, "PARTITIONED"},
        {DistributionType::REPLICATED, "REPLICATED"}};
void to_json(json& j, const DistributionType& e) {
  static_assert(
      std::is_enum<DistributionType>::value,
      "DistributionType must be an enum!");
  const auto* it = std::find_if(
      std::begin(DistributionType_enum_table),
      std::end(DistributionType_enum_table),
      [e](const std::pair<DistributionType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(DistributionType_enum_table))
           ? it
           : std::begin(DistributionType_enum_table))
          ->second;
}
void from_json(const json& j, DistributionType& e) {
  static_assert(
      std::is_enum<DistributionType>::value,
      "DistributionType must be an enum!");
  const auto* it = std::find_if(
      std::begin(DistributionType_enum_table),
      std::end(DistributionType_enum_table),
      [&j](const std::pair<DistributionType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(DistributionType_enum_table))
           ? it
           : std::begin(DistributionType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SemiJoinNode::SemiJoinNode() noexcept {
  _type = ".SemiJoinNode";
}

void to_json(json& j, const SemiJoinNode& p) {
  j = json::object();
  j["@type"] = ".SemiJoinNode";
  to_json_key(j, "id", p.id, "SemiJoinNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "SemiJoinNode", "PlanNode", "source");
  to_json_key(
      j,
      "filteringSource",
      p.filteringSource,
      "SemiJoinNode",
      "PlanNode",
      "filteringSource");
  to_json_key(
      j,
      "sourceJoinVariable",
      p.sourceJoinVariable,
      "SemiJoinNode",
      "VariableReferenceExpression",
      "sourceJoinVariable");
  to_json_key(
      j,
      "filteringSourceJoinVariable",
      p.filteringSourceJoinVariable,
      "SemiJoinNode",
      "VariableReferenceExpression",
      "filteringSourceJoinVariable");
  to_json_key(
      j,
      "semiJoinOutput",
      p.semiJoinOutput,
      "SemiJoinNode",
      "VariableReferenceExpression",
      "semiJoinOutput");
  to_json_key(
      j,
      "sourceHashVariable",
      p.sourceHashVariable,
      "SemiJoinNode",
      "VariableReferenceExpression",
      "sourceHashVariable");
  to_json_key(
      j,
      "filteringSourceHashVariable",
      p.filteringSourceHashVariable,
      "SemiJoinNode",
      "VariableReferenceExpression",
      "filteringSourceHashVariable");
  to_json_key(
      j,
      "distributionType",
      p.distributionType,
      "SemiJoinNode",
      "DistributionType",
      "distributionType");
  to_json_key(
      j,
      "dynamicFilters",
      p.dynamicFilters,
      "SemiJoinNode",
      "Map<String, VariableReferenceExpression>",
      "dynamicFilters");
}

void from_json(const json& j, SemiJoinNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "SemiJoinNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "SemiJoinNode", "PlanNode", "source");
  from_json_key(
      j,
      "filteringSource",
      p.filteringSource,
      "SemiJoinNode",
      "PlanNode",
      "filteringSource");
  from_json_key(
      j,
      "sourceJoinVariable",
      p.sourceJoinVariable,
      "SemiJoinNode",
      "VariableReferenceExpression",
      "sourceJoinVariable");
  from_json_key(
      j,
      "filteringSourceJoinVariable",
      p.filteringSourceJoinVariable,
      "SemiJoinNode",
      "VariableReferenceExpression",
      "filteringSourceJoinVariable");
  from_json_key(
      j,
      "semiJoinOutput",
      p.semiJoinOutput,
      "SemiJoinNode",
      "VariableReferenceExpression",
      "semiJoinOutput");
  from_json_key(
      j,
      "sourceHashVariable",
      p.sourceHashVariable,
      "SemiJoinNode",
      "VariableReferenceExpression",
      "sourceHashVariable");
  from_json_key(
      j,
      "filteringSourceHashVariable",
      p.filteringSourceHashVariable,
      "SemiJoinNode",
      "VariableReferenceExpression",
      "filteringSourceHashVariable");
  from_json_key(
      j,
      "distributionType",
      p.distributionType,
      "SemiJoinNode",
      "DistributionType",
      "distributionType");
  from_json_key(
      j,
      "dynamicFilters",
      p.dynamicFilters,
      "SemiJoinNode",
      "Map<String, VariableReferenceExpression>",
      "dynamicFilters");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const ServerInfo& p) {
  j = json::object();
  to_json_key(
      j,
      "nodeVersion",
      p.nodeVersion,
      "ServerInfo",
      "NodeVersion",
      "nodeVersion");
  to_json_key(
      j, "environment", p.environment, "ServerInfo", "String", "environment");
  to_json_key(
      j, "coordinator", p.coordinator, "ServerInfo", "bool", "coordinator");
  to_json_key(j, "starting", p.starting, "ServerInfo", "bool", "starting");
  to_json_key(j, "uptime", p.uptime, "ServerInfo", "Duration", "uptime");
}

void from_json(const json& j, ServerInfo& p) {
  from_json_key(
      j,
      "nodeVersion",
      p.nodeVersion,
      "ServerInfo",
      "NodeVersion",
      "nodeVersion");
  from_json_key(
      j, "environment", p.environment, "ServerInfo", "String", "environment");
  from_json_key(
      j, "coordinator", p.coordinator, "ServerInfo", "bool", "coordinator");
  from_json_key(j, "starting", p.starting, "ServerInfo", "bool", "starting");
  from_json_key(j, "uptime", p.uptime, "ServerInfo", "Duration", "uptime");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const SessionPropertyMetadata& p) {
  j = json::object();
  to_json_key(j, "name", p.name, "SessionPropertyMetadata", "String", "name");
  to_json_key(
      j,
      "description",
      p.description,
      "SessionPropertyMetadata",
      "String",
      "description");
  to_json_key(
      j,
      "typeSignature",
      p.typeSignature,
      "SessionPropertyMetadata",
      "TypeSignature",
      "typeSignature");
  to_json_key(
      j,
      "defaultValue",
      p.defaultValue,
      "SessionPropertyMetadata",
      "String",
      "defaultValue");
  to_json_key(
      j, "hidden", p.hidden, "SessionPropertyMetadata", "bool", "hidden");
}

void from_json(const json& j, SessionPropertyMetadata& p) {
  from_json_key(j, "name", p.name, "SessionPropertyMetadata", "String", "name");
  from_json_key(
      j,
      "description",
      p.description,
      "SessionPropertyMetadata",
      "String",
      "description");
  from_json_key(
      j,
      "typeSignature",
      p.typeSignature,
      "SessionPropertyMetadata",
      "TypeSignature",
      "typeSignature");
  from_json_key(
      j,
      "defaultValue",
      p.defaultValue,
      "SessionPropertyMetadata",
      "String",
      "defaultValue");
  from_json_key(
      j, "hidden", p.hidden, "SessionPropertyMetadata", "bool", "hidden");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SortNode::SortNode() noexcept {
  _type = ".SortNode";
}

void to_json(json& j, const SortNode& p) {
  j = json::object();
  j["@type"] = ".SortNode";
  to_json_key(j, "id", p.id, "SortNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "SortNode", "PlanNode", "source");
  to_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "SortNode",
      "OrderingScheme",
      "orderingScheme");
  to_json_key(j, "isPartial", p.isPartial, "SortNode", "bool", "isPartial");
  to_json_key(
      j,
      "partitionBy",
      p.partitionBy,
      "SortNode",
      "List<VariableReferenceExpression>",
      "partitionBy");
}

void from_json(const json& j, SortNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "SortNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "SortNode", "PlanNode", "source");
  from_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "SortNode",
      "OrderingScheme",
      "orderingScheme");
  from_json_key(j, "isPartial", p.isPartial, "SortNode", "bool", "isPartial");
  from_json_key(
      j,
      "partitionBy",
      p.partitionBy,
      "SortNode",
      "List<VariableReferenceExpression>",
      "partitionBy");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SortedRangeSet::SortedRangeSet() noexcept {
  _type = "sortable";
}

void to_json(json& j, const SortedRangeSet& p) {
  j = json::object();
  j["@type"] = "sortable";
  to_json_key(j, "type", p.type, "SortedRangeSet", "Type", "type");
  to_json_key(j, "ranges", p.ranges, "SortedRangeSet", "List<Range>", "ranges");
}

void from_json(const json& j, SortedRangeSet& p) {
  p._type = j["@type"];
  from_json_key(j, "type", p.type, "SortedRangeSet", "Type", "type");
  from_json_key(
      j, "ranges", p.ranges, "SortedRangeSet", "List<Range>", "ranges");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<SpatialJoinType, json> SpatialJoinType_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {SpatialJoinType::INNER, "INNER"},
        {SpatialJoinType::LEFT, "LEFT"}};
void to_json(json& j, const SpatialJoinType& e) {
  static_assert(
      std::is_enum<SpatialJoinType>::value, "SpatialJoinType must be an enum!");
  const auto* it = std::find_if(
      std::begin(SpatialJoinType_enum_table),
      std::end(SpatialJoinType_enum_table),
      [e](const std::pair<SpatialJoinType, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(SpatialJoinType_enum_table))
           ? it
           : std::begin(SpatialJoinType_enum_table))
          ->second;
}
void from_json(const json& j, SpatialJoinType& e) {
  static_assert(
      std::is_enum<SpatialJoinType>::value, "SpatialJoinType must be an enum!");
  const auto* it = std::find_if(
      std::begin(SpatialJoinType_enum_table),
      std::end(SpatialJoinType_enum_table),
      [&j](const std::pair<SpatialJoinType, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(SpatialJoinType_enum_table))
           ? it
           : std::begin(SpatialJoinType_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SpatialJoinNode::SpatialJoinNode() noexcept {
  _type = ".SpatialJoinNode";
}

void to_json(json& j, const SpatialJoinNode& p) {
  j = json::object();
  j["@type"] = ".SpatialJoinNode";
  to_json_key(j, "id", p.id, "SpatialJoinNode", "PlanNodeId", "id");
  to_json_key(j, "type", p.type, "SpatialJoinNode", "SpatialJoinType", "type");
  to_json_key(j, "left", p.left, "SpatialJoinNode", "PlanNode", "left");
  to_json_key(j, "right", p.right, "SpatialJoinNode", "PlanNode", "right");
  to_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "SpatialJoinNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  to_json_key(
      j,
      "probeGeometryVariable",
      p.probeGeometryVariable,
      "SpatialJoinNode",
      "VariableReferenceExpression",
      "probeGeometryVariable");
  to_json_key(
      j,
      "buildGeometryVariable",
      p.buildGeometryVariable,
      "SpatialJoinNode",
      "VariableReferenceExpression",
      "buildGeometryVariable");
  to_json_key(
      j,
      "radiusVariable",
      p.radiusVariable,
      "SpatialJoinNode",
      "VariableReferenceExpression",
      "radiusVariable");
  to_json_key(
      j, "filter", p.filter, "SpatialJoinNode", "RowExpression", "filter");
  to_json_key(
      j,
      "leftPartitionVariable",
      p.leftPartitionVariable,
      "SpatialJoinNode",
      "VariableReferenceExpression",
      "leftPartitionVariable");
  to_json_key(
      j,
      "rightPartitionVariable",
      p.rightPartitionVariable,
      "SpatialJoinNode",
      "VariableReferenceExpression",
      "rightPartitionVariable");
  to_json_key(j, "kdbTree", p.kdbTree, "SpatialJoinNode", "String", "kdbTree");
}

void from_json(const json& j, SpatialJoinNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "SpatialJoinNode", "PlanNodeId", "id");
  from_json_key(
      j, "type", p.type, "SpatialJoinNode", "SpatialJoinType", "type");
  from_json_key(j, "left", p.left, "SpatialJoinNode", "PlanNode", "left");
  from_json_key(j, "right", p.right, "SpatialJoinNode", "PlanNode", "right");
  from_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "SpatialJoinNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  from_json_key(
      j,
      "probeGeometryVariable",
      p.probeGeometryVariable,
      "SpatialJoinNode",
      "VariableReferenceExpression",
      "probeGeometryVariable");
  from_json_key(
      j,
      "buildGeometryVariable",
      p.buildGeometryVariable,
      "SpatialJoinNode",
      "VariableReferenceExpression",
      "buildGeometryVariable");
  from_json_key(
      j,
      "radiusVariable",
      p.radiusVariable,
      "SpatialJoinNode",
      "VariableReferenceExpression",
      "radiusVariable");
  from_json_key(
      j, "filter", p.filter, "SpatialJoinNode", "RowExpression", "filter");
  from_json_key(
      j,
      "leftPartitionVariable",
      p.leftPartitionVariable,
      "SpatialJoinNode",
      "VariableReferenceExpression",
      "leftPartitionVariable");
  from_json_key(
      j,
      "rightPartitionVariable",
      p.rightPartitionVariable,
      "SpatialJoinNode",
      "VariableReferenceExpression",
      "rightPartitionVariable");
  from_json_key(
      j, "kdbTree", p.kdbTree, "SpatialJoinNode", "String", "kdbTree");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<Form, json> Form_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {Form::IF, "IF"},
        {Form::NULL_IF, "NULL_IF"},
        {Form::SWITCH, "SWITCH"},
        {Form::WHEN, "WHEN"},
        {Form::IS_NULL, "IS_NULL"},
        {Form::COALESCE, "COALESCE"},
        {Form::IN, "IN"},
        {Form::AND, "AND"},
        {Form::OR, "OR"},
        {Form::DEREFERENCE, "DEREFERENCE"},
        {Form::ROW_CONSTRUCTOR, "ROW_CONSTRUCTOR"},
        {Form::BIND, "BIND"}};
void to_json(json& j, const Form& e) {
  static_assert(std::is_enum<Form>::value, "Form must be an enum!");
  const auto* it = std::find_if(
      std::begin(Form_enum_table),
      std::end(Form_enum_table),
      [e](const std::pair<Form, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(Form_enum_table)) ? it : std::begin(Form_enum_table))
          ->second;
}
void from_json(const json& j, Form& e) {
  static_assert(std::is_enum<Form>::value, "Form must be an enum!");
  const auto* it = std::find_if(
      std::begin(Form_enum_table),
      std::end(Form_enum_table),
      [&j](const std::pair<Form, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(Form_enum_table)) ? it : std::begin(Form_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SpecialFormExpression::SpecialFormExpression() noexcept {
  _type = "special";
}

void to_json(json& j, const SpecialFormExpression& p) {
  j = json::object();
  j["@type"] = "special";
  to_json_key(
      j,
      "sourceLocation",
      p.sourceLocation,
      "SpecialFormExpression",
      "SourceLocation",
      "sourceLocation");
  to_json_key(j, "form", p.form, "SpecialFormExpression", "Form", "form");
  to_json_key(
      j,
      "returnType",
      p.returnType,
      "SpecialFormExpression",
      "Type",
      "returnType");
  to_json_key(
      j,
      "arguments",
      p.arguments,
      "SpecialFormExpression",
      "List<std::shared_ptr<RowExpression>>",
      "arguments");
}

void from_json(const json& j, SpecialFormExpression& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "sourceLocation",
      p.sourceLocation,
      "SpecialFormExpression",
      "SourceLocation",
      "sourceLocation");
  from_json_key(j, "form", p.form, "SpecialFormExpression", "Form", "form");
  from_json_key(
      j,
      "returnType",
      p.returnType,
      "SpecialFormExpression",
      "Type",
      "returnType");
  from_json_key(
      j,
      "arguments",
      p.arguments,
      "SpecialFormExpression",
      "List<std::shared_ptr<RowExpression>>",
      "arguments");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SqlFunctionHandle::SqlFunctionHandle() noexcept {
  _type = "sql_function_handle";
}

void to_json(json& j, const SqlFunctionHandle& p) {
  j = json::object();
  j["@type"] = "sql_function_handle";
  to_json_key(
      j,
      "functionId",
      p.functionId,
      "SqlFunctionHandle",
      "SqlFunctionId",
      "functionId");
  to_json_key(
      j, "version", p.version, "SqlFunctionHandle", "String", "version");
}

void from_json(const json& j, SqlFunctionHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "functionId",
      p.functionId,
      "SqlFunctionHandle",
      "SqlFunctionId",
      "functionId");
  from_json_key(
      j, "version", p.version, "SqlFunctionHandle", "String", "version");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const StatisticAggregations& p) {
  j = json::object();
  to_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "StatisticAggregations",
      "List<VariableReferenceExpression>",
      "outputVariables");
  to_json_key(
      j,
      "aggregations",
      p.aggregations,
      "StatisticAggregations",
      "Map<VariableReferenceExpression, Aggregation>",
      "aggregations");
  to_json_key(
      j,
      "groupingVariables",
      p.groupingVariables,
      "StatisticAggregations",
      "List<VariableReferenceExpression>",
      "groupingVariables");
}

void from_json(const json& j, StatisticAggregations& p) {
  from_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "StatisticAggregations",
      "List<VariableReferenceExpression>",
      "outputVariables");
  from_json_key(
      j,
      "aggregations",
      p.aggregations,
      "StatisticAggregations",
      "Map<VariableReferenceExpression, Aggregation>",
      "aggregations");
  from_json_key(
      j,
      "groupingVariables",
      p.groupingVariables,
      "StatisticAggregations",
      "List<VariableReferenceExpression>",
      "groupingVariables");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SystemColumnHandle::SystemColumnHandle() noexcept {
  _type = "$system@system";
}

void to_json(json& j, const SystemColumnHandle& p) {
  j = json::object();
  j["@type"] = "$system@system";
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "SystemColumnHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "columnName",
      p.columnName,
      "SystemColumnHandle",
      "String",
      "columnName");
}

void from_json(const json& j, SystemColumnHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "SystemColumnHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "columnName",
      p.columnName,
      "SystemColumnHandle",
      "String",
      "columnName");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<SystemPartitionFunction, json>
    SystemPartitionFunction_enum_table[] =
        { // NOLINT: cert-err58-cpp
            {SystemPartitionFunction::SINGLE, "SINGLE"},
            {SystemPartitionFunction::HASH, "HASH"},
            {SystemPartitionFunction::ROUND_ROBIN, "ROUND_ROBIN"},
            {SystemPartitionFunction::BROADCAST, "BROADCAST"},
            {SystemPartitionFunction::UNKNOWN, "UNKNOWN"}};
void to_json(json& j, const SystemPartitionFunction& e) {
  static_assert(
      std::is_enum<SystemPartitionFunction>::value,
      "SystemPartitionFunction must be an enum!");
  const auto* it = std::find_if(
      std::begin(SystemPartitionFunction_enum_table),
      std::end(SystemPartitionFunction_enum_table),
      [e](const std::pair<SystemPartitionFunction, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(SystemPartitionFunction_enum_table))
           ? it
           : std::begin(SystemPartitionFunction_enum_table))
          ->second;
}
void from_json(const json& j, SystemPartitionFunction& e) {
  static_assert(
      std::is_enum<SystemPartitionFunction>::value,
      "SystemPartitionFunction must be an enum!");
  const auto* it = std::find_if(
      std::begin(SystemPartitionFunction_enum_table),
      std::end(SystemPartitionFunction_enum_table),
      [&j](const std::pair<SystemPartitionFunction, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(SystemPartitionFunction_enum_table))
           ? it
           : std::begin(SystemPartitionFunction_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<SystemPartitioning, json>
    SystemPartitioning_enum_table[] =
        { // NOLINT: cert-err58-cpp
            {SystemPartitioning::SINGLE, "SINGLE"},
            {SystemPartitioning::FIXED, "FIXED"},
            {SystemPartitioning::SOURCE, "SOURCE"},
            {SystemPartitioning::SCALED, "SCALED"},
            {SystemPartitioning::COORDINATOR_ONLY, "COORDINATOR_ONLY"},
            {SystemPartitioning::ARBITRARY, "ARBITRARY"}};
void to_json(json& j, const SystemPartitioning& e) {
  static_assert(
      std::is_enum<SystemPartitioning>::value,
      "SystemPartitioning must be an enum!");
  const auto* it = std::find_if(
      std::begin(SystemPartitioning_enum_table),
      std::end(SystemPartitioning_enum_table),
      [e](const std::pair<SystemPartitioning, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(SystemPartitioning_enum_table))
           ? it
           : std::begin(SystemPartitioning_enum_table))
          ->second;
}
void from_json(const json& j, SystemPartitioning& e) {
  static_assert(
      std::is_enum<SystemPartitioning>::value,
      "SystemPartitioning must be an enum!");
  const auto* it = std::find_if(
      std::begin(SystemPartitioning_enum_table),
      std::end(SystemPartitioning_enum_table),
      [&j](const std::pair<SystemPartitioning, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(SystemPartitioning_enum_table))
           ? it
           : std::begin(SystemPartitioning_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SystemPartitioningHandle::SystemPartitioningHandle() noexcept {
  _type = "$remote";
}

void to_json(json& j, const SystemPartitioningHandle& p) {
  j = json::object();
  j["@type"] = "$remote";
  to_json_key(
      j,
      "partitioning",
      p.partitioning,
      "SystemPartitioningHandle",
      "SystemPartitioning",
      "partitioning");
  to_json_key(
      j,
      "function",
      p.function,
      "SystemPartitioningHandle",
      "SystemPartitionFunction",
      "function");
}

void from_json(const json& j, SystemPartitioningHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "partitioning",
      p.partitioning,
      "SystemPartitioningHandle",
      "SystemPartitioning",
      "partitioning");
  from_json_key(
      j,
      "function",
      p.function,
      "SystemPartitioningHandle",
      "SystemPartitionFunction",
      "function");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SystemTableHandle::SystemTableHandle() noexcept {
  _type = "$system@system";
}

void to_json(json& j, const SystemTableHandle& p) {
  j = json::object();
  j["@type"] = "$system@system";
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "SystemTableHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "schemaName",
      p.schemaName,
      "SystemTableHandle",
      "String",
      "schemaName");
  to_json_key(
      j, "tableName", p.tableName, "SystemTableHandle", "String", "tableName");
}

void from_json(const json& j, SystemTableHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "SystemTableHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "schemaName",
      p.schemaName,
      "SystemTableHandle",
      "String",
      "schemaName");
  from_json_key(
      j, "tableName", p.tableName, "SystemTableHandle", "String", "tableName");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SystemSplit::SystemSplit() noexcept {
  _type = "$system@system";
}

void to_json(json& j, const SystemSplit& p) {
  j = json::object();
  j["@type"] = "$system@system";
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "SystemSplit",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "tableHandle",
      p.tableHandle,
      "SystemSplit",
      "SystemTableHandle",
      "tableHandle");
  to_json_key(
      j,
      "addresses",
      p.addresses,
      "SystemSplit",
      "List<HostAddress>",
      "addresses");
  to_json_key(
      j,
      "constraint",
      p.constraint,
      "SystemSplit",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "constraint");
}

void from_json(const json& j, SystemSplit& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "SystemSplit",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "tableHandle",
      p.tableHandle,
      "SystemSplit",
      "SystemTableHandle",
      "tableHandle");
  from_json_key(
      j,
      "addresses",
      p.addresses,
      "SystemSplit",
      "List<HostAddress>",
      "addresses");
  from_json_key(
      j,
      "constraint",
      p.constraint,
      "SystemSplit",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "constraint");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SystemTableLayoutHandle::SystemTableLayoutHandle() noexcept {
  _type = "$system@system";
}

void to_json(json& j, const SystemTableLayoutHandle& p) {
  j = json::object();
  j["@type"] = "$system@system";
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "SystemTableLayoutHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "table",
      p.table,
      "SystemTableLayoutHandle",
      "SystemTableHandle",
      "table");
  to_json_key(
      j,
      "constraint",
      p.constraint,
      "SystemTableLayoutHandle",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "constraint");
}

void from_json(const json& j, SystemTableLayoutHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "SystemTableLayoutHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "table",
      p.table,
      "SystemTableLayoutHandle",
      "SystemTableHandle",
      "table");
  from_json_key(
      j,
      "constraint",
      p.constraint,
      "SystemTableLayoutHandle",
      "TupleDomain<std::shared_ptr<ColumnHandle>>",
      "constraint");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
SystemTransactionHandle::SystemTransactionHandle() noexcept {
  _type = "$system@system";
}

void to_json(json& j, const SystemTransactionHandle& p) {
  j = json::object();
  j["@type"] = "$system@system";
  to_json_key(
      j,
      "connectorId",
      p.connectorId,
      "SystemTransactionHandle",
      "ConnectorId",
      "connectorId");
  to_json_key(
      j,
      "transactionId",
      p.transactionId,
      "SystemTransactionHandle",
      "TransactionId",
      "transactionId");
  to_json_key(
      j,
      "connectorTransactionHandle",
      p.connectorTransactionHandle,
      "SystemTransactionHandle",
      "ConnectorTransactionHandle",
      "connectorTransactionHandle");
}

void from_json(const json& j, SystemTransactionHandle& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "connectorId",
      p.connectorId,
      "SystemTransactionHandle",
      "ConnectorId",
      "connectorId");
  from_json_key(
      j,
      "transactionId",
      p.transactionId,
      "SystemTransactionHandle",
      "TransactionId",
      "transactionId");
  from_json_key(
      j,
      "connectorTransactionHandle",
      p.connectorTransactionHandle,
      "SystemTransactionHandle",
      "ConnectorTransactionHandle",
      "connectorTransactionHandle");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
TableArgument::TableArgument() noexcept {
  _type = "table";
}

void to_json(json& j, const TableArgument& p) {
  j = json::object();
  j["@type"] = "table";
  to_json_key(j, "rowType", p.rowType, "TableArgument", "RowType", "rowType");
  to_json_key(
      j,
      "partitionBy",
      p.partitionBy,
      "TableArgument",
      "List<String>",
      "partitionBy");
  to_json_key(
      j, "orderBy", p.orderBy, "TableArgument", "List<String>", "orderBy");
  to_json_key(j, "fields", p.fields, "TableArgument", "List<Field>", "fields");
}

void from_json(const json& j, TableArgument& p) {
  p._type = j["@type"];
  from_json_key(j, "rowType", p.rowType, "TableArgument", "RowType", "rowType");
  from_json_key(
      j,
      "partitionBy",
      p.partitionBy,
      "TableArgument",
      "List<String>",
      "partitionBy");
  from_json_key(
      j, "orderBy", p.orderBy, "TableArgument", "List<String>", "orderBy");
  from_json_key(
      j, "fields", p.fields, "TableArgument", "List<Field>", "fields");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
TableArgumentSpecification::TableArgumentSpecification() noexcept {
  _type = "table";
}

void to_json(json& j, const TableArgumentSpecification& p) {
  j = json::object();
  j["@type"] = "table";
  to_json_key(
      j, "name", p.name, "TableArgumentSpecification", "String", "name");
  to_json_key(
      j,
      "rowSemantics",
      p.rowSemantics,
      "TableArgumentSpecification",
      "bool",
      "rowSemantics");
  to_json_key(
      j,
      "pruneWhenEmpty",
      p.pruneWhenEmpty,
      "TableArgumentSpecification",
      "bool",
      "pruneWhenEmpty");
  to_json_key(
      j,
      "passThroughColumns",
      p.passThroughColumns,
      "TableArgumentSpecification",
      "bool",
      "passThroughColumns");
}

void from_json(const json& j, TableArgumentSpecification& p) {
  p._type = j["@type"];
  from_json_key(
      j, "name", p.name, "TableArgumentSpecification", "String", "name");
  from_json_key(
      j,
      "rowSemantics",
      p.rowSemantics,
      "TableArgumentSpecification",
      "bool",
      "rowSemantics");
  from_json_key(
      j,
      "pruneWhenEmpty",
      p.pruneWhenEmpty,
      "TableArgumentSpecification",
      "bool",
      "pruneWhenEmpty");
  from_json_key(
      j,
      "passThroughColumns",
      p.passThroughColumns,
      "TableArgumentSpecification",
      "bool",
      "passThroughColumns");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
TableScanNode::TableScanNode() noexcept {
  _type = ".TableScanNode";
}

void to_json(json& j, const TableScanNode& p) {
  j = json::object();
  j["@type"] = ".TableScanNode";
  to_json_key(j, "id", p.id, "TableScanNode", "PlanNodeId", "id");
  to_json_key(j, "table", p.table, "TableScanNode", "TableHandle", "table");
  to_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "TableScanNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  to_json_key(
      j,
      "assignments",
      p.assignments,
      "TableScanNode",
      "Map<VariableReferenceExpression, std::shared_ptr<ColumnHandle>>",
      "assignments");
}

void from_json(const json& j, TableScanNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "TableScanNode", "PlanNodeId", "id");
  from_json_key(j, "table", p.table, "TableScanNode", "TableHandle", "table");
  from_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "TableScanNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  from_json_key(
      j,
      "assignments",
      p.assignments,
      "TableScanNode",
      "Map<VariableReferenceExpression, std::shared_ptr<ColumnHandle>>",
      "assignments");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
TableWriterMergeNode::TableWriterMergeNode() noexcept {
  _type = "com.facebook.presto.sql.planner.plan.TableWriterMergeNode";
}

void to_json(json& j, const TableWriterMergeNode& p) {
  j = json::object();
  j["@type"] = "com.facebook.presto.sql.planner.plan.TableWriterMergeNode";
  to_json_key(j, "id", p.id, "TableWriterMergeNode", "PlanNodeId", "id");
  to_json_key(
      j, "source", p.source, "TableWriterMergeNode", "PlanNode", "source");
  to_json_key(
      j,
      "rowCountVariable",
      p.rowCountVariable,
      "TableWriterMergeNode",
      "VariableReferenceExpression",
      "rowCountVariable");
  to_json_key(
      j,
      "fragmentVariable",
      p.fragmentVariable,
      "TableWriterMergeNode",
      "VariableReferenceExpression",
      "fragmentVariable");
  to_json_key(
      j,
      "tableCommitContextVariable",
      p.tableCommitContextVariable,
      "TableWriterMergeNode",
      "VariableReferenceExpression",
      "tableCommitContextVariable");
  to_json_key(
      j,
      "statisticsAggregation",
      p.statisticsAggregation,
      "TableWriterMergeNode",
      "StatisticAggregations",
      "statisticsAggregation");
}

void from_json(const json& j, TableWriterMergeNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "TableWriterMergeNode", "PlanNodeId", "id");
  from_json_key(
      j, "source", p.source, "TableWriterMergeNode", "PlanNode", "source");
  from_json_key(
      j,
      "rowCountVariable",
      p.rowCountVariable,
      "TableWriterMergeNode",
      "VariableReferenceExpression",
      "rowCountVariable");
  from_json_key(
      j,
      "fragmentVariable",
      p.fragmentVariable,
      "TableWriterMergeNode",
      "VariableReferenceExpression",
      "fragmentVariable");
  from_json_key(
      j,
      "tableCommitContextVariable",
      p.tableCommitContextVariable,
      "TableWriterMergeNode",
      "VariableReferenceExpression",
      "tableCommitContextVariable");
  from_json_key(
      j,
      "statisticsAggregation",
      p.statisticsAggregation,
      "TableWriterMergeNode",
      "StatisticAggregations",
      "statisticsAggregation");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
TableWriterNode::TableWriterNode() noexcept {
  _type = "com.facebook.presto.sql.planner.plan.TableWriterNode";
}

void to_json(json& j, const TableWriterNode& p) {
  j = json::object();
  j["@type"] = "com.facebook.presto.sql.planner.plan.TableWriterNode";
  to_json_key(j, "id", p.id, "TableWriterNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "TableWriterNode", "PlanNode", "source");
  to_json_key(
      j,
      "rowCountVariable",
      p.rowCountVariable,
      "TableWriterNode",
      "VariableReferenceExpression",
      "rowCountVariable");
  to_json_key(
      j,
      "fragmentVariable",
      p.fragmentVariable,
      "TableWriterNode",
      "VariableReferenceExpression",
      "fragmentVariable");
  to_json_key(
      j,
      "tableCommitContextVariable",
      p.tableCommitContextVariable,
      "TableWriterNode",
      "VariableReferenceExpression",
      "tableCommitContextVariable");
  to_json_key(
      j,
      "columns",
      p.columns,
      "TableWriterNode",
      "List<VariableReferenceExpression>",
      "columns");
  to_json_key(
      j,
      "columnNames",
      p.columnNames,
      "TableWriterNode",
      "List<String>",
      "columnNames");
  to_json_key(
      j,
      "notNullColumnVariables",
      p.notNullColumnVariables,
      "TableWriterNode",
      "List<VariableReferenceExpression>",
      "notNullColumnVariables");
  to_json_key(
      j,
      "partitioningScheme",
      p.partitioningScheme,
      "TableWriterNode",
      "PartitioningScheme",
      "partitioningScheme");
  to_json_key(
      j,
      "preferredShufflePartitioningScheme",
      p.preferredShufflePartitioningScheme,
      "TableWriterNode",
      "PartitioningScheme",
      "preferredShufflePartitioningScheme");
  to_json_key(
      j,
      "statisticsAggregation",
      p.statisticsAggregation,
      "TableWriterNode",
      "StatisticAggregations",
      "statisticsAggregation");
}

void from_json(const json& j, TableWriterNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "TableWriterNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "TableWriterNode", "PlanNode", "source");
  from_json_key(
      j,
      "rowCountVariable",
      p.rowCountVariable,
      "TableWriterNode",
      "VariableReferenceExpression",
      "rowCountVariable");
  from_json_key(
      j,
      "fragmentVariable",
      p.fragmentVariable,
      "TableWriterNode",
      "VariableReferenceExpression",
      "fragmentVariable");
  from_json_key(
      j,
      "tableCommitContextVariable",
      p.tableCommitContextVariable,
      "TableWriterNode",
      "VariableReferenceExpression",
      "tableCommitContextVariable");
  from_json_key(
      j,
      "columns",
      p.columns,
      "TableWriterNode",
      "List<VariableReferenceExpression>",
      "columns");
  from_json_key(
      j,
      "columnNames",
      p.columnNames,
      "TableWriterNode",
      "List<String>",
      "columnNames");
  from_json_key(
      j,
      "notNullColumnVariables",
      p.notNullColumnVariables,
      "TableWriterNode",
      "List<VariableReferenceExpression>",
      "notNullColumnVariables");
  from_json_key(
      j,
      "partitioningScheme",
      p.partitioningScheme,
      "TableWriterNode",
      "PartitioningScheme",
      "partitioningScheme");
  from_json_key(
      j,
      "preferredShufflePartitioningScheme",
      p.preferredShufflePartitioningScheme,
      "TableWriterNode",
      "PartitioningScheme",
      "preferredShufflePartitioningScheme");
  from_json_key(
      j,
      "statisticsAggregation",
      p.statisticsAggregation,
      "TableWriterNode",
      "StatisticAggregations",
      "statisticsAggregation");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const TaskStats& p) {
  j = json::object();
  to_json_key(
      j,
      "createTimeInMillis",
      p.createTimeInMillis,
      "TaskStats",
      "int64_t",
      "createTimeInMillis");
  to_json_key(
      j,
      "firstStartTimeInMillis",
      p.firstStartTimeInMillis,
      "TaskStats",
      "int64_t",
      "firstStartTimeInMillis");
  to_json_key(
      j,
      "lastStartTimeInMillis",
      p.lastStartTimeInMillis,
      "TaskStats",
      "int64_t",
      "lastStartTimeInMillis");
  to_json_key(
      j,
      "lastEndTimeInMillis",
      p.lastEndTimeInMillis,
      "TaskStats",
      "int64_t",
      "lastEndTimeInMillis");
  to_json_key(
      j,
      "endTimeInMillis",
      p.endTimeInMillis,
      "TaskStats",
      "int64_t",
      "endTimeInMillis");
  to_json_key(
      j,
      "elapsedTimeInNanos",
      p.elapsedTimeInNanos,
      "TaskStats",
      "int64_t",
      "elapsedTimeInNanos");
  to_json_key(
      j,
      "queuedTimeInNanos",
      p.queuedTimeInNanos,
      "TaskStats",
      "int64_t",
      "queuedTimeInNanos");
  to_json_key(
      j, "totalDrivers", p.totalDrivers, "TaskStats", "int", "totalDrivers");
  to_json_key(
      j, "queuedDrivers", p.queuedDrivers, "TaskStats", "int", "queuedDrivers");
  to_json_key(
      j,
      "queuedPartitionedDrivers",
      p.queuedPartitionedDrivers,
      "TaskStats",
      "int",
      "queuedPartitionedDrivers");
  to_json_key(
      j,
      "queuedPartitionedSplitsWeight",
      p.queuedPartitionedSplitsWeight,
      "TaskStats",
      "int64_t",
      "queuedPartitionedSplitsWeight");
  to_json_key(
      j,
      "runningDrivers",
      p.runningDrivers,
      "TaskStats",
      "int",
      "runningDrivers");
  to_json_key(
      j,
      "runningPartitionedDrivers",
      p.runningPartitionedDrivers,
      "TaskStats",
      "int",
      "runningPartitionedDrivers");
  to_json_key(
      j,
      "runningPartitionedSplitsWeight",
      p.runningPartitionedSplitsWeight,
      "TaskStats",
      "int64_t",
      "runningPartitionedSplitsWeight");
  to_json_key(
      j,
      "blockedDrivers",
      p.blockedDrivers,
      "TaskStats",
      "int",
      "blockedDrivers");
  to_json_key(
      j,
      "completedDrivers",
      p.completedDrivers,
      "TaskStats",
      "int",
      "completedDrivers");
  to_json_key(
      j,
      "totalNewDrivers",
      p.totalNewDrivers,
      "TaskStats",
      "int",
      "totalNewDrivers");
  to_json_key(
      j,
      "queuedNewDrivers",
      p.queuedNewDrivers,
      "TaskStats",
      "int",
      "queuedNewDrivers");
  to_json_key(
      j,
      "runningNewDrivers",
      p.runningNewDrivers,
      "TaskStats",
      "int",
      "runningNewDrivers");
  to_json_key(
      j,
      "completedNewDrivers",
      p.completedNewDrivers,
      "TaskStats",
      "int",
      "completedNewDrivers");
  to_json_key(
      j, "totalSplits", p.totalSplits, "TaskStats", "int", "totalSplits");
  to_json_key(
      j, "queuedSplits", p.queuedSplits, "TaskStats", "int", "queuedSplits");
  to_json_key(
      j, "runningSplits", p.runningSplits, "TaskStats", "int", "runningSplits");
  to_json_key(
      j,
      "completedSplits",
      p.completedSplits,
      "TaskStats",
      "int",
      "completedSplits");
  to_json_key(
      j,
      "cumulativeUserMemory",
      p.cumulativeUserMemory,
      "TaskStats",
      "double",
      "cumulativeUserMemory");
  to_json_key(
      j,
      "cumulativeTotalMemory",
      p.cumulativeTotalMemory,
      "TaskStats",
      "double",
      "cumulativeTotalMemory");
  to_json_key(
      j,
      "userMemoryReservationInBytes",
      p.userMemoryReservationInBytes,
      "TaskStats",
      "int64_t",
      "userMemoryReservationInBytes");
  to_json_key(
      j,
      "revocableMemoryReservationInBytes",
      p.revocableMemoryReservationInBytes,
      "TaskStats",
      "int64_t",
      "revocableMemoryReservationInBytes");
  to_json_key(
      j,
      "systemMemoryReservationInBytes",
      p.systemMemoryReservationInBytes,
      "TaskStats",
      "int64_t",
      "systemMemoryReservationInBytes");
  to_json_key(
      j,
      "peakTotalMemoryInBytes",
      p.peakTotalMemoryInBytes,
      "TaskStats",
      "int64_t",
      "peakTotalMemoryInBytes");
  to_json_key(
      j,
      "peakUserMemoryInBytes",
      p.peakUserMemoryInBytes,
      "TaskStats",
      "int64_t",
      "peakUserMemoryInBytes");
  to_json_key(
      j,
      "peakNodeTotalMemoryInBytes",
      p.peakNodeTotalMemoryInBytes,
      "TaskStats",
      "int64_t",
      "peakNodeTotalMemoryInBytes");
  to_json_key(
      j,
      "totalScheduledTimeInNanos",
      p.totalScheduledTimeInNanos,
      "TaskStats",
      "int64_t",
      "totalScheduledTimeInNanos");
  to_json_key(
      j,
      "totalCpuTimeInNanos",
      p.totalCpuTimeInNanos,
      "TaskStats",
      "int64_t",
      "totalCpuTimeInNanos");
  to_json_key(
      j,
      "totalBlockedTimeInNanos",
      p.totalBlockedTimeInNanos,
      "TaskStats",
      "int64_t",
      "totalBlockedTimeInNanos");
  to_json_key(
      j, "fullyBlocked", p.fullyBlocked, "TaskStats", "bool", "fullyBlocked");
  to_json_key(
      j,
      "blockedReasons",
      p.blockedReasons,
      "TaskStats",
      "List<BlockedReason>",
      "blockedReasons");
  to_json_key(
      j,
      "totalAllocationInBytes",
      p.totalAllocationInBytes,
      "TaskStats",
      "int64_t",
      "totalAllocationInBytes");
  to_json_key(
      j,
      "rawInputDataSizeInBytes",
      p.rawInputDataSizeInBytes,
      "TaskStats",
      "int64_t",
      "rawInputDataSizeInBytes");
  to_json_key(
      j,
      "rawInputPositions",
      p.rawInputPositions,
      "TaskStats",
      "int64_t",
      "rawInputPositions");
  to_json_key(
      j,
      "processedInputDataSizeInBytes",
      p.processedInputDataSizeInBytes,
      "TaskStats",
      "int64_t",
      "processedInputDataSizeInBytes");
  to_json_key(
      j,
      "processedInputPositions",
      p.processedInputPositions,
      "TaskStats",
      "int64_t",
      "processedInputPositions");
  to_json_key(
      j,
      "outputDataSizeInBytes",
      p.outputDataSizeInBytes,
      "TaskStats",
      "int64_t",
      "outputDataSizeInBytes");
  to_json_key(
      j,
      "outputPositions",
      p.outputPositions,
      "TaskStats",
      "int64_t",
      "outputPositions");
  to_json_key(
      j,
      "physicalWrittenDataSizeInBytes",
      p.physicalWrittenDataSizeInBytes,
      "TaskStats",
      "int64_t",
      "physicalWrittenDataSizeInBytes");
  to_json_key(
      j, "fullGcCount", p.fullGcCount, "TaskStats", "int", "fullGcCount");
  to_json_key(
      j,
      "fullGcTimeInMillis",
      p.fullGcTimeInMillis,
      "TaskStats",
      "int64_t",
      "fullGcTimeInMillis");
  to_json_key(
      j,
      "pipelines",
      p.pipelines,
      "TaskStats",
      "List<PipelineStats>",
      "pipelines");
  to_json_key(
      j,
      "runtimeStats",
      p.runtimeStats,
      "TaskStats",
      "RuntimeStats",
      "runtimeStats");
}

void from_json(const json& j, TaskStats& p) {
  from_json_key(
      j,
      "createTimeInMillis",
      p.createTimeInMillis,
      "TaskStats",
      "int64_t",
      "createTimeInMillis");
  from_json_key(
      j,
      "firstStartTimeInMillis",
      p.firstStartTimeInMillis,
      "TaskStats",
      "int64_t",
      "firstStartTimeInMillis");
  from_json_key(
      j,
      "lastStartTimeInMillis",
      p.lastStartTimeInMillis,
      "TaskStats",
      "int64_t",
      "lastStartTimeInMillis");
  from_json_key(
      j,
      "lastEndTimeInMillis",
      p.lastEndTimeInMillis,
      "TaskStats",
      "int64_t",
      "lastEndTimeInMillis");
  from_json_key(
      j,
      "endTimeInMillis",
      p.endTimeInMillis,
      "TaskStats",
      "int64_t",
      "endTimeInMillis");
  from_json_key(
      j,
      "elapsedTimeInNanos",
      p.elapsedTimeInNanos,
      "TaskStats",
      "int64_t",
      "elapsedTimeInNanos");
  from_json_key(
      j,
      "queuedTimeInNanos",
      p.queuedTimeInNanos,
      "TaskStats",
      "int64_t",
      "queuedTimeInNanos");
  from_json_key(
      j, "totalDrivers", p.totalDrivers, "TaskStats", "int", "totalDrivers");
  from_json_key(
      j, "queuedDrivers", p.queuedDrivers, "TaskStats", "int", "queuedDrivers");
  from_json_key(
      j,
      "queuedPartitionedDrivers",
      p.queuedPartitionedDrivers,
      "TaskStats",
      "int",
      "queuedPartitionedDrivers");
  from_json_key(
      j,
      "queuedPartitionedSplitsWeight",
      p.queuedPartitionedSplitsWeight,
      "TaskStats",
      "int64_t",
      "queuedPartitionedSplitsWeight");
  from_json_key(
      j,
      "runningDrivers",
      p.runningDrivers,
      "TaskStats",
      "int",
      "runningDrivers");
  from_json_key(
      j,
      "runningPartitionedDrivers",
      p.runningPartitionedDrivers,
      "TaskStats",
      "int",
      "runningPartitionedDrivers");
  from_json_key(
      j,
      "runningPartitionedSplitsWeight",
      p.runningPartitionedSplitsWeight,
      "TaskStats",
      "int64_t",
      "runningPartitionedSplitsWeight");
  from_json_key(
      j,
      "blockedDrivers",
      p.blockedDrivers,
      "TaskStats",
      "int",
      "blockedDrivers");
  from_json_key(
      j,
      "completedDrivers",
      p.completedDrivers,
      "TaskStats",
      "int",
      "completedDrivers");
  from_json_key(
      j,
      "totalNewDrivers",
      p.totalNewDrivers,
      "TaskStats",
      "int",
      "totalNewDrivers");
  from_json_key(
      j,
      "queuedNewDrivers",
      p.queuedNewDrivers,
      "TaskStats",
      "int",
      "queuedNewDrivers");
  from_json_key(
      j,
      "runningNewDrivers",
      p.runningNewDrivers,
      "TaskStats",
      "int",
      "runningNewDrivers");
  from_json_key(
      j,
      "completedNewDrivers",
      p.completedNewDrivers,
      "TaskStats",
      "int",
      "completedNewDrivers");
  from_json_key(
      j, "totalSplits", p.totalSplits, "TaskStats", "int", "totalSplits");
  from_json_key(
      j, "queuedSplits", p.queuedSplits, "TaskStats", "int", "queuedSplits");
  from_json_key(
      j, "runningSplits", p.runningSplits, "TaskStats", "int", "runningSplits");
  from_json_key(
      j,
      "completedSplits",
      p.completedSplits,
      "TaskStats",
      "int",
      "completedSplits");
  from_json_key(
      j,
      "cumulativeUserMemory",
      p.cumulativeUserMemory,
      "TaskStats",
      "double",
      "cumulativeUserMemory");
  from_json_key(
      j,
      "cumulativeTotalMemory",
      p.cumulativeTotalMemory,
      "TaskStats",
      "double",
      "cumulativeTotalMemory");
  from_json_key(
      j,
      "userMemoryReservationInBytes",
      p.userMemoryReservationInBytes,
      "TaskStats",
      "int64_t",
      "userMemoryReservationInBytes");
  from_json_key(
      j,
      "revocableMemoryReservationInBytes",
      p.revocableMemoryReservationInBytes,
      "TaskStats",
      "int64_t",
      "revocableMemoryReservationInBytes");
  from_json_key(
      j,
      "systemMemoryReservationInBytes",
      p.systemMemoryReservationInBytes,
      "TaskStats",
      "int64_t",
      "systemMemoryReservationInBytes");
  from_json_key(
      j,
      "peakTotalMemoryInBytes",
      p.peakTotalMemoryInBytes,
      "TaskStats",
      "int64_t",
      "peakTotalMemoryInBytes");
  from_json_key(
      j,
      "peakUserMemoryInBytes",
      p.peakUserMemoryInBytes,
      "TaskStats",
      "int64_t",
      "peakUserMemoryInBytes");
  from_json_key(
      j,
      "peakNodeTotalMemoryInBytes",
      p.peakNodeTotalMemoryInBytes,
      "TaskStats",
      "int64_t",
      "peakNodeTotalMemoryInBytes");
  from_json_key(
      j,
      "totalScheduledTimeInNanos",
      p.totalScheduledTimeInNanos,
      "TaskStats",
      "int64_t",
      "totalScheduledTimeInNanos");
  from_json_key(
      j,
      "totalCpuTimeInNanos",
      p.totalCpuTimeInNanos,
      "TaskStats",
      "int64_t",
      "totalCpuTimeInNanos");
  from_json_key(
      j,
      "totalBlockedTimeInNanos",
      p.totalBlockedTimeInNanos,
      "TaskStats",
      "int64_t",
      "totalBlockedTimeInNanos");
  from_json_key(
      j, "fullyBlocked", p.fullyBlocked, "TaskStats", "bool", "fullyBlocked");
  from_json_key(
      j,
      "blockedReasons",
      p.blockedReasons,
      "TaskStats",
      "List<BlockedReason>",
      "blockedReasons");
  from_json_key(
      j,
      "totalAllocationInBytes",
      p.totalAllocationInBytes,
      "TaskStats",
      "int64_t",
      "totalAllocationInBytes");
  from_json_key(
      j,
      "rawInputDataSizeInBytes",
      p.rawInputDataSizeInBytes,
      "TaskStats",
      "int64_t",
      "rawInputDataSizeInBytes");
  from_json_key(
      j,
      "rawInputPositions",
      p.rawInputPositions,
      "TaskStats",
      "int64_t",
      "rawInputPositions");
  from_json_key(
      j,
      "processedInputDataSizeInBytes",
      p.processedInputDataSizeInBytes,
      "TaskStats",
      "int64_t",
      "processedInputDataSizeInBytes");
  from_json_key(
      j,
      "processedInputPositions",
      p.processedInputPositions,
      "TaskStats",
      "int64_t",
      "processedInputPositions");
  from_json_key(
      j,
      "outputDataSizeInBytes",
      p.outputDataSizeInBytes,
      "TaskStats",
      "int64_t",
      "outputDataSizeInBytes");
  from_json_key(
      j,
      "outputPositions",
      p.outputPositions,
      "TaskStats",
      "int64_t",
      "outputPositions");
  from_json_key(
      j,
      "physicalWrittenDataSizeInBytes",
      p.physicalWrittenDataSizeInBytes,
      "TaskStats",
      "int64_t",
      "physicalWrittenDataSizeInBytes");
  from_json_key(
      j, "fullGcCount", p.fullGcCount, "TaskStats", "int", "fullGcCount");
  from_json_key(
      j,
      "fullGcTimeInMillis",
      p.fullGcTimeInMillis,
      "TaskStats",
      "int64_t",
      "fullGcTimeInMillis");
  from_json_key(
      j,
      "pipelines",
      p.pipelines,
      "TaskStats",
      "List<PipelineStats>",
      "pipelines");
  from_json_key(
      j,
      "runtimeStats",
      p.runtimeStats,
      "TaskStats",
      "RuntimeStats",
      "runtimeStats");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<TaskState, json> TaskState_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {TaskState::PLANNED, "PLANNED"},
        {TaskState::RUNNING, "RUNNING"},
        {TaskState::FINISHED, "FINISHED"},
        {TaskState::CANCELED, "CANCELED"},
        {TaskState::ABORTED, "ABORTED"},
        {TaskState::FAILED, "FAILED"}};
void to_json(json& j, const TaskState& e) {
  static_assert(std::is_enum<TaskState>::value, "TaskState must be an enum!");
  const auto* it = std::find_if(
      std::begin(TaskState_enum_table),
      std::end(TaskState_enum_table),
      [e](const std::pair<TaskState, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(TaskState_enum_table))
           ? it
           : std::begin(TaskState_enum_table))
          ->second;
}
void from_json(const json& j, TaskState& e) {
  static_assert(std::is_enum<TaskState>::value, "TaskState must be an enum!");
  const auto* it = std::find_if(
      std::begin(TaskState_enum_table),
      std::end(TaskState_enum_table),
      [&j](const std::pair<TaskState, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(TaskState_enum_table))
           ? it
           : std::begin(TaskState_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const TaskStatus& p) {
  j = json::object();
  to_json_key(
      j,
      "taskInstanceIdLeastSignificantBits",
      p.taskInstanceIdLeastSignificantBits,
      "TaskStatus",
      "int64_t",
      "taskInstanceIdLeastSignificantBits");
  to_json_key(
      j,
      "taskInstanceIdMostSignificantBits",
      p.taskInstanceIdMostSignificantBits,
      "TaskStatus",
      "int64_t",
      "taskInstanceIdMostSignificantBits");
  to_json_key(j, "version", p.version, "TaskStatus", "int64_t", "version");
  to_json_key(j, "state", p.state, "TaskStatus", "TaskState", "state");
  to_json_key(j, "self", p.self, "TaskStatus", "URI", "self");
  to_json_key(
      j,
      "completedDriverGroups",
      p.completedDriverGroups,
      "TaskStatus",
      "List<Lifespan>",
      "completedDriverGroups");
  to_json_key(
      j,
      "failures",
      p.failures,
      "TaskStatus",
      "List<ExecutionFailureInfo>",
      "failures");
  to_json_key(
      j,
      "queuedPartitionedDrivers",
      p.queuedPartitionedDrivers,
      "TaskStatus",
      "int",
      "queuedPartitionedDrivers");
  to_json_key(
      j,
      "runningPartitionedDrivers",
      p.runningPartitionedDrivers,
      "TaskStatus",
      "int",
      "runningPartitionedDrivers");
  to_json_key(
      j,
      "outputBufferUtilization",
      p.outputBufferUtilization,
      "TaskStatus",
      "double",
      "outputBufferUtilization");
  to_json_key(
      j,
      "outputBufferOverutilized",
      p.outputBufferOverutilized,
      "TaskStatus",
      "bool",
      "outputBufferOverutilized");
  to_json_key(
      j,
      "physicalWrittenDataSizeInBytes",
      p.physicalWrittenDataSizeInBytes,
      "TaskStatus",
      "int64_t",
      "physicalWrittenDataSizeInBytes");
  to_json_key(
      j,
      "memoryReservationInBytes",
      p.memoryReservationInBytes,
      "TaskStatus",
      "int64_t",
      "memoryReservationInBytes");
  to_json_key(
      j,
      "systemMemoryReservationInBytes",
      p.systemMemoryReservationInBytes,
      "TaskStatus",
      "int64_t",
      "systemMemoryReservationInBytes");
  to_json_key(
      j,
      "peakNodeTotalMemoryReservationInBytes",
      p.peakNodeTotalMemoryReservationInBytes,
      "TaskStatus",
      "int64_t",
      "peakNodeTotalMemoryReservationInBytes");
  to_json_key(
      j, "fullGcCount", p.fullGcCount, "TaskStatus", "int64_t", "fullGcCount");
  to_json_key(
      j,
      "fullGcTimeInMillis",
      p.fullGcTimeInMillis,
      "TaskStatus",
      "int64_t",
      "fullGcTimeInMillis");
  to_json_key(
      j,
      "totalCpuTimeInNanos",
      p.totalCpuTimeInNanos,
      "TaskStatus",
      "int64_t",
      "totalCpuTimeInNanos");
  to_json_key(
      j,
      "taskAgeInMillis",
      p.taskAgeInMillis,
      "TaskStatus",
      "int64_t",
      "taskAgeInMillis");
  to_json_key(
      j,
      "queuedPartitionedSplitsWeight",
      p.queuedPartitionedSplitsWeight,
      "TaskStatus",
      "int64_t",
      "queuedPartitionedSplitsWeight");
  to_json_key(
      j,
      "runningPartitionedSplitsWeight",
      p.runningPartitionedSplitsWeight,
      "TaskStatus",
      "int64_t",
      "runningPartitionedSplitsWeight");
}

void from_json(const json& j, TaskStatus& p) {
  from_json_key(
      j,
      "taskInstanceIdLeastSignificantBits",
      p.taskInstanceIdLeastSignificantBits,
      "TaskStatus",
      "int64_t",
      "taskInstanceIdLeastSignificantBits");
  from_json_key(
      j,
      "taskInstanceIdMostSignificantBits",
      p.taskInstanceIdMostSignificantBits,
      "TaskStatus",
      "int64_t",
      "taskInstanceIdMostSignificantBits");
  from_json_key(j, "version", p.version, "TaskStatus", "int64_t", "version");
  from_json_key(j, "state", p.state, "TaskStatus", "TaskState", "state");
  from_json_key(j, "self", p.self, "TaskStatus", "URI", "self");
  from_json_key(
      j,
      "completedDriverGroups",
      p.completedDriverGroups,
      "TaskStatus",
      "List<Lifespan>",
      "completedDriverGroups");
  from_json_key(
      j,
      "failures",
      p.failures,
      "TaskStatus",
      "List<ExecutionFailureInfo>",
      "failures");
  from_json_key(
      j,
      "queuedPartitionedDrivers",
      p.queuedPartitionedDrivers,
      "TaskStatus",
      "int",
      "queuedPartitionedDrivers");
  from_json_key(
      j,
      "runningPartitionedDrivers",
      p.runningPartitionedDrivers,
      "TaskStatus",
      "int",
      "runningPartitionedDrivers");
  from_json_key(
      j,
      "outputBufferUtilization",
      p.outputBufferUtilization,
      "TaskStatus",
      "double",
      "outputBufferUtilization");
  from_json_key(
      j,
      "outputBufferOverutilized",
      p.outputBufferOverutilized,
      "TaskStatus",
      "bool",
      "outputBufferOverutilized");
  from_json_key(
      j,
      "physicalWrittenDataSizeInBytes",
      p.physicalWrittenDataSizeInBytes,
      "TaskStatus",
      "int64_t",
      "physicalWrittenDataSizeInBytes");
  from_json_key(
      j,
      "memoryReservationInBytes",
      p.memoryReservationInBytes,
      "TaskStatus",
      "int64_t",
      "memoryReservationInBytes");
  from_json_key(
      j,
      "systemMemoryReservationInBytes",
      p.systemMemoryReservationInBytes,
      "TaskStatus",
      "int64_t",
      "systemMemoryReservationInBytes");
  from_json_key(
      j,
      "peakNodeTotalMemoryReservationInBytes",
      p.peakNodeTotalMemoryReservationInBytes,
      "TaskStatus",
      "int64_t",
      "peakNodeTotalMemoryReservationInBytes");
  from_json_key(
      j, "fullGcCount", p.fullGcCount, "TaskStatus", "int64_t", "fullGcCount");
  from_json_key(
      j,
      "fullGcTimeInMillis",
      p.fullGcTimeInMillis,
      "TaskStatus",
      "int64_t",
      "fullGcTimeInMillis");
  from_json_key(
      j,
      "totalCpuTimeInNanos",
      p.totalCpuTimeInNanos,
      "TaskStatus",
      "int64_t",
      "totalCpuTimeInNanos");
  from_json_key(
      j,
      "taskAgeInMillis",
      p.taskAgeInMillis,
      "TaskStatus",
      "int64_t",
      "taskAgeInMillis");
  from_json_key(
      j,
      "queuedPartitionedSplitsWeight",
      p.queuedPartitionedSplitsWeight,
      "TaskStatus",
      "int64_t",
      "queuedPartitionedSplitsWeight");
  from_json_key(
      j,
      "runningPartitionedSplitsWeight",
      p.runningPartitionedSplitsWeight,
      "TaskStatus",
      "int64_t",
      "runningPartitionedSplitsWeight");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

void to_json(json& j, const TaskInfo& p) {
  j = json::object();
  to_json_key(j, "taskId", p.taskId, "TaskInfo", "TaskId", "taskId");
  to_json_key(
      j, "taskStatus", p.taskStatus, "TaskInfo", "TaskStatus", "taskStatus");
  to_json_key(
      j,
      "lastHeartbeatInMillis",
      p.lastHeartbeatInMillis,
      "TaskInfo",
      "int64_t",
      "lastHeartbeatInMillis");
  to_json_key(
      j,
      "outputBuffers",
      p.outputBuffers,
      "TaskInfo",
      "OutputBufferInfo",
      "outputBuffers");
  to_json_key(
      j,
      "noMoreSplits",
      p.noMoreSplits,
      "TaskInfo",
      "List<PlanNodeId>",
      "noMoreSplits");
  to_json_key(j, "stats", p.stats, "TaskInfo", "TaskStats", "stats");
  to_json_key(j, "needsPlan", p.needsPlan, "TaskInfo", "bool", "needsPlan");
  to_json_key(j, "nodeId", p.nodeId, "TaskInfo", "String", "nodeId");
}

void from_json(const json& j, TaskInfo& p) {
  from_json_key(j, "taskId", p.taskId, "TaskInfo", "TaskId", "taskId");
  from_json_key(
      j, "taskStatus", p.taskStatus, "TaskInfo", "TaskStatus", "taskStatus");
  from_json_key(
      j,
      "lastHeartbeatInMillis",
      p.lastHeartbeatInMillis,
      "TaskInfo",
      "int64_t",
      "lastHeartbeatInMillis");
  from_json_key(
      j,
      "outputBuffers",
      p.outputBuffers,
      "TaskInfo",
      "OutputBufferInfo",
      "outputBuffers");
  from_json_key(
      j,
      "noMoreSplits",
      p.noMoreSplits,
      "TaskInfo",
      "List<PlanNodeId>",
      "noMoreSplits");
  from_json_key(j, "stats", p.stats, "TaskInfo", "TaskStats", "stats");
  from_json_key(j, "needsPlan", p.needsPlan, "TaskInfo", "bool", "needsPlan");
  from_json_key(j, "nodeId", p.nodeId, "TaskInfo", "String", "nodeId");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
// Loosely copied this here from NLOHMANN_JSON_SERIALIZE_ENUM()

// NOLINTNEXTLINE: cppcoreguidelines-avoid-c-arrays
static const std::pair<Step, json> Step_enum_table[] =
    { // NOLINT: cert-err58-cpp
        {Step::SINGLE, "SINGLE"},
        {Step::PARTIAL, "PARTIAL"},
        {Step::FINAL, "FINAL"}};
void to_json(json& j, const Step& e) {
  static_assert(std::is_enum<Step>::value, "Step must be an enum!");
  const auto* it = std::find_if(
      std::begin(Step_enum_table),
      std::end(Step_enum_table),
      [e](const std::pair<Step, json>& ej_pair) -> bool {
        return ej_pair.first == e;
      });
  j = ((it != std::end(Step_enum_table)) ? it : std::begin(Step_enum_table))
          ->second;
}
void from_json(const json& j, Step& e) {
  static_assert(std::is_enum<Step>::value, "Step must be an enum!");
  const auto* it = std::find_if(
      std::begin(Step_enum_table),
      std::end(Step_enum_table),
      [&j](const std::pair<Step, json>& ej_pair) -> bool {
        return ej_pair.second == j;
      });
  e = ((it != std::end(Step_enum_table)) ? it : std::begin(Step_enum_table))
          ->first;
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
TopNNode::TopNNode() noexcept {
  _type = ".TopNNode";
}

void to_json(json& j, const TopNNode& p) {
  j = json::object();
  j["@type"] = ".TopNNode";
  to_json_key(j, "id", p.id, "TopNNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "TopNNode", "PlanNode", "source");
  to_json_key(j, "count", p.count, "TopNNode", "int64_t", "count");
  to_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "TopNNode",
      "OrderingScheme",
      "orderingScheme");
  to_json_key(j, "step", p.step, "TopNNode", "Step", "step");
}

void from_json(const json& j, TopNNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "TopNNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "TopNNode", "PlanNode", "source");
  from_json_key(j, "count", p.count, "TopNNode", "int64_t", "count");
  from_json_key(
      j,
      "orderingScheme",
      p.orderingScheme,
      "TopNNode",
      "OrderingScheme",
      "orderingScheme");
  from_json_key(j, "step", p.step, "TopNNode", "Step", "step");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
TopNRowNumberNode::TopNRowNumberNode() noexcept {
  _type = "com.facebook.presto.sql.planner.plan.TopNRowNumberNode";
}

void to_json(json& j, const TopNRowNumberNode& p) {
  j = json::object();
  j["@type"] = "com.facebook.presto.sql.planner.plan.TopNRowNumberNode";
  to_json_key(j, "id", p.id, "TopNRowNumberNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "TopNRowNumberNode", "PlanNode", "source");
  to_json_key(
      j,
      "specification",
      p.specification,
      "TopNRowNumberNode",
      "DataOrganizationSpecification",
      "specification");
  to_json_key(
      j,
      "rowNumberVariable",
      p.rowNumberVariable,
      "TopNRowNumberNode",
      "VariableReferenceExpression",
      "rowNumberVariable");
  to_json_key(
      j,
      "maxRowCountPerPartition",
      p.maxRowCountPerPartition,
      "TopNRowNumberNode",
      "int",
      "maxRowCountPerPartition");
  to_json_key(j, "partial", p.partial, "TopNRowNumberNode", "bool", "partial");
  to_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "TopNRowNumberNode",
      "VariableReferenceExpression",
      "hashVariable");
}

void from_json(const json& j, TopNRowNumberNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "TopNRowNumberNode", "PlanNodeId", "id");
  from_json_key(
      j, "source", p.source, "TopNRowNumberNode", "PlanNode", "source");
  from_json_key(
      j,
      "specification",
      p.specification,
      "TopNRowNumberNode",
      "DataOrganizationSpecification",
      "specification");
  from_json_key(
      j,
      "rowNumberVariable",
      p.rowNumberVariable,
      "TopNRowNumberNode",
      "VariableReferenceExpression",
      "rowNumberVariable");
  from_json_key(
      j,
      "maxRowCountPerPartition",
      p.maxRowCountPerPartition,
      "TopNRowNumberNode",
      "int",
      "maxRowCountPerPartition");
  from_json_key(
      j, "partial", p.partial, "TopNRowNumberNode", "bool", "partial");
  from_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "TopNRowNumberNode",
      "VariableReferenceExpression",
      "hashVariable");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
UnnestNode::UnnestNode() noexcept {
  _type = ".UnnestNode";
}

void to_json(json& j, const UnnestNode& p) {
  j = json::object();
  j["@type"] = ".UnnestNode";
  to_json_key(j, "id", p.id, "UnnestNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "UnnestNode", "PlanNode", "source");
  to_json_key(
      j,
      "replicateVariables",
      p.replicateVariables,
      "UnnestNode",
      "List<VariableReferenceExpression>",
      "replicateVariables");
  to_json_key(
      j,
      "unnestVariables",
      p.unnestVariables,
      "UnnestNode",
      "Map<VariableReferenceExpression, List<VariableReferenceExpression>>",
      "unnestVariables");
  to_json_key(
      j,
      "ordinalityVariable",
      p.ordinalityVariable,
      "UnnestNode",
      "VariableReferenceExpression",
      "ordinalityVariable");
}

void from_json(const json& j, UnnestNode& p) {
  p._type = j["@type"];
  from_json_key(j, "id", p.id, "UnnestNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "UnnestNode", "PlanNode", "source");
  from_json_key(
      j,
      "replicateVariables",
      p.replicateVariables,
      "UnnestNode",
      "List<VariableReferenceExpression>",
      "replicateVariables");
  from_json_key(
      j,
      "unnestVariables",
      p.unnestVariables,
      "UnnestNode",
      "Map<VariableReferenceExpression, List<VariableReferenceExpression>>",
      "unnestVariables");
  from_json_key(
      j,
      "ordinalityVariable",
      p.ordinalityVariable,
      "UnnestNode",
      "VariableReferenceExpression",
      "ordinalityVariable");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
UpdateHandle::UpdateHandle() noexcept {
  _type = "UpdateHandle";
}

void to_json(json& j, const UpdateHandle& p) {
  j = json::object();
  j["@type"] = "UpdateHandle";
  to_json_key(j, "handle", p.handle, "UpdateHandle", "TableHandle", "handle");
  to_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "UpdateHandle",
      "SchemaTableName",
      "schemaTableName");
}

void from_json(const json& j, UpdateHandle& p) {
  p._type = j["@type"];
  from_json_key(j, "handle", p.handle, "UpdateHandle", "TableHandle", "handle");
  from_json_key(
      j,
      "schemaTableName",
      p.schemaTableName,
      "UpdateHandle",
      "SchemaTableName",
      "schemaTableName");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
ValuesNode::ValuesNode() noexcept {
  _type = ".ValuesNode";
}

void to_json(json& j, const ValuesNode& p) {
  j = json::object();
  j["@type"] = ".ValuesNode";
  to_json_key(
      j, "location", p.location, "ValuesNode", "SourceLocation", "location");
  to_json_key(j, "id", p.id, "ValuesNode", "PlanNodeId", "id");
  to_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "ValuesNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  to_json_key(
      j,
      "rows",
      p.rows,
      "ValuesNode",
      "List<List<std::shared_ptr<RowExpression>>>",
      "rows");
  to_json_key(
      j,
      "valuesNodeLabel",
      p.valuesNodeLabel,
      "ValuesNode",
      "String",
      "valuesNodeLabel");
}

void from_json(const json& j, ValuesNode& p) {
  p._type = j["@type"];
  from_json_key(
      j, "location", p.location, "ValuesNode", "SourceLocation", "location");
  from_json_key(j, "id", p.id, "ValuesNode", "PlanNodeId", "id");
  from_json_key(
      j,
      "outputVariables",
      p.outputVariables,
      "ValuesNode",
      "List<VariableReferenceExpression>",
      "outputVariables");
  from_json_key(
      j,
      "rows",
      p.rows,
      "ValuesNode",
      "List<List<std::shared_ptr<RowExpression>>>",
      "rows");
  from_json_key(
      j,
      "valuesNodeLabel",
      p.valuesNodeLabel,
      "ValuesNode",
      "String",
      "valuesNodeLabel");
}
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
WindowNode::WindowNode() noexcept {
  _type = ".WindowNode";
}

void to_json(json& j, const WindowNode& p) {
  j = json::object();
  j["@type"] = ".WindowNode";
  to_json_key(
      j,
      "sourceLocation",
      p.sourceLocation,
      "WindowNode",
      "SourceLocation",
      "sourceLocation");
  to_json_key(j, "id", p.id, "WindowNode", "PlanNodeId", "id");
  to_json_key(j, "source", p.source, "WindowNode", "PlanNode", "source");
  to_json_key(
      j,
      "specification",
      p.specification,
      "WindowNode",
      "DataOrganizationSpecification",
      "specification");
  to_json_key(
      j,
      "windowFunctions",
      p.windowFunctions,
      "WindowNode",
      "Map<VariableReferenceExpression, Function>",
      "windowFunctions");
  to_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "WindowNode",
      "VariableReferenceExpression",
      "hashVariable");
  to_json_key(
      j,
      "prePartitionedInputs",
      p.prePartitionedInputs,
      "WindowNode",
      "List<VariableReferenceExpression>",
      "prePartitionedInputs");
  to_json_key(
      j,
      "preSortedOrderPrefix",
      p.preSortedOrderPrefix,
      "WindowNode",
      "int",
      "preSortedOrderPrefix");
}

void from_json(const json& j, WindowNode& p) {
  p._type = j["@type"];
  from_json_key(
      j,
      "sourceLocation",
      p.sourceLocation,
      "WindowNode",
      "SourceLocation",
      "sourceLocation");
  from_json_key(j, "id", p.id, "WindowNode", "PlanNodeId", "id");
  from_json_key(j, "source", p.source, "WindowNode", "PlanNode", "source");
  from_json_key(
      j,
      "specification",
      p.specification,
      "WindowNode",
      "DataOrganizationSpecification",
      "specification");
  from_json_key(
      j,
      "windowFunctions",
      p.windowFunctions,
      "WindowNode",
      "Map<VariableReferenceExpression, Function>",
      "windowFunctions");
  from_json_key(
      j,
      "hashVariable",
      p.hashVariable,
      "WindowNode",
      "VariableReferenceExpression",
      "hashVariable");
  from_json_key(
      j,
      "prePartitionedInputs",
      p.prePartitionedInputs,
      "WindowNode",
      "List<VariableReferenceExpression>",
      "prePartitionedInputs");
  from_json_key(
      j,
      "preSortedOrderPrefix",
      p.preSortedOrderPrefix,
      "WindowNode",
      "int",
      "preSortedOrderPrefix");
}
} // namespace facebook::presto::protocol
