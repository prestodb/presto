// DO NOT EDIT : This file is generated by chevron
/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once

// This file is generated DO NOT EDIT @generated

#include <tgmath.h>
#include <cstdint>
#include <exception>
#include <iostream>
#include <list>
#include <map>
#include <regex>
#include <set>
#include <string>

#include <folly/Format.h>
#include <utility>
#include "presto_cpp/external/json/nlohmann/json.hpp"
#include "presto_cpp/presto_protocol/core/DataSize.h"
#include "presto_cpp/presto_protocol/core/Duration.h"
#include "velox/common/base/Exceptions.h"
#include "velox/common/encode/Base64.h"

using nlohmann::json;

namespace facebook::presto::protocol {
enum class NodeSelectionStrategy {
  HARD_AFFINITY,
  SOFT_AFFINITY,
  NO_PREFERENCE
};
extern void to_json(json& j, const NodeSelectionStrategy& e);
extern void from_json(const json& j, NodeSelectionStrategy& e);
} // namespace facebook::presto::protocol

namespace facebook::presto::protocol {

extern const char* const PRESTO_PAGES_MIME_TYPE;

extern const char* const PRESTO_CURRENT_STATE_HTTP_HEADER;
extern const char* const PRESTO_MAX_WAIT_HTTP_HEADER;
extern const char* const PRESTO_MAX_SIZE_HTTP_HEADER;
extern const char* const PRESTO_TASK_INSTANCE_ID_HEADER;
extern const char* const PRESTO_PAGE_TOKEN_HEADER;
extern const char* const PRESTO_PAGE_NEXT_TOKEN_HEADER;
extern const char* const PRESTO_BUFFER_COMPLETE_HEADER;
extern const char* const PRESTO_GET_DATA_SIZE_HEADER;
extern const char* const PRESTO_BUFFER_REMAINING_BYTES_HEADER;
extern const char* const PRESTO_BUFFER_WAIT_TIME_MS_HEADER;
extern const char* const PRESTO_BUFFER_REMAINING_FROM_SPILL_HEADER;

extern const char* const PRESTO_MAX_WAIT_DEFAULT;
extern const char* const PRESTO_MAX_SIZE_DEFAULT;

extern const char* const PRESTO_ABORT_TASK_URL_PARAM;

class Exception : public std::runtime_error {
 public:
  explicit Exception(const std::string& message)
      : std::runtime_error(message) {};
};

class TypeError : public Exception {
 public:
  explicit TypeError(const std::string& message) : Exception(message) {};
};

class OutOfRange : public Exception {
 public:
  explicit OutOfRange(const std::string& message) : Exception(message) {};
};
class ParseError : public Exception {
 public:
  explicit ParseError(const std::string& message) : Exception(message) {};
};

using String = std::string;
using Integer = int;
using Long = int64_t;
using boolean = bool;

template <typename T>
using List = std::vector<T>;
template <typename T>
using Set = std::set<T>;
template <typename K, typename V>
using Map = std::map<K, V>;

// These will have to be customized
//
using UUID = std::string;

using Subfield = std::string;
using HiveType = std::string;
using Type = std::string;

using DateTime = std::string;
using Locale = std::string;
using TimeZoneKey = int16_t;
using URI = std::string;
using SqlFunctionId = std::string;

using QualifiedObjectName = std::string;
using TypeSignature = std::string;
using HostAddress = std::string;

using ConnectorId = std::string;
using MemoryPoolId = std::string;
using OutputBufferId = std::string;
using PlanFragmentId = std::string;
using PlanNodeId = std::string;
using QueryId = std::string;
using TaskId = std::string;
using TransactionId = std::string;
struct RuntimeMetric;
using RuntimeStats = Map<String, RuntimeMetric>;
using SplitWeight = int64_t;
struct SourceLocation;

template <typename T>
void to_json_key(json& j, const char* key, const T& value) {
  j[key] = value;
}

template <typename T>
void to_json_key(json& j, const char* key, const std::shared_ptr<T>& value) {
  if (value != nullptr) {
    j[key] = value;
  }
}

template <typename T>
void to_json_key(
    json& j,
    const char* key,
    const T& value,
    const char* className,
    const char* typeName,
    const char* fieldName) {
  try {
    to_json_key(j, key, value);
  } catch (json::type_error& e) {
    throw TypeError(
        std::string(e.what()) + " " + className + " " + typeName + " " +
        fieldName);
  }
}

template <typename T>
void from_json_key(const json& j, const char* key, T& value) {
  j.at(key).get_to(value);
}

template <typename T>
void from_json_key(const json& j, const char* key, std::shared_ptr<T>& value) {
  if (j.count(key)) {
    j.at(key).get_to(value);
  }
}

template <typename T>
void from_json_key(
    const json& j,
    const char* key,
    T& value,
    const char* className,
    const char* typeName,
    const char* fieldName) {
  try {
    from_json_key(j, key, value);
  } catch (json::type_error& e) {
    throw TypeError(
        std::string(e.what()) + " " + className + " " + typeName + " " +
        fieldName);
  } catch (json::out_of_range& e) {
    throw OutOfRange(
        std::string(e.what()) + " " + className + " " + typeName + " " +
        fieldName);
  }
}

struct KeyedSubclass {
  std::string _type; // This member holds the subtype that was serialized.

  std::string getSubclassKey(const json& j);
  virtual ~KeyedSubclass() {}
};

struct JsonEncodedSubclass : public KeyedSubclass {
  std::string getSubclassKey(const json& j);
};

struct Base64EncodedSubclass : public KeyedSubclass {
  std::string getSubclassKey(const json& j);

  virtual bool operator<(const Base64EncodedSubclass& /* o */) const {
    throw std::runtime_error("missing operator<() in Base64EncodedSubclass");
  }
};

} // namespace facebook::presto::protocol

namespace nlohmann {
std::string json_map_key(const std::string p);

template <typename T>
void to_json(json& j, const std::shared_ptr<T>& p) {
  j = *p;
}
template <typename T>
void from_json(const json& j, std::shared_ptr<T>& p) {
  p = std::make_shared<T>();
  j.get_to(*p);
}

template <typename V>
struct adl_serializer<facebook::presto::protocol::Map<int, V>> {
  static void to_json(
      json& j,
      const facebook::presto::protocol::Map<int, V>& p) {
    j = json::object();
    for (auto& el : p) {
      j[std::to_string(el.first)] = el.second;
    }
  }

  static void from_json(
      const json& j,
      facebook::presto::protocol::Map<int, V>& p) {
    for (auto& el : j.items()) {
      p.insert(std::pair<int, V>(std::stoi(el.key()), el.value().get<V>()));
    }
  }
};

template <typename K, typename V>
struct adl_serializer<facebook::presto::protocol::Map<K, V>> {
  static void to_json(json& j, const facebook::presto::protocol::Map<K, V>& p) {
    j = json::object();
    for (auto& el : p) {
      j[json_map_key(el.first)] = el.second;
    }
  }

  static void from_json(
      const json& j,
      facebook::presto::protocol::Map<K, V>& p) {
    for (auto& el : j.items()) {
      p.insert(std::pair<K, V>(K(el.key()), el.value().get<V>()));
    }
  }
};
} // namespace nlohmann

// Forward declaration of all abstract types
//
namespace facebook::presto::protocol {
struct ArgumentSpecification : public JsonEncodedSubclass {};
void to_json(json& j, const std::shared_ptr<ArgumentSpecification>& p);
void from_json(const json& j, std::shared_ptr<ArgumentSpecification>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ReturnTypeSpecification : public JsonEncodedSubclass {};
void to_json(json& j, const std::shared_ptr<ReturnTypeSpecification>& p);
void from_json(const json& j, std::shared_ptr<ReturnTypeSpecification>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct FunctionHandle : public JsonEncodedSubclass {};
void to_json(json& j, const std::shared_ptr<FunctionHandle>& p);
void from_json(const json& j, std::shared_ptr<FunctionHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RowExpression : public JsonEncodedSubclass {
  std::shared_ptr<SourceLocation> sourceLocation = {};
};
void to_json(json& j, const std::shared_ptr<RowExpression>& p);
void from_json(const json& j, std::shared_ptr<RowExpression>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct PlanNode : public JsonEncodedSubclass {
  PlanNodeId id = {};
};
void to_json(json& j, const std::shared_ptr<PlanNode>& p);
void from_json(const json& j, std::shared_ptr<PlanNode>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ExecutionWriterTarget : public JsonEncodedSubclass {};
void to_json(json& j, const std::shared_ptr<ExecutionWriterTarget>& p);
void from_json(const json& j, std::shared_ptr<ExecutionWriterTarget>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorPartitioningHandle : public JsonEncodedSubclass {};
void to_json(json& j, const std::shared_ptr<ConnectorPartitioningHandle>& p);
void from_json(const json& j, std::shared_ptr<ConnectorPartitioningHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Argument : public JsonEncodedSubclass {};
void to_json(json& j, const std::shared_ptr<Argument>& p);
void from_json(const json& j, std::shared_ptr<Argument>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct InputDistribution : public JsonEncodedSubclass {};
void to_json(json& j, const std::shared_ptr<InputDistribution>& p);
void from_json(const json& j, std::shared_ptr<InputDistribution>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ValueSet : public JsonEncodedSubclass {};
void to_json(json& j, const std::shared_ptr<ValueSet>& p);
void from_json(const json& j, std::shared_ptr<ValueSet>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorIndexHandle : public JsonEncodedSubclass {};
void to_json(json& j, const std::shared_ptr<ConnectorIndexHandle>& p);
void from_json(const json& j, std::shared_ptr<ConnectorIndexHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ColumnHandle : public JsonEncodedSubclass {
  virtual bool operator<(const ColumnHandle& /* o */) const {
    throw std::runtime_error("missing operator<() in ColumnHandle subclass");
  }
};
void to_json(json& j, const std::shared_ptr<ColumnHandle>& p);
void from_json(const json& j, std::shared_ptr<ColumnHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorMergeTableHandle : public JsonEncodedSubclass {};
void to_json(json& j, const std::shared_ptr<ConnectorMergeTableHandle>& p);
void from_json(const json& j, std::shared_ptr<ConnectorMergeTableHandle>& p);
} // namespace facebook::presto::protocol

namespace facebook::presto::protocol {
struct AbstractConnectorTableFunction {
  String schema = {};
  String name = {};
  List<std::shared_ptr<ArgumentSpecification>> arguments = {};
  std::shared_ptr<ReturnTypeSpecification> returnTypeSpecification = {};
};
void to_json(json& j, const AbstractConnectorTableFunction& p);
void from_json(const json& j, AbstractConnectorTableFunction& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SourceLocation {
  int line = {};
  int column = {};
};
void to_json(json& j, const SourceLocation& p);
void from_json(const json& j, SourceLocation& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct CallExpression : public RowExpression {
  String displayName = {};
  std::shared_ptr<FunctionHandle> functionHandle = {};
  Type returnType = {};
  List<std::shared_ptr<RowExpression>> arguments = {};

  CallExpression() noexcept;
};
void to_json(json& j, const CallExpression& p);
void from_json(const json& j, CallExpression& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class SortOrder {
  ASC_NULLS_FIRST,
  ASC_NULLS_LAST,
  DESC_NULLS_FIRST,
  DESC_NULLS_LAST
};
extern void to_json(json& j, const SortOrder& e);
extern void from_json(const json& j, SortOrder& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

struct VariableReferenceExpression : RowExpression {
  String name;
  Type type; // dependency

  VariableReferenceExpression() noexcept;
  explicit VariableReferenceExpression(const String& str) {
    _type = "variable";

    std::vector<std::string, std::allocator<std::string>> parts;

    folly::split("<", str, parts);
    name = parts[0];
    type = parts[1].substr(0, parts[1].length() - 1);
  }

  bool operator<(const VariableReferenceExpression& o) const {
    if (name == o.name) {
      return type < o.type;
    }

    return name < o.name;
  }
};

void to_json(json& j, const VariableReferenceExpression& p);
void from_json(const json& j, VariableReferenceExpression& p);

std::string json_map_key(
    const facebook::presto::protocol::VariableReferenceExpression& p);

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Ordering {
  VariableReferenceExpression variable = {};
  SortOrder sortOrder = {};
};
void to_json(json& j, const Ordering& p);
void from_json(const json& j, Ordering& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct OrderingScheme {
  List<Ordering> orderBy = {};
};
void to_json(json& j, const OrderingScheme& p);
void from_json(const json& j, OrderingScheme& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Aggregation {
  CallExpression call = {};
  std::shared_ptr<std::shared_ptr<RowExpression>> filter = {};
  std::shared_ptr<OrderingScheme> orderBy = {};
  bool distinct = {};
  std::shared_ptr<VariableReferenceExpression> mask = {};
  std::shared_ptr<FunctionHandle> functionHandle = {};
  List<std::shared_ptr<RowExpression>> arguments = {};
};
void to_json(json& j, const Aggregation& p);
void from_json(const json& j, Aggregation& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct AggregationFunctionMetadata {
  TypeSignature intermediateType = {};
  bool isOrderSensitive = {};
};
void to_json(json& j, const AggregationFunctionMetadata& p);
void from_json(const json& j, AggregationFunctionMetadata& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class AggregationNodeStep { PARTIAL, FINAL, INTERMEDIATE, SINGLE };
extern void to_json(json& j, const AggregationNodeStep& e);
extern void from_json(const json& j, AggregationNodeStep& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct GroupingSetDescriptor {
  List<VariableReferenceExpression> groupingKeys = {};
  int groupingSetCount = {};
  List<Integer> globalGroupingSets = {};
};
void to_json(json& j, const GroupingSetDescriptor& p);
void from_json(const json& j, GroupingSetDescriptor& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct AggregationNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  Map<VariableReferenceExpression, Aggregation> aggregations = {};
  GroupingSetDescriptor groupingSets = {};
  List<VariableReferenceExpression> preGroupedVariables = {};
  AggregationNodeStep step = {};
  std::shared_ptr<VariableReferenceExpression> hashVariable = {};
  std::shared_ptr<VariableReferenceExpression> groupIdVariable = {};
  std::shared_ptr<Integer> aggregationId = {};

  AggregationNode() noexcept;
};
void to_json(json& j, const AggregationNode& p);
void from_json(const json& j, AggregationNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct AllOrNoneValueSet : public ValueSet {
  Type type = {};
  bool all = {};

  AllOrNoneValueSet() noexcept;
};
void to_json(json& j, const AllOrNoneValueSet& p);
void from_json(const json& j, AllOrNoneValueSet& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorTableHandle : public JsonEncodedSubclass {
  static std::string serialize(ConnectorTableHandle& p) {
    VELOX_NYI("Serialization not implemented for ConnectorTableHandle");
  }
  static std::shared_ptr<ConnectorTableHandle> deserialize(
      const std::string& data,
      std::shared_ptr<ConnectorTableHandle> p) {
    VELOX_NYI("Deserialization not implemented for ConnectorTableHandle");
  }
};
void to_json(json& j, const std::shared_ptr<ConnectorTableHandle>& p);
void from_json(const json& j, std::shared_ptr<ConnectorTableHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorTransactionHandle : public JsonEncodedSubclass {
  static std::string serialize(ConnectorTransactionHandle& p) {
    VELOX_NYI("Serialization not implemented for ConnectorTransactionHandle");
  }
  static std::shared_ptr<ConnectorTransactionHandle> deserialize(
      const std::string& data,
      std::shared_ptr<ConnectorTransactionHandle> p) {
    VELOX_NYI("Deserialization not implemented for ConnectorTransactionHandle");
  }
};
void to_json(json& j, const std::shared_ptr<ConnectorTransactionHandle>& p);
void from_json(const json& j, std::shared_ptr<ConnectorTransactionHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct AnalyzeTableHandle {
  ConnectorId connectorId = {};
  std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
  std::shared_ptr<ConnectorTableHandle> connectorHandle = {};
};
void to_json(json& j, const AnalyzeTableHandle& p);
void from_json(const json& j, AnalyzeTableHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct AssignUniqueId : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  VariableReferenceExpression idVariable = {};

  AssignUniqueId() noexcept;
};
void to_json(json& j, const AssignUniqueId& p);
void from_json(const json& j, AssignUniqueId& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Assignments {
  Map<VariableReferenceExpression, std::shared_ptr<RowExpression>> assignments =
      {};
};
void to_json(json& j, const Assignments& p);
void from_json(const json& j, Assignments& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct BaseInputDistribution : public InputDistribution {
  List<VariableReferenceExpression> partitionBy = {};
  std::shared_ptr<OrderingScheme> orderingScheme = {};
  List<VariableReferenceExpression> inputVariables = {};

  BaseInputDistribution() noexcept;
};
void to_json(json& j, const BaseInputDistribution& p);
void from_json(const json& j, BaseInputDistribution& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class BufferType {
  PARTITIONED,
  BROADCAST,
  ARBITRARY,
  DISCARDING,
  SPOOLING
};
extern void to_json(json& j, const BufferType& e);
extern void from_json(const json& j, BufferType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct OutputBuffers {
  BufferType type = {};
  int64_t version = {};
  bool noMoreBufferIds = {};
  Map<OutputBufferId, Integer> buffers = {};
};
void to_json(json& j, const OutputBuffers& p);
void from_json(const json& j, OutputBuffers& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

std::ostream& operator<<(std::ostream& os, const DataSize& d);

void to_json(nlohmann::json& j, const DataSize& p);
void from_json(const nlohmann::json& j, DataSize& p);

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

std::ostream& operator<<(std::ostream& os, const Duration& d);

void to_json(json& j, const Duration& p);
void from_json(const json& j, Duration& p);

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ResourceEstimates {
  std::shared_ptr<Duration> executionTime = {};
  std::shared_ptr<Duration> cpuTime = {};
  std::shared_ptr<DataSize> peakMemory = {};
  std::shared_ptr<DataSize> peakTaskMemory = {};
};
void to_json(json& j, const ResourceEstimates& p);
void from_json(const json& j, ResourceEstimates& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class SelectedRoleType { ROLE, ALL, NONE };
extern void to_json(json& j, const SelectedRoleType& e);
extern void from_json(const json& j, SelectedRoleType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SelectedRole {
  SelectedRoleType type = {};
  std::shared_ptr<String> role = {};
};
void to_json(json& j, const SelectedRole& p);
void from_json(const json& j, SelectedRole& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Parameter {
  String name = {};
  TypeSignature type = {};
};
void to_json(json& j, const Parameter& p);
void from_json(const json& j, Parameter& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class Determinism {
  DETERMINISTIC,
  NOT_DETERMINISTIC,
};
extern void to_json(json& j, const Determinism& e);
extern void from_json(const json& j, Determinism& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Language {
  String language = {};
};
void to_json(json& j, const Language& p);
void from_json(const json& j, Language& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class NullCallClause { RETURNS_NULL_ON_NULL_INPUT, CALLED_ON_NULL_INPUT };
extern void to_json(json& j, const NullCallClause& e);
extern void from_json(const json& j, NullCallClause& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RoutineCharacteristics {
  std::shared_ptr<Language> language = {};
  std::shared_ptr<Determinism> determinism = {};
  std::shared_ptr<NullCallClause> nullCallClause = {};
};
void to_json(json& j, const RoutineCharacteristics& p);
void from_json(const json& j, RoutineCharacteristics& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class FunctionKind { SCALAR, AGGREGATE, WINDOW };
extern void to_json(json& j, const FunctionKind& e);
extern void from_json(const json& j, FunctionKind& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct LongVariableConstraint {
  String name = {};
  String expression = {};
};
void to_json(json& j, const LongVariableConstraint& p);
void from_json(const json& j, LongVariableConstraint& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

struct TypeVariableConstraint {
  String name = {};
  bool comparableRequired = {};
  bool orderableRequired = {};
  String variadicBound = {};
  bool nonDecimalNumericRequired = {};
  String boundedBy = {};
};
void to_json(json& j, const TypeVariableConstraint& p);
void from_json(const json& j, TypeVariableConstraint& p);

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Signature {
  QualifiedObjectName name = {};
  FunctionKind kind = {};
  List<TypeVariableConstraint> typeVariableConstraints = {};
  List<LongVariableConstraint> longVariableConstraints = {};
  TypeSignature returnType = {};
  List<TypeSignature> argumentTypes = {};
  bool variableArity = {};
};
void to_json(json& j, const Signature& p);
void from_json(const json& j, Signature& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SqlInvokedFunction {
  List<Parameter> parameters = {};
  String description = {};
  RoutineCharacteristics routineCharacteristics = {};
  String body = {};
  bool variableArity = {};
  Signature signature = {};
  SqlFunctionId functionId = {};
};
void to_json(json& j, const SqlInvokedFunction& p);
void from_json(const json& j, SqlInvokedFunction& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SessionRepresentation {
  String queryId = {};
  std::shared_ptr<TransactionId> transactionId = {};
  bool clientTransactionSupport = {};
  String user = {};
  std::shared_ptr<String> principal = {};
  std::shared_ptr<String> source = {};
  std::shared_ptr<String> catalog = {};
  std::shared_ptr<String> schema = {};
  std::shared_ptr<String> traceToken = {};
  TimeZoneKey timeZoneKey = {};
  Locale locale = {};
  std::shared_ptr<String> remoteUserAddress = {};
  std::shared_ptr<String> userAgent = {};
  std::shared_ptr<String> clientInfo = {};
  List<String> clientTags = {};
  ResourceEstimates resourceEstimates = {};
  int64_t startTime = {};
  Map<String, String> systemProperties = {};
  Map<ConnectorId, Map<String, String>> catalogProperties = {};
  Map<String, Map<String, String>> unprocessedCatalogProperties = {};
  Map<String, SelectedRole> roles = {};
  Map<String, String> preparedStatements = {};
  Map<SqlFunctionId, SqlInvokedFunction> sessionFunctions = {};
};
void to_json(json& j, const SessionRepresentation& p);
void from_json(const json& j, SessionRepresentation& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TableWriteInfo {
  std::shared_ptr<ExecutionWriterTarget> writerTarget = {};
  std::shared_ptr<AnalyzeTableHandle> analyzeTableHandle = {};
};
void to_json(json& j, const TableWriteInfo& p);
void from_json(const json& j, TableWriteInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

struct Lifespan {
  bool isgroup = false;
  int groupid = 0;

  bool operator<(const Lifespan& o) const {
    return groupid < o.groupid;
  }
};

void to_json(json& j, const Lifespan& p);
void from_json(const json& j, Lifespan& p);

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorSplit : public JsonEncodedSubclass {
  static std::string serialize(ConnectorSplit& p) {
    VELOX_NYI("Serialization not implemented for ConnectorSplit");
  }
  static std::shared_ptr<ConnectorSplit> deserialize(
      const std::string& data,
      std::shared_ptr<ConnectorSplit> p) {
    VELOX_NYI("Deserialization not implemented for ConnectorSplit");
  }
};
void to_json(json& j, const std::shared_ptr<ConnectorSplit>& p);
void from_json(const json& j, std::shared_ptr<ConnectorSplit>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SplitContext {
  bool cacheable = {};
};
void to_json(json& j, const SplitContext& p);
void from_json(const json& j, SplitContext& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Split {
  ConnectorId connectorId = {};
  std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
  std::shared_ptr<ConnectorSplit> connectorSplit = {};
  Lifespan lifespan = {};
  SplitContext splitContext = {};
};
void to_json(json& j, const Split& p);
void from_json(const json& j, Split& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

struct ScheduledSplit {
  int64_t sequenceId = {};
  PlanNodeId planNodeId = {}; // dependency
  Split split = {};

  bool operator<(const ScheduledSplit& o) const {
    return sequenceId < o.sequenceId;
  }
};

void to_json(json& j, const ScheduledSplit& p);
void from_json(const json& j, ScheduledSplit& p);

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TaskSource {
  PlanNodeId planNodeId = {};
  List<ScheduledSplit> splits = {};
  List<Lifespan> noMoreSplitsForLifespan = {};
  bool noMoreSplits = {};
};
void to_json(json& j, const TaskSource& p);
void from_json(const json& j, TaskSource& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TaskUpdateRequest {
  SessionRepresentation session = {};
  Map<String, String> extraCredentials = {};
  std::shared_ptr<String> fragment = {};
  List<TaskSource> sources = {};
  OutputBuffers outputIds = {};
  std::shared_ptr<TableWriteInfo> tableWriteInfo = {};
};
void to_json(json& j, const TaskUpdateRequest& p);
void from_json(const json& j, TaskUpdateRequest& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct BatchTaskUpdateRequest {
  TaskUpdateRequest taskUpdateRequest = {};
  std::shared_ptr<String> shuffleWriteInfo = {};
  std::shared_ptr<String> broadcastBasePath = {};
};
void to_json(json& j, const BatchTaskUpdateRequest& p);
void from_json(const json& j, BatchTaskUpdateRequest& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct PageBufferInfo {
  int partition = {};
  int64_t bufferedPages = {};
  int64_t bufferedBytes = {};
  int64_t rowsAdded = {};
  int64_t pagesAdded = {};
};
void to_json(json& j, const PageBufferInfo& p);
void from_json(const json& j, PageBufferInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct BufferInfo {
  OutputBufferId bufferId = {};
  bool finished = {};
  int bufferedPages = {};
  int64_t pagesSent = {};
  PageBufferInfo pageBufferInfo = {};
};
void to_json(json& j, const BufferInfo& p);
void from_json(const json& j, BufferInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class BuiltInFunctionKind { ENGINE, PLUGIN, WORKER };
extern void to_json(json& j, const BuiltInFunctionKind& e);
extern void from_json(const json& j, BuiltInFunctionKind& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct BuiltInFunctionHandle : public FunctionHandle {
  Signature signature = {};
  BuiltInFunctionKind builtInFunctionKind = {};

  BuiltInFunctionHandle() noexcept;
};
void to_json(json& j, const BuiltInFunctionHandle& p);
void from_json(const json& j, BuiltInFunctionHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class CacheQuotaScope { GLOBAL, SCHEMA, TABLE, PARTITION };
extern void to_json(json& j, const CacheQuotaScope& e);
extern void from_json(const json& j, CacheQuotaScope& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct CacheQuotaRequirement {
  CacheQuotaScope cacheQuotaScope = {};
  std::shared_ptr<DataSize> quota = {};
};
void to_json(json& j, const CacheQuotaRequirement& p);
void from_json(const json& j, CacheQuotaRequirement& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class ExchangeEncoding { COLUMNAR, ROW_WISE };
extern void to_json(json& j, const ExchangeEncoding& e);
extern void from_json(const json& j, ExchangeEncoding& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct PartitioningHandle {
  std::shared_ptr<ConnectorId> connectorId = {};
  std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
  std::shared_ptr<ConnectorPartitioningHandle> connectorHandle = {};
};
void to_json(json& j, const PartitioningHandle& p);
void from_json(const json& j, PartitioningHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Partitioning {
  PartitioningHandle handle = {};
  List<std::shared_ptr<RowExpression>> arguments = {};
};
void to_json(json& j, const Partitioning& p);
void from_json(const json& j, Partitioning& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct PartitioningScheme {
  Partitioning partitioning = {};
  List<VariableReferenceExpression> outputLayout = {};
  std::shared_ptr<VariableReferenceExpression> hashColumn = {};
  bool replicateNullsAndAny = {};
  bool scaleWriters = {};
  ExchangeEncoding encoding = {};
  std::shared_ptr<List<int>> bucketToPartition = {};
};
void to_json(json& j, const PartitioningScheme& p);
void from_json(const json& j, PartitioningScheme& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct CallDistributedProcedureNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  VariableReferenceExpression rowCountVariable = {};
  VariableReferenceExpression fragmentVariable = {};
  VariableReferenceExpression tableCommitContextVariable = {};
  List<VariableReferenceExpression> columns = {};
  List<String> columnNames = {};
  List<VariableReferenceExpression> notNullColumnVariables = {};
  std::shared_ptr<PartitioningScheme> partitioningScheme = {};

  CallDistributedProcedureNode() noexcept;
};
void to_json(json& j, const CallDistributedProcedureNode& p);
void from_json(const json& j, CallDistributedProcedureNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

struct Column {
  String name;
  String type;

  Column() = default;
  explicit Column(const String& str) {
    name = str;
  }
};

void to_json(json& j, const Column& p);
void from_json(const json& j, Column& p);

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorTableMetadata {
  QualifiedObjectName functionName = {};
  Map<String, std::shared_ptr<Argument>> arguments = {};
};
void to_json(json& j, const ConnectorTableMetadata& p);
void from_json(const json& j, ConnectorTableMetadata& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

struct Block {
  std::string data;
};

void to_json(json& j, const Block& p);

void from_json(const json& j, Block& p);

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConstantExpression : public RowExpression {
  Block valueBlock = {};
  Type type = {};

  ConstantExpression() noexcept;
};
void to_json(json& j, const ConstantExpression& p);
void from_json(const json& j, ConstantExpression& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorOutputTableHandle : public JsonEncodedSubclass {
  static std::string serialize(ConnectorOutputTableHandle& p) {
    VELOX_NYI("Serialization not implemented for ConnectorOutputTableHandle");
  }
  static std::shared_ptr<ConnectorOutputTableHandle> deserialize(
      const std::string& data,
      std::shared_ptr<ConnectorOutputTableHandle> p) {
    VELOX_NYI("Deserialization not implemented for ConnectorOutputTableHandle");
  }
};
void to_json(json& j, const std::shared_ptr<ConnectorOutputTableHandle>& p);
void from_json(const json& j, std::shared_ptr<ConnectorOutputTableHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct OutputTableHandle {
  ConnectorId connectorId = {};
  std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
  std::shared_ptr<ConnectorOutputTableHandle> connectorHandle = {};
};
void to_json(json& j, const OutputTableHandle& p);
void from_json(const json& j, OutputTableHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SchemaTableName {
  String schema = {};
  String table = {};
};
void to_json(json& j, const SchemaTableName& p);
void from_json(const json& j, SchemaTableName& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct CreateHandle : public ExecutionWriterTarget {
  OutputTableHandle handle = {};
  SchemaTableName schemaTableName = {};

  CreateHandle() noexcept;
};
void to_json(json& j, const CreateHandle& p);
void from_json(const json& j, CreateHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DataOrganizationSpecification {
  List<VariableReferenceExpression> partitionBy = {};
  std::shared_ptr<OrderingScheme> orderingScheme = {};
};
void to_json(json& j, const DataOrganizationSpecification& p);
void from_json(const json& j, DataOrganizationSpecification& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorDeleteTableHandle : public JsonEncodedSubclass {
  static std::string serialize(ConnectorDeleteTableHandle& p) {
    VELOX_NYI("Serialization not implemented for ConnectorDeleteTableHandle");
  }
  static std::shared_ptr<ConnectorDeleteTableHandle> deserialize(
      const std::string& data,
      std::shared_ptr<ConnectorDeleteTableHandle> p) {
    VELOX_NYI("Deserialization not implemented for ConnectorDeleteTableHandle");
  }
};
void to_json(json& j, const std::shared_ptr<ConnectorDeleteTableHandle>& p);
void from_json(const json& j, std::shared_ptr<ConnectorDeleteTableHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DeleteTableHandle {
  ConnectorId connectorId = {};
  std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
  std::shared_ptr<ConnectorDeleteTableHandle> connectorHandle = {};
};
void to_json(json& j, const DeleteTableHandle& p);
void from_json(const json& j, DeleteTableHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DeleteHandle : public ExecutionWriterTarget {
  DeleteTableHandle handle = {};
  SchemaTableName schemaTableName = {};

  DeleteHandle() noexcept;
};
void to_json(json& j, const DeleteHandle& p);
void from_json(const json& j, DeleteHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DeleteNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  std::shared_ptr<VariableReferenceExpression> rowId = {};
  List<VariableReferenceExpression> outputVariables = {};
  std::shared_ptr<InputDistribution> inputDistribution = {};

  DeleteNode() noexcept;
};
void to_json(json& j, const DeleteNode& p);
void from_json(const json& j, DeleteNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Field {
  std::shared_ptr<String> name = {};
  std::shared_ptr<Type> type = {};
};
void to_json(json& j, const Field& p);
void from_json(const json& j, Field& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Descriptor {
  List<Field> fields = {};
};
void to_json(json& j, const Descriptor& p);
void from_json(const json& j, Descriptor& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DescribedTableReturnTypeSpecification : public ReturnTypeSpecification {
  Descriptor descriptor = {};

  DescribedTableReturnTypeSpecification() noexcept;
};
void to_json(json& j, const DescribedTableReturnTypeSpecification& p);
void from_json(const json& j, DescribedTableReturnTypeSpecification& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DescriptorArgument : public Argument {
  std::shared_ptr<Descriptor> descriptor = {};

  DescriptorArgument() noexcept;
};
void to_json(json& j, const DescriptorArgument& p);
void from_json(const json& j, DescriptorArgument& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DescriptorArgumentSpecification : public ArgumentSpecification {
  String name = {};
  bool required = {};
  Descriptor defaultValue = {};

  DescriptorArgumentSpecification() noexcept;
};
void to_json(json& j, const DescriptorArgumentSpecification& p);
void from_json(const json& j, DescriptorArgumentSpecification& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DistinctLimitNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  int64_t limit = {};
  bool partial = {};
  List<VariableReferenceExpression> distinctVariables = {};
  std::shared_ptr<VariableReferenceExpression> hashVariable = {};
  int timeoutMillis = {};

  DistinctLimitNode() noexcept;
};
void to_json(json& j, const DistinctLimitNode& p);
void from_json(const json& j, DistinctLimitNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorDistributedProcedureHandle : public JsonEncodedSubclass {};
void to_json(
    json& j,
    const std::shared_ptr<ConnectorDistributedProcedureHandle>& p);
void from_json(
    const json& j,
    std::shared_ptr<ConnectorDistributedProcedureHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DistributedProcedureHandle {
  ConnectorId connectorId = {};
  std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
  std::shared_ptr<ConnectorDistributedProcedureHandle> connectorHandle = {};
};
void to_json(json& j, const DistributedProcedureHandle& p);
void from_json(const json& j, DistributedProcedureHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DistributionSnapshot {
  double maxError = {};
  double count = {};
  double total = {};
  int64_t p01 = {};
  int64_t p05 = {};
  int64_t p10 = {};
  int64_t p25 = {};
  int64_t p50 = {};
  int64_t p75 = {};
  int64_t p90 = {};
  int64_t p95 = {};
  int64_t p99 = {};
  int64_t min = {};
  int64_t max = {};
  double avg = {};
};
void to_json(json& j, const DistributionSnapshot& p);
void from_json(const json& j, DistributionSnapshot& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Domain {
  std::shared_ptr<ValueSet> values = {};
  bool nullAllowed = {};
};
void to_json(json& j, const Domain& p);
void from_json(const json& j, Domain& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class BlockedReason { WAITING_FOR_MEMORY };
extern void to_json(json& j, const BlockedReason& e);
extern void from_json(const json& j, BlockedReason& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DynamicFilterStats {
  List<PlanNodeId> producerNodeIds = {};
};
void to_json(json& j, const DynamicFilterStats& p);
void from_json(const json& j, DynamicFilterStats& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct OperatorInfo {};
void to_json(json& j, const OperatorInfo& p);
void from_json(const json& j, OperatorInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct OperatorStats {
  int stageId = {};
  int stageExecutionId = {};
  int pipelineId = {};
  int operatorId = {};
  PlanNodeId planNodeId = {};
  String operatorType = {};
  int64_t totalDrivers = {};
  int64_t isBlockedCalls = {};
  Duration isBlockedWall = {};
  Duration isBlockedCpu = {};
  int64_t isBlockedAllocationInBytes = {};
  int64_t addInputCalls = {};
  Duration addInputWall = {};
  Duration addInputCpu = {};
  int64_t addInputAllocationInBytes = {};
  int64_t rawInputDataSizeInBytes = {};
  int64_t rawInputPositions = {};
  int64_t inputDataSizeInBytes = {};
  int64_t inputPositions = {};
  double sumSquaredInputPositions = {};
  int64_t getOutputCalls = {};
  Duration getOutputWall = {};
  Duration getOutputCpu = {};
  int64_t getOutputAllocationInBytes = {};
  int64_t outputDataSizeInBytes = {};
  int64_t outputPositions = {};
  int64_t physicalWrittenDataSizeInBytes = {};
  Duration additionalCpu = {};
  Duration blockedWall = {};
  int64_t finishCalls = {};
  Duration finishWall = {};
  Duration finishCpu = {};
  int64_t finishAllocationInBytes = {};
  int64_t userMemoryReservationInBytes = {};
  int64_t revocableMemoryReservationInBytes = {};
  int64_t systemMemoryReservationInBytes = {};
  int64_t peakUserMemoryReservationInBytes = {};
  int64_t peakSystemMemoryReservationInBytes = {};
  int64_t peakTotalMemoryReservationInBytes = {};
  int64_t spilledDataSizeInBytes = {};
  std::shared_ptr<BlockedReason> blockedReason = {};
  OperatorInfo info = {};
  RuntimeStats runtimeStats = {};
  DynamicFilterStats dynamicFilterStats = {};
  int64_t nullJoinBuildKeyCount = {};
  int64_t joinBuildKeyCount = {};
  int64_t nullJoinProbeKeyCount = {};
  int64_t joinProbeKeyCount = {};
};
void to_json(json& j, const OperatorStats& p);
void from_json(const json& j, OperatorStats& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct DriverStats {
  Lifespan lifespan = {};
  int64_t createTimeInMillis = {};
  int64_t startTimeInMillis = {};
  int64_t endTimeInMillis = {};
  Duration queuedTime = {};
  Duration elapsedTime = {};
  int64_t userMemoryReservationInBytes = {};
  int64_t revocableMemoryReservationInBytes = {};
  int64_t systemMemoryReservationInBytes = {};
  Duration totalScheduledTime = {};
  Duration totalCpuTime = {};
  Duration totalBlockedTime = {};
  bool fullyBlocked = {};
  List<BlockedReason> blockedReasons = {};
  int64_t totalAllocationInBytes = {};
  int64_t rawInputDataSizeInBytes = {};
  int64_t rawInputPositions = {};
  Duration rawInputReadTime = {};
  int64_t processedInputDataSizeInBytes = {};
  int64_t processedInputPositions = {};
  int64_t outputDataSizeInBytes = {};
  int64_t outputPositions = {};
  int64_t physicalWrittenDataSizeInBytes = {};
  List<OperatorStats> operatorStats = {};
};
void to_json(json& j, const DriverStats& p);
void from_json(const json& j, DriverStats& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct EmptySplit : public ConnectorSplit {
  ConnectorId connectorId = {};

  EmptySplit() noexcept;
};
void to_json(json& j, const EmptySplit& p);
void from_json(const json& j, EmptySplit& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct EnforceSingleRowNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};

  EnforceSingleRowNode() noexcept;
};
void to_json(json& j, const EnforceSingleRowNode& p);
void from_json(const json& j, EnforceSingleRowNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

class ValueEntry {
 public:
  Type type;
  std::shared_ptr<Block> block;
};

void to_json(json& j, const ValueEntry& p);
void from_json(const json& j, ValueEntry& p);

} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct EquatableValueSet : public ValueSet {
  Type type = {};
  bool whiteList = {};
  List<ValueEntry> entries = {};

  EquatableValueSet() noexcept;
};
void to_json(json& j, const EquatableValueSet& p);
void from_json(const json& j, EquatableValueSet& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct EquiJoinClause {
  VariableReferenceExpression left = {};
  VariableReferenceExpression right = {};
};
void to_json(json& j, const EquiJoinClause& p);
void from_json(const json& j, EquiJoinClause& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class ErrorType {
  USER_ERROR,
  INTERNAL_ERROR,
  INSUFFICIENT_RESOURCES,
  EXTERNAL
};
extern void to_json(json& j, const ErrorType& e);
extern void from_json(const json& j, ErrorType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ErrorCode {
  int code = {};
  String name = {};
  ErrorType type = {};
  bool retriable = {};
};
void to_json(json& j, const ErrorCode& p);
void from_json(const json& j, ErrorCode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ErrorLocation {
  int lineNumber = {};
  int columnNumber = {};
};
void to_json(json& j, const ErrorLocation& p);
void from_json(const json& j, ErrorLocation& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class ExchangeNodeScope { LOCAL, REMOTE_STREAMING, REMOTE_MATERIALIZED };
extern void to_json(json& j, const ExchangeNodeScope& e);
extern void from_json(const json& j, ExchangeNodeScope& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class ExchangeNodeType {
  GATHER,
  REPARTITION,
  REPLICATE,
};
extern void to_json(json& j, const ExchangeNodeType& e);
extern void from_json(const json& j, ExchangeNodeType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ExchangeNode : public PlanNode {
  ExchangeNodeType type = {};
  ExchangeNodeScope scope = {};
  PartitioningScheme partitioningScheme = {};
  List<std::shared_ptr<PlanNode>> sources = {};
  List<List<VariableReferenceExpression>> inputs = {};
  bool ensureSourceOrdering = {};
  std::shared_ptr<OrderingScheme> orderingScheme = {};

  ExchangeNode() noexcept;
};
void to_json(json& j, const ExchangeNode& p);
void from_json(const json& j, ExchangeNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ExecuteProcedureHandle : public ExecutionWriterTarget {
  DistributedProcedureHandle handle = {};
  SchemaTableName schemaTableName = {};
  QualifiedObjectName procedureName = {};

  ExecuteProcedureHandle() noexcept;
};
void to_json(json& j, const ExecuteProcedureHandle& p);
void from_json(const json& j, ExecuteProcedureHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class ErrorCause {
  UNKNOWN,
  LOW_PARTITION_COUNT,
  EXCEEDS_BROADCAST_MEMORY_LIMIT
};
extern void to_json(json& j, const ErrorCause& e);
extern void from_json(const json& j, ErrorCause& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ExecutionFailureInfo {
  String type = {};
  String message = {};
  std::shared_ptr<ExecutionFailureInfo> cause = {};
  List<ExecutionFailureInfo> suppressed = {};
  List<String> stack = {};
  ErrorLocation errorLocation = {};
  ErrorCode errorCode = {};
  HostAddress remoteHost = {};
  ErrorCause errorCause = {};
};
void to_json(json& j, const ExecutionFailureInfo& p);
void from_json(const json& j, ExecutionFailureInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct FilterNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  std::shared_ptr<RowExpression> predicate = {};

  FilterNode() noexcept;
};
void to_json(json& j, const FilterNode& p);
void from_json(const json& j, FilterNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class BoundType {
  UNBOUNDED_PRECEDING,
  PRECEDING,
  CURRENT_ROW,
  FOLLOWING,
  UNBOUNDED_FOLLOWING
};
extern void to_json(json& j, const BoundType& e);
extern void from_json(const json& j, BoundType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class WindowType {
  RANGE,
  ROWS,
  GROUPS,
};
extern void to_json(json& j, const WindowType& e);
extern void from_json(const json& j, WindowType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Frame {
  WindowType type = {};
  BoundType startType = {};
  std::shared_ptr<VariableReferenceExpression> startValue = {};
  std::shared_ptr<VariableReferenceExpression>
      sortKeyCoercedForFrameStartComparison = {};
  BoundType endType = {};
  std::shared_ptr<VariableReferenceExpression> endValue = {};
  std::shared_ptr<VariableReferenceExpression>
      sortKeyCoercedForFrameEndComparison = {};
  std::shared_ptr<String> originalStartValue = {};
  std::shared_ptr<String> originalEndValue = {};
};
void to_json(json& j, const Frame& p);
void from_json(const json& j, Frame& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Function {
  CallExpression functionCall = {};
  Frame frame = {};
  bool ignoreNulls = {};
};
void to_json(json& j, const Function& p);
void from_json(const json& j, Function& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct GenericTableReturnTypeSpecification : public ReturnTypeSpecification {
  String returnType = {};

  GenericTableReturnTypeSpecification() noexcept;
};
void to_json(json& j, const GenericTableReturnTypeSpecification& p);
void from_json(const json& j, GenericTableReturnTypeSpecification& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct GroupIdNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  List<List<VariableReferenceExpression>> groupingSets = {};
  Map<VariableReferenceExpression, VariableReferenceExpression>
      groupingColumns = {};
  List<VariableReferenceExpression> aggregationArguments = {};
  VariableReferenceExpression groupIdVariable = {};

  GroupIdNode() noexcept;
};
void to_json(json& j, const GroupIdNode& p);
void from_json(const json& j, GroupIdNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct IndexHandle {
  ConnectorId connectorId = {};
  std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
  std::shared_ptr<ConnectorIndexHandle> connectorHandle = {};
};
void to_json(json& j, const IndexHandle& p);
void from_json(const json& j, IndexHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class JoinType { INNER, LEFT, RIGHT, FULL, SOURCE_OUTER };
extern void to_json(json& j, const JoinType& e);
extern void from_json(const json& j, JoinType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct IndexJoinNode : public PlanNode {
  JoinType type = {};
  std::shared_ptr<PlanNode> probeSource = {};
  std::shared_ptr<PlanNode> indexSource = {};
  List<EquiJoinClause> criteria = {};
  std::shared_ptr<std::shared_ptr<RowExpression>> filter = {};
  std::shared_ptr<VariableReferenceExpression> probeHashVariable = {};
  std::shared_ptr<VariableReferenceExpression> indexHashVariable = {};
  List<VariableReferenceExpression> lookupVariables = {};

  IndexJoinNode() noexcept;
};
void to_json(json& j, const IndexJoinNode& p);
void from_json(const json& j, IndexJoinNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorTableLayoutHandle : public JsonEncodedSubclass {
  static std::string serialize(ConnectorTableLayoutHandle& p) {
    VELOX_NYI("Serialization not implemented for ConnectorTableLayoutHandle");
  }
  static std::shared_ptr<ConnectorTableLayoutHandle> deserialize(
      const std::string& data,
      std::shared_ptr<ConnectorTableLayoutHandle> p) {
    VELOX_NYI("Deserialization not implemented for ConnectorTableLayoutHandle");
  }
};
void to_json(json& j, const std::shared_ptr<ConnectorTableLayoutHandle>& p);
void from_json(const json& j, std::shared_ptr<ConnectorTableLayoutHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TableHandle {
  ConnectorId connectorId = {};
  std::shared_ptr<ConnectorTableHandle> connectorHandle = {};
  std::shared_ptr<ConnectorTransactionHandle> transaction = {};
  std::shared_ptr<ConnectorTableLayoutHandle> connectorTableLayout = {};
};
void to_json(json& j, const TableHandle& p);
void from_json(const json& j, TableHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {

template <typename T>
struct pointerDerefCompare {
  bool operator()(const std::shared_ptr<T>& a, const std::shared_ptr<T>& b)
      const {
    return *a < *b;
  }
};

template <typename T>
struct TupleDomain {
  std::shared_ptr<Map<T, Domain>> domains;
};

template <typename T>
struct TupleDomain<std::shared_ptr<T>> {
  std::shared_ptr<std::map<std::shared_ptr<T>, Domain, pointerDerefCompare<T>>>
      domains;
};

template <class T>
struct ColumnDomain {
  T column;
  Domain domain; // dependency
};

} // namespace facebook::presto::protocol

namespace nlohmann {

template <typename T>
struct adl_serializer<facebook::presto::protocol::ColumnDomain<T>> {
  static void to_json(
      json& j,
      const facebook::presto::protocol::ColumnDomain<T>& p) {
    facebook::presto::protocol::to_json_key(
        j, "column", p.column, "ColumnDomain", "T", "column");
    facebook::presto::protocol::to_json_key(
        j, "domain", p.domain, "ColumnDomain", "Domain", "domain");
  }

  static void from_json(
      const json& j,
      facebook::presto::protocol::ColumnDomain<T>& p) {
    facebook::presto::protocol::from_json_key(
        j, "column", p.column, "ColumnDomain", "T", "column");
    facebook::presto::protocol::from_json_key(
        j, "domain", p.domain, "ColumnDomain", "Domain", "domain");
  }
};

template <typename T>
struct adl_serializer<facebook::presto::protocol::TupleDomain<T>> {
  static void to_json(
      json& j,
      const facebook::presto::protocol::TupleDomain<T>& tup) {
    facebook::presto::protocol::List<
        facebook::presto::protocol::ColumnDomain<T>>
        list;
    if (tup.domains != nullptr) {
      for (auto& el : *tup.domains) {
        facebook::presto::protocol::ColumnDomain<T> domain;
        domain.column = el.first;
        domain.domain = el.second;
        list.push_back(domain);
      }
    }

    j["columnDomains"] = list;
  }

  static void from_json(
      const json& j,
      facebook::presto::protocol::TupleDomain<T>& tup) {
    if (j.count("columnDomains") != 0U) {
      std::shared_ptr<facebook::presto::protocol::
                          Map<T, facebook::presto::protocol::Domain>>
          map = std::make_shared<
              std::map<T, facebook::presto::protocol::Domain>>();

      facebook::presto::protocol::List<
          facebook::presto::protocol::ColumnDomain<T>>
          list = j.at("columnDomains");
      for (const facebook::presto::protocol::ColumnDomain<T>& value : list) {
        map->insert(std::make_pair(T(value.column), value.domain));
      }
      tup.domains = map;
    }
  }
};

template <typename T>
struct adl_serializer<
    facebook::presto::protocol::TupleDomain<std::shared_ptr<T>>> {
  static void to_json(
      json& j,
      const facebook::presto::protocol::TupleDomain<std::shared_ptr<T>>& tup) {
    facebook::presto::protocol::List<
        facebook::presto::protocol::ColumnDomain<std::shared_ptr<T>>>
        list;
    if (tup.domains != nullptr) {
      for (auto& el : *tup.domains) {
        facebook::presto::protocol::ColumnDomain<std::shared_ptr<T>> domain;
        domain.column = el.first;
        domain.domain = el.second;
        list.push_back(domain);
      }
    }

    j["columnDomains"] = list;
  }

  static void from_json(
      const json& j,
      facebook::presto::protocol::TupleDomain<std::shared_ptr<T>>& tup) {
    if (j.count("columnDomains") != 0U) {
      auto map = std::make_shared<std::map<
          std::shared_ptr<T>,
          facebook::presto::protocol::Domain,
          facebook::presto::protocol::pointerDerefCompare<T>>>();

      facebook::presto::protocol::List<
          facebook::presto::protocol::ColumnDomain<std::shared_ptr<T>>>
          list = j.at("columnDomains");
      for (const facebook::presto::protocol::ColumnDomain<std::shared_ptr<T>>&
               value : list) {
        map->insert(
            std::make_pair(std::shared_ptr<T>(value.column), value.domain));
      }
      tup.domains = map;
    }
  }
};

} // namespace nlohmann
namespace facebook::presto::protocol {
struct IndexSourceNode : public PlanNode {
  IndexHandle indexHandle = {};
  TableHandle tableHandle = {};
  List<VariableReferenceExpression> lookupVariables = {};
  List<VariableReferenceExpression> outputVariables = {};
  Map<VariableReferenceExpression, std::shared_ptr<ColumnHandle>> assignments =
      {};
  TupleDomain<std::shared_ptr<ColumnHandle>> currentConstraint = {};

  IndexSourceNode() noexcept;
};
void to_json(json& j, const IndexSourceNode& p);
void from_json(const json& j, IndexSourceNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ConnectorInsertTableHandle : public JsonEncodedSubclass {
  static std::string serialize(ConnectorInsertTableHandle& p) {
    VELOX_NYI("Serialization not implemented for ConnectorInsertTableHandle");
  }
  static std::shared_ptr<ConnectorInsertTableHandle> deserialize(
      const std::string& data,
      std::shared_ptr<ConnectorInsertTableHandle> p) {
    VELOX_NYI("Deserialization not implemented for ConnectorInsertTableHandle");
  }
};
void to_json(json& j, const std::shared_ptr<ConnectorInsertTableHandle>& p);
void from_json(const json& j, std::shared_ptr<ConnectorInsertTableHandle>& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct InsertTableHandle {
  ConnectorId connectorId = {};
  std::shared_ptr<ConnectorTransactionHandle> transactionHandle = {};
  std::shared_ptr<ConnectorInsertTableHandle> connectorHandle = {};
};
void to_json(json& j, const InsertTableHandle& p);
void from_json(const json& j, InsertTableHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct InsertHandle : public ExecutionWriterTarget {
  InsertTableHandle handle = {};
  SchemaTableName schemaTableName = {};

  InsertHandle() noexcept;
};
void to_json(json& j, const InsertHandle& p);
void from_json(const json& j, InsertHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class JoinDistributionType { PARTITIONED, REPLICATED };
extern void to_json(json& j, const JoinDistributionType& e);
extern void from_json(const json& j, JoinDistributionType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct JoinNode : public PlanNode {
  JoinType type = {};
  std::shared_ptr<PlanNode> left = {};
  std::shared_ptr<PlanNode> right = {};
  List<EquiJoinClause> criteria = {};
  List<VariableReferenceExpression> outputVariables = {};
  std::shared_ptr<std::shared_ptr<RowExpression>> filter = {};
  std::shared_ptr<VariableReferenceExpression> leftHashVariable = {};
  std::shared_ptr<VariableReferenceExpression> rightHashVariable = {};
  std::shared_ptr<JoinDistributionType> distributionType = {};
  Map<String, VariableReferenceExpression> dynamicFilters = {};

  JoinNode() noexcept;
};
void to_json(json& j, const JoinNode& p);
void from_json(const json& j, JoinNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct JoinNodeStatsEstimate {
  double nullJoinBuildKeyCount = {};
  double joinBuildKeyCount = {};
  double nullJoinProbeKeyCount = {};
  double joinProbeKeyCount = {};
};
void to_json(json& j, const JoinNodeStatsEstimate& p);
void from_json(const json& j, JoinNodeStatsEstimate& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct JsonBasedTableFunctionMetadata {
  QualifiedObjectName functionName = {};
  List<std::shared_ptr<ArgumentSpecification>> arguments = {};
  std::shared_ptr<ReturnTypeSpecification> returnTypeSpecification = {};
};
void to_json(json& j, const JsonBasedTableFunctionMetadata& p);
void from_json(const json& j, JsonBasedTableFunctionMetadata& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct JsonBasedUdfFunctionMetadata {
  String docString = {};
  FunctionKind functionKind = {};
  TypeSignature outputType = {};
  List<TypeSignature> paramTypes = {};
  String schema = {};
  bool variableArity = {};
  RoutineCharacteristics routineCharacteristics = {};
  std::shared_ptr<AggregationFunctionMetadata> aggregateMetadata = {};
  std::shared_ptr<SqlFunctionId> functionId = {};
  std::shared_ptr<String> version = {};
  std::shared_ptr<List<TypeVariableConstraint>> typeVariableConstraints = {};
  std::shared_ptr<List<LongVariableConstraint>> longVariableConstraints = {};
  std::shared_ptr<URI> executionEndpoint = {};
};
void to_json(json& j, const JsonBasedUdfFunctionMetadata& p);
void from_json(const json& j, JsonBasedUdfFunctionMetadata& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct LambdaDefinitionExpression : public RowExpression {
  List<Type> argumentTypes = {};
  List<String> arguments = {};
  std::shared_ptr<RowExpression> body = {};

  LambdaDefinitionExpression() noexcept;
};
void to_json(json& j, const LambdaDefinitionExpression& p);
void from_json(const json& j, LambdaDefinitionExpression& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class LimitNodeStep { PARTIAL, FINAL };
extern void to_json(json& j, const LimitNodeStep& e);
extern void from_json(const json& j, LimitNodeStep& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct LimitNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  int64_t count = {};
  LimitNodeStep step = {};

  LimitNode() noexcept;
};
void to_json(json& j, const LimitNode& p);
void from_json(const json& j, LimitNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Location {
  String location = {};
};
void to_json(json& j, const Location& p);
void from_json(const json& j, Location& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct MarkDistinctNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  VariableReferenceExpression markerVariable = {};
  List<VariableReferenceExpression> distinctVariables = {};
  std::shared_ptr<VariableReferenceExpression> hashVariable = {};

  MarkDistinctNode() noexcept;
};
void to_json(json& j, const MarkDistinctNode& p);
void from_json(const json& j, MarkDistinctNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class Bound { BELOW, EXACTLY, ABOVE };
extern void to_json(json& j, const Bound& e);
extern void from_json(const json& j, Bound& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Marker {
  Type type = {};
  std::shared_ptr<Block> valueBlock = {};
  Bound bound = {};
};
void to_json(json& j, const Marker& p);
void from_json(const json& j, Marker& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct MemoryAllocation {
  String tag = {};
  int64_t allocation = {};
};
void to_json(json& j, const MemoryAllocation& p);
void from_json(const json& j, MemoryAllocation& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct MemoryPoolInfo {
  int64_t maxBytes = {};
  int64_t reservedBytes = {};
  int64_t reservedRevocableBytes = {};
  Map<QueryId, Long> queryMemoryReservations = {};
  Map<QueryId, List<MemoryAllocation>> queryMemoryAllocations = {};
  Map<QueryId, Long> queryMemoryRevocableReservations = {};
};
void to_json(json& j, const MemoryPoolInfo& p);
void from_json(const json& j, MemoryPoolInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct MemoryInfo {
  DataSize totalNodeMemory = {};
  Map<MemoryPoolId, MemoryPoolInfo> pools = {};
};
void to_json(json& j, const MemoryInfo& p);
void from_json(const json& j, MemoryInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct MergeHandle : public ExecutionWriterTarget {
  TableHandle tableHandle = {};
  std::shared_ptr<ConnectorMergeTableHandle> connectorMergeTableHandle = {};

  MergeHandle() noexcept;
};
void to_json(json& j, const MergeHandle& p);
void from_json(const json& j, MergeHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct MergeJoinNode : public PlanNode {
  MergeJoinNode() noexcept;
  PlanNodeId id = {};
  JoinType type = {};
  std::shared_ptr<PlanNode> left = {};
  std::shared_ptr<PlanNode> right = {};
  List<EquiJoinClause> criteria = {};
  List<VariableReferenceExpression> outputVariables = {};
  std::shared_ptr<std::shared_ptr<RowExpression>> filter = {};
  std::shared_ptr<VariableReferenceExpression> leftHashVariable = {};
  std::shared_ptr<VariableReferenceExpression> rightHashVariable = {};
};
void to_json(json& j, const MergeJoinNode& p);
void from_json(const json& j, MergeJoinNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class RowChangeParadigm {
  CHANGE_ONLY_UPDATED_COLUMNS,
  DELETE_ROW_AND_INSERT_ROW
};
extern void to_json(json& j, const RowChangeParadigm& e);
extern void from_json(const json& j, RowChangeParadigm& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct MergeParadigmAndTypes {
  RowChangeParadigm paradigm = {};
  List<Type> columnTypes = {};
  Type targetTableRowIdColumnType = {};
};
void to_json(json& j, const MergeParadigmAndTypes& p);
void from_json(const json& j, MergeParadigmAndTypes& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct MergeTarget {
  TableHandle handle = {};
  std::shared_ptr<MergeHandle> mergeHandle = {};
  SchemaTableName schemaTableName = {};
  MergeParadigmAndTypes mergeParadigmAndTypes = {};
};
void to_json(json& j, const MergeTarget& p);
void from_json(const json& j, MergeTarget& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct NativeField {
  std::shared_ptr<String> name = {};
  std::shared_ptr<TypeSignature> typeSignature = {};
};
void to_json(json& j, const NativeField& p);
void from_json(const json& j, NativeField& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct NativeDescriptor {
  List<NativeField> fields = {};
};
void to_json(json& j, const NativeDescriptor& p);
void from_json(const json& j, NativeDescriptor& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct NativeSidecarFailureInfo {
  String type = {};
  String message = {};
  std::shared_ptr<NativeSidecarFailureInfo> cause = {};
  List<NativeSidecarFailureInfo> suppressed = {};
  List<String> stack = {};
  ErrorCode errorCode = {};
};
void to_json(json& j, const NativeSidecarFailureInfo& p);
void from_json(const json& j, NativeSidecarFailureInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct NativeTableFunctionHandle {
  String serializedTableFunctionHandle = {};
  QualifiedObjectName functionName = {};
};
void to_json(json& j, const NativeTableFunctionHandle& p);
void from_json(const json& j, NativeTableFunctionHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct NativeTableFunctionAnalysis {
  std::shared_ptr<NativeDescriptor> returnedType = {};
  Map<String, List<Integer>> requiredColumns = {};
  NativeTableFunctionHandle handle = {};
};
void to_json(json& j, const NativeTableFunctionAnalysis& p);
void from_json(const json& j, NativeTableFunctionAnalysis& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct NodeLoadMetrics {
  double cpuUsedPercent = {};
  double memoryUsedInBytes = {};
  int numQueuedDrivers = {};
  bool cpuOverload = {};
  bool memoryOverload = {};
};
void to_json(json& j, const NodeLoadMetrics& p);
void from_json(const json& j, NodeLoadMetrics& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class NodeState { ACTIVE, INACTIVE, SHUTTING_DOWN };
extern void to_json(json& j, const NodeState& e);
extern void from_json(const json& j, NodeState& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct NodeStats {
  NodeState nodeState = {};
  std::shared_ptr<NodeLoadMetrics> loadMetrics = {};
};
void to_json(json& j, const NodeStats& p);
void from_json(const json& j, NodeStats& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct NodeVersion {
  String version = {};
};
void to_json(json& j, const NodeVersion& p);
void from_json(const json& j, NodeVersion& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct NodeStatus {
  String nodeId = {};
  NodeVersion nodeVersion = {};
  String environment = {};
  bool coordinator = {};
  Duration uptime = {};
  String externalAddress = {};
  String internalAddress = {};
  MemoryInfo memoryInfo = {};
  int processors = {};
  double processCpuLoad = {};
  double systemCpuLoad = {};
  int64_t heapUsed = {};
  int64_t heapAvailable = {};
  int64_t nonHeapUsed = {};
};
void to_json(json& j, const NodeStatus& p);
void from_json(const json& j, NodeStatus& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Serializable {
  Type type = {};
  Block block = {};
};
void to_json(json& j, const Serializable& p);
void from_json(const json& j, Serializable& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct NullableValue {
  Serializable serializable = {};
};
void to_json(json& j, const NullableValue& p);
void from_json(const json& j, NullableValue& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct OnlyPassThroughReturnTypeSpecification : public ReturnTypeSpecification {
  String returnType = {};

  OnlyPassThroughReturnTypeSpecification() noexcept;
};
void to_json(json& j, const OnlyPassThroughReturnTypeSpecification& p);
void from_json(const json& j, OnlyPassThroughReturnTypeSpecification& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class BufferState {
  OPEN,
  NO_MORE_BUFFERS,
  NO_MORE_PAGES,
  FLUSHING,
  FINISHED,
  FAILED
};
extern void to_json(json& j, const BufferState& e);
extern void from_json(const json& j, BufferState& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct OutputBufferInfo {
  String type = {};
  BufferState state = {};
  bool canAddBuffers = {};
  bool canAddPages = {};
  int64_t totalBufferedBytes = {};
  int64_t totalBufferedPages = {};
  int64_t totalRowsSent = {};
  int64_t totalPagesSent = {};
  List<BufferInfo> buffers = {};
};
void to_json(json& j, const OutputBufferInfo& p);
void from_json(const json& j, OutputBufferInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct OutputNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  List<String> columnNames = {};
  List<VariableReferenceExpression> outputVariables = {};

  OutputNode() noexcept;
};
void to_json(json& j, const OutputNode& p);
void from_json(const json& j, OutputNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct PartialAggregationStatsEstimate {
  double inputBytes = {};
  double outputBytes = {};
  double inputRowCount = {};
  double outputRowCount = {};
};
void to_json(json& j, const PartialAggregationStatsEstimate& p);
void from_json(const json& j, PartialAggregationStatsEstimate& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct PipelineStats {
  int pipelineId = {};
  int64_t firstStartTimeInMillis = {};
  int64_t lastStartTimeInMillis = {};
  int64_t lastEndTimeInMillis = {};
  bool inputPipeline = {};
  bool outputPipeline = {};
  int totalDrivers = {};
  int queuedDrivers = {};
  int queuedPartitionedDrivers = {};
  int64_t queuedPartitionedSplitsWeight = {};
  int runningDrivers = {};
  int runningPartitionedDrivers = {};
  int64_t runningPartitionedSplitsWeight = {};
  int blockedDrivers = {};
  int completedDrivers = {};
  int64_t userMemoryReservationInBytes = {};
  int64_t revocableMemoryReservationInBytes = {};
  int64_t systemMemoryReservationInBytes = {};
  DistributionSnapshot queuedTime = {};
  DistributionSnapshot elapsedTime = {};
  int64_t totalScheduledTimeInNanos = {};
  int64_t totalCpuTimeInNanos = {};
  int64_t totalBlockedTimeInNanos = {};
  bool fullyBlocked = {};
  List<BlockedReason> blockedReasons = {};
  int64_t totalAllocationInBytes = {};
  int64_t rawInputDataSizeInBytes = {};
  int64_t rawInputPositions = {};
  int64_t processedInputDataSizeInBytes = {};
  int64_t processedInputPositions = {};
  int64_t outputDataSizeInBytes = {};
  int64_t outputPositions = {};
  int64_t physicalWrittenDataSizeInBytes = {};
  List<OperatorStats> operatorSummaries = {};
  List<DriverStats> drivers = {};
};
void to_json(json& j, const PipelineStats& p);
void from_json(const json& j, PipelineStats& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct PlanConversionResponse {
  List<NativeSidecarFailureInfo> failures = {};
};
void to_json(json& j, const PlanConversionResponse& p);
void from_json(const json& j, PlanConversionResponse& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct PlanCostEstimate {
  double cpuCost = {};
  double maxMemory = {};
  double maxMemoryWhenOutputting = {};
  double networkCost = {};
};
void to_json(json& j, const PlanCostEstimate& p);
void from_json(const json& j, PlanCostEstimate& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class StageExecutionStrategy {
  UNGROUPED_EXECUTION,
  FIXED_LIFESPAN_SCHEDULE_GROUPED_EXECUTION,
  DYNAMIC_LIFESPAN_SCHEDULE_GROUPED_EXECUTION,
  RECOVERABLE_GROUPED_EXECUTION
};
extern void to_json(json& j, const StageExecutionStrategy& e);
extern void from_json(const json& j, StageExecutionStrategy& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct StageExecutionDescriptor {
  StageExecutionStrategy stageExecutionStrategy = {};
  List<PlanNodeId> groupedExecutionScanNodes = {};
  int totalLifespans = {};
};
void to_json(json& j, const StageExecutionDescriptor& p);
void from_json(const json& j, StageExecutionDescriptor& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class ConfidenceLevel { LOW, HIGH, FACT };
extern void to_json(json& j, const ConfidenceLevel& e);
extern void from_json(const json& j, ConfidenceLevel& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TableWriterNodeStatsEstimate {
  double taskCountIfScaledWriter = {};
};
void to_json(json& j, const TableWriterNodeStatsEstimate& p);
void from_json(const json& j, TableWriterNodeStatsEstimate& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct VariableStatsEstimate {
  double lowValue = {};
  double highValue = {};
  double nullsFraction = {};
  double averageRowSize = {};
  double distinctValuesCount = {};
};
void to_json(json& j, const VariableStatsEstimate& p);
void from_json(const json& j, VariableStatsEstimate& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct PlanNodeStatsEstimate {
  double outputRowCount = {};
  double totalSize = {};
  ConfidenceLevel confident = {};
  Map<VariableReferenceExpression, VariableStatsEstimate> variableStatistics =
      {};
  JoinNodeStatsEstimate joinNodeStatsEstimate = {};
  TableWriterNodeStatsEstimate tableWriterNodeStatsEstimate = {};
  PartialAggregationStatsEstimate partialAggregationStatsEstimate = {};
};
void to_json(json& j, const PlanNodeStatsEstimate& p);
void from_json(const json& j, PlanNodeStatsEstimate& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct StatsAndCosts {
  Map<PlanNodeId, PlanNodeStatsEstimate> stats = {};
  Map<PlanNodeId, PlanCostEstimate> costs = {};
};
void to_json(json& j, const StatsAndCosts& p);
void from_json(const json& j, StatsAndCosts& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct PlanFragment {
  PlanFragmentId id = {};
  std::shared_ptr<PlanNode> root = {};
  List<VariableReferenceExpression> variables = {};
  PartitioningHandle partitioning = {};
  List<PlanNodeId> tableScanSchedulingOrder = {};
  PartitioningScheme partitioningScheme = {};
  StageExecutionDescriptor stageExecutionDescriptor = {};
  std::shared_ptr<OrderingScheme> outputOrderingScheme = {};
  bool outputTableWriterFragment = {};
  std::shared_ptr<String> jsonRepresentation = {};
};
void to_json(json& j, const PlanFragment& p);
void from_json(const json& j, PlanFragment& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class Locality { UNKNOWN, LOCAL, REMOTE };
extern void to_json(json& j, const Locality& e);
extern void from_json(const json& j, Locality& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ProjectNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  Assignments assignments = {};
  Locality locality = {};

  ProjectNode() noexcept;
};
void to_json(json& j, const ProjectNode& p);
void from_json(const json& j, ProjectNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct Range {
  Marker low = {};
  Marker high = {};
};
void to_json(json& j, const Range& p);
void from_json(const json& j, Range& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RefreshMaterializedViewHandle {
  InsertTableHandle handle = {};
  SchemaTableName schemaTableName = {};
};
void to_json(json& j, const RefreshMaterializedViewHandle& p);
void from_json(const json& j, RefreshMaterializedViewHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RemoteSourceNode : public PlanNode {
  List<PlanFragmentId> sourceFragmentIds = {};
  List<VariableReferenceExpression> outputVariables = {};
  bool ensureSourceOrdering = {};
  std::shared_ptr<OrderingScheme> orderingScheme = {};
  ExchangeNodeType exchangeType = {};
  ExchangeEncoding encoding = {};

  RemoteSourceNode() noexcept;
};
void to_json(json& j, const RemoteSourceNode& p);
void from_json(const json& j, RemoteSourceNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RemoteSplit : public ConnectorSplit {
  Location location = {};
  TaskId remoteSourceTaskId = {};

  RemoteSplit() noexcept;
};
void to_json(json& j, const RemoteSplit& p);
void from_json(const json& j, RemoteSplit& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RemoteTransactionHandle : public ConnectorTransactionHandle {
  std::shared_ptr<String> dummy = {};

  RemoteTransactionHandle() noexcept;
};
void to_json(json& j, const RemoteTransactionHandle& p);
void from_json(const json& j, RemoteTransactionHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RestFunctionHandle : public FunctionHandle {
  SqlFunctionId functionId = {};
  String version = {};
  Signature signature = {};
  std::shared_ptr<URI> executionEndpoint = {};

  RestFunctionHandle() noexcept;
};
void to_json(json& j, const RestFunctionHandle& p);
void from_json(const json& j, RestFunctionHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RowExpressionOptimizationResult {
  std::shared_ptr<RowExpression> optimizedExpression = {};
  NativeSidecarFailureInfo expressionFailureInfo = {};
};
void to_json(json& j, const RowExpressionOptimizationResult& p);
void from_json(const json& j, RowExpressionOptimizationResult& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RowNumberNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  List<VariableReferenceExpression> partitionBy = {};
  VariableReferenceExpression rowNumberVariable = {};
  std::shared_ptr<Integer> maxRowCountPerPartition = {};
  bool partial = {};
  std::shared_ptr<VariableReferenceExpression> hashVariable = {};

  RowNumberNode() noexcept;
};
void to_json(json& j, const RowNumberNode& p);
void from_json(const json& j, RowNumberNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RowType {
  std::shared_ptr<TypeSignature> typeSignature = {};
};
void to_json(json& j, const RowType& p);
void from_json(const json& j, RowType& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class RuntimeUnit { NONE, NANO, BYTE };
extern void to_json(json& j, const RuntimeUnit& e);
extern void from_json(const json& j, RuntimeUnit& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct RuntimeMetric {
  String name = {};
  RuntimeUnit unit = {};
  int64_t sum = {};
  int64_t count = {};
  int64_t max = {};
  int64_t min = {};
};
void to_json(json& j, const RuntimeMetric& p);
void from_json(const json& j, RuntimeMetric& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class SampleNodeType { BERNOULLI, SYSTEM };
extern void to_json(json& j, const SampleNodeType& e);
extern void from_json(const json& j, SampleNodeType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SampleNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  double sampleRatio = {};
  SampleNodeType sampleType = {};

  SampleNode() noexcept;
};
void to_json(json& j, const SampleNode& p);
void from_json(const json& j, SampleNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ScalarArgument : public Argument {
  NullableValue nullableValue = {};

  ScalarArgument() noexcept;
};
void to_json(json& j, const ScalarArgument& p);
void from_json(const json& j, ScalarArgument& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ScalarArgumentSpecification : public ArgumentSpecification {
  String name = {};
  Type type = {};
  bool required = {};

  ScalarArgumentSpecification() noexcept;
};
void to_json(json& j, const ScalarArgumentSpecification& p);
void from_json(const json& j, ScalarArgumentSpecification& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class DistributionType { PARTITIONED, REPLICATED };
extern void to_json(json& j, const DistributionType& e);
extern void from_json(const json& j, DistributionType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SemiJoinNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  std::shared_ptr<PlanNode> filteringSource = {};
  VariableReferenceExpression sourceJoinVariable = {};
  VariableReferenceExpression filteringSourceJoinVariable = {};
  VariableReferenceExpression semiJoinOutput = {};
  std::shared_ptr<VariableReferenceExpression> sourceHashVariable = {};
  std::shared_ptr<VariableReferenceExpression> filteringSourceHashVariable = {};
  std::shared_ptr<DistributionType> distributionType = {};
  Map<String, VariableReferenceExpression> dynamicFilters = {};

  SemiJoinNode() noexcept;
};
void to_json(json& j, const SemiJoinNode& p);
void from_json(const json& j, SemiJoinNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ServerInfo {
  NodeVersion nodeVersion = {};
  String environment = {};
  bool coordinator = {};
  bool starting = {};
  std::shared_ptr<Duration> uptime = {};
};
void to_json(json& j, const ServerInfo& p);
void from_json(const json& j, ServerInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SessionPropertyMetadata {
  String name = {};
  String description = {};
  TypeSignature typeSignature = {};
  String defaultValue = {};
  bool hidden = {};
};
void to_json(json& j, const SessionPropertyMetadata& p);
void from_json(const json& j, SessionPropertyMetadata& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SortNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  OrderingScheme orderingScheme = {};
  bool isPartial = {};
  List<VariableReferenceExpression> partitionBy = {};

  SortNode() noexcept;
};
void to_json(json& j, const SortNode& p);
void from_json(const json& j, SortNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SortedRangeSet : public ValueSet {
  Type type = {};
  List<Range> ranges = {};

  SortedRangeSet() noexcept;
};
void to_json(json& j, const SortedRangeSet& p);
void from_json(const json& j, SortedRangeSet& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class SpatialJoinType { INNER, LEFT };
extern void to_json(json& j, const SpatialJoinType& e);
extern void from_json(const json& j, SpatialJoinType& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SpatialJoinNode : public PlanNode {
  SpatialJoinType type = {};
  std::shared_ptr<PlanNode> left = {};
  std::shared_ptr<PlanNode> right = {};
  List<VariableReferenceExpression> outputVariables = {};
  VariableReferenceExpression probeGeometryVariable = {};
  VariableReferenceExpression buildGeometryVariable = {};
  std::shared_ptr<VariableReferenceExpression> radiusVariable = {};
  std::shared_ptr<RowExpression> filter = {};
  std::shared_ptr<VariableReferenceExpression> leftPartitionVariable = {};
  std::shared_ptr<VariableReferenceExpression> rightPartitionVariable = {};
  std::shared_ptr<String> kdbTree = {};

  SpatialJoinNode() noexcept;
};
void to_json(json& j, const SpatialJoinNode& p);
void from_json(const json& j, SpatialJoinNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class Form {
  IF,
  NULL_IF,
  SWITCH,
  WHEN,
  IS_NULL,
  COALESCE,
  IN,
  AND,
  OR,
  DEREFERENCE,
  ROW_CONSTRUCTOR,
  BIND
};
extern void to_json(json& j, const Form& e);
extern void from_json(const json& j, Form& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SpecialFormExpression : public RowExpression {
  Form form = {};
  Type returnType = {};
  List<std::shared_ptr<RowExpression>> arguments = {};

  SpecialFormExpression() noexcept;
};
void to_json(json& j, const SpecialFormExpression& p);
void from_json(const json& j, SpecialFormExpression& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SqlFunctionHandle : public FunctionHandle {
  SqlFunctionId functionId = {};
  String version = {};

  SqlFunctionHandle() noexcept;
};
void to_json(json& j, const SqlFunctionHandle& p);
void from_json(const json& j, SqlFunctionHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct StatisticAggregations {
  List<VariableReferenceExpression> outputVariables = {};
  Map<VariableReferenceExpression, Aggregation> aggregations = {};
  List<VariableReferenceExpression> groupingVariables = {};
};
void to_json(json& j, const StatisticAggregations& p);
void from_json(const json& j, StatisticAggregations& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SystemColumnHandle : public ColumnHandle {
  ConnectorId connectorId = {};
  String columnName = {};

  SystemColumnHandle() noexcept;
};
void to_json(json& j, const SystemColumnHandle& p);
void from_json(const json& j, SystemColumnHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class SystemPartitionFunction {
  SINGLE,
  HASH,
  ROUND_ROBIN,
  BROADCAST,
  UNKNOWN
};
extern void to_json(json& j, const SystemPartitionFunction& e);
extern void from_json(const json& j, SystemPartitionFunction& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class SystemPartitioning {
  SINGLE,
  FIXED,
  SOURCE,
  SCALED,
  COORDINATOR_ONLY,
  ARBITRARY
};
extern void to_json(json& j, const SystemPartitioning& e);
extern void from_json(const json& j, SystemPartitioning& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SystemPartitioningHandle : public ConnectorPartitioningHandle {
  SystemPartitioning partitioning = {};
  SystemPartitionFunction function = {};

  SystemPartitioningHandle() noexcept;
};
void to_json(json& j, const SystemPartitioningHandle& p);
void from_json(const json& j, SystemPartitioningHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SystemTableHandle : public ConnectorTableHandle {
  ConnectorId connectorId = {};
  String schemaName = {};
  String tableName = {};

  SystemTableHandle() noexcept;
};
void to_json(json& j, const SystemTableHandle& p);
void from_json(const json& j, SystemTableHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SystemSplit : public ConnectorSplit {
  ConnectorId connectorId = {};
  SystemTableHandle tableHandle = {};
  List<HostAddress> addresses = {};
  TupleDomain<std::shared_ptr<ColumnHandle>> constraint = {};

  SystemSplit() noexcept;
};
void to_json(json& j, const SystemSplit& p);
void from_json(const json& j, SystemSplit& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SystemTableLayoutHandle : public ConnectorTableLayoutHandle {
  ConnectorId connectorId = {};
  SystemTableHandle table = {};
  TupleDomain<std::shared_ptr<ColumnHandle>> constraint = {};

  SystemTableLayoutHandle() noexcept;
};
void to_json(json& j, const SystemTableLayoutHandle& p);
void from_json(const json& j, SystemTableLayoutHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct SystemTransactionHandle : public ConnectorTransactionHandle {
  ConnectorId connectorId = {};
  TransactionId transactionId = {};
  std::shared_ptr<ConnectorTransactionHandle> connectorTransactionHandle = {};

  SystemTransactionHandle() noexcept;
};
void to_json(json& j, const SystemTransactionHandle& p);
void from_json(const json& j, SystemTransactionHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TableArgument : public Argument {
  RowType rowType = {};
  List<String> partitionBy = {};
  List<String> orderBy = {};
  List<Field> fields = {};

  TableArgument() noexcept;
};
void to_json(json& j, const TableArgument& p);
void from_json(const json& j, TableArgument& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TableArgumentSpecification : public ArgumentSpecification {
  String name = {};
  bool rowSemantics = {};
  bool pruneWhenEmpty = {};
  bool passThroughColumns = {};

  TableArgumentSpecification() noexcept;
};
void to_json(json& j, const TableArgumentSpecification& p);
void from_json(const json& j, TableArgumentSpecification& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TableScanNode : public PlanNode {
  TableHandle table = {};
  List<VariableReferenceExpression> outputVariables = {};
  Map<VariableReferenceExpression, std::shared_ptr<ColumnHandle>> assignments =
      {};

  TableScanNode() noexcept;
};
void to_json(json& j, const TableScanNode& p);
void from_json(const json& j, TableScanNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TableWriterMergeNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  VariableReferenceExpression rowCountVariable = {};
  VariableReferenceExpression fragmentVariable = {};
  VariableReferenceExpression tableCommitContextVariable = {};
  std::shared_ptr<StatisticAggregations> statisticsAggregation = {};

  TableWriterMergeNode() noexcept;
};
void to_json(json& j, const TableWriterMergeNode& p);
void from_json(const json& j, TableWriterMergeNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TableWriterNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  // TODO Add target
  VariableReferenceExpression rowCountVariable = {};
  VariableReferenceExpression fragmentVariable = {};
  VariableReferenceExpression tableCommitContextVariable = {};
  List<VariableReferenceExpression> columns = {};
  List<String> columnNames = {};
  List<VariableReferenceExpression> notNullColumnVariables = {};
  std::shared_ptr<PartitioningScheme> partitioningScheme = {};
  std::shared_ptr<PartitioningScheme> preferredShufflePartitioningScheme = {};
  std::shared_ptr<StatisticAggregations> statisticsAggregation = {};

  TableWriterNode() noexcept;
};
void to_json(json& j, const TableWriterNode& p);
void from_json(const json& j, TableWriterNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TaskStats {
  int64_t createTimeInMillis = {};
  int64_t firstStartTimeInMillis = {};
  int64_t lastStartTimeInMillis = {};
  int64_t lastEndTimeInMillis = {};
  int64_t endTimeInMillis = {};
  int64_t elapsedTimeInNanos = {};
  int64_t queuedTimeInNanos = {};
  int totalDrivers = {};
  int queuedDrivers = {};
  int queuedPartitionedDrivers = {};
  int64_t queuedPartitionedSplitsWeight = {};
  int runningDrivers = {};
  int runningPartitionedDrivers = {};
  int64_t runningPartitionedSplitsWeight = {};
  int blockedDrivers = {};
  int completedDrivers = {};
  int totalNewDrivers = {};
  int queuedNewDrivers = {};
  int runningNewDrivers = {};
  int completedNewDrivers = {};
  int totalSplits = {};
  int queuedSplits = {};
  int runningSplits = {};
  int completedSplits = {};
  double cumulativeUserMemory = {};
  double cumulativeTotalMemory = {};
  int64_t userMemoryReservationInBytes = {};
  int64_t revocableMemoryReservationInBytes = {};
  int64_t systemMemoryReservationInBytes = {};
  int64_t peakTotalMemoryInBytes = {};
  int64_t peakUserMemoryInBytes = {};
  int64_t peakNodeTotalMemoryInBytes = {};
  int64_t totalScheduledTimeInNanos = {};
  int64_t totalCpuTimeInNanos = {};
  int64_t totalBlockedTimeInNanos = {};
  bool fullyBlocked = {};
  List<BlockedReason> blockedReasons = {};
  int64_t totalAllocationInBytes = {};
  int64_t rawInputDataSizeInBytes = {};
  int64_t rawInputPositions = {};
  int64_t processedInputDataSizeInBytes = {};
  int64_t processedInputPositions = {};
  int64_t outputDataSizeInBytes = {};
  int64_t outputPositions = {};
  int64_t physicalWrittenDataSizeInBytes = {};
  int fullGcCount = {};
  int64_t fullGcTimeInMillis = {};
  List<PipelineStats> pipelines = {};
  RuntimeStats runtimeStats = {};
};
void to_json(json& j, const TaskStats& p);
void from_json(const json& j, TaskStats& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class TaskState { PLANNED, RUNNING, FINISHED, CANCELED, ABORTED, FAILED };
extern void to_json(json& j, const TaskState& e);
extern void from_json(const json& j, TaskState& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TaskStatus {
  int64_t taskInstanceIdLeastSignificantBits = {};
  int64_t taskInstanceIdMostSignificantBits = {};
  int64_t version = {};
  TaskState state = {};
  URI self = {};
  List<Lifespan> completedDriverGroups = {};
  List<ExecutionFailureInfo> failures = {};
  int queuedPartitionedDrivers = {};
  int runningPartitionedDrivers = {};
  double outputBufferUtilization = {};
  bool outputBufferOverutilized = {};
  int64_t physicalWrittenDataSizeInBytes = {};
  int64_t memoryReservationInBytes = {};
  int64_t systemMemoryReservationInBytes = {};
  int64_t peakNodeTotalMemoryReservationInBytes = {};
  int64_t fullGcCount = {};
  int64_t fullGcTimeInMillis = {};
  int64_t totalCpuTimeInNanos = {};
  int64_t taskAgeInMillis = {};
  int64_t queuedPartitionedSplitsWeight = {};
  int64_t runningPartitionedSplitsWeight = {};
};
void to_json(json& j, const TaskStatus& p);
void from_json(const json& j, TaskStatus& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TaskInfo {
  TaskId taskId = {};
  TaskStatus taskStatus = {};
  int64_t lastHeartbeatInMillis = {};
  OutputBufferInfo outputBuffers = {};
  List<PlanNodeId> noMoreSplits = {};
  TaskStats stats = {};
  bool needsPlan = {};
  String nodeId = {};
};
void to_json(json& j, const TaskInfo& p);
void from_json(const json& j, TaskInfo& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
enum class Step { SINGLE, PARTIAL, FINAL };
extern void to_json(json& j, const Step& e);
extern void from_json(const json& j, Step& e);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TopNNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  int64_t count = {};
  OrderingScheme orderingScheme = {};
  Step step = {};

  TopNNode() noexcept;
};
void to_json(json& j, const TopNNode& p);
void from_json(const json& j, TopNNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct TopNRowNumberNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  DataOrganizationSpecification specification = {};
  VariableReferenceExpression rowNumberVariable = {};
  int maxRowCountPerPartition = {};
  bool partial = {};
  std::shared_ptr<VariableReferenceExpression> hashVariable = {};

  TopNRowNumberNode() noexcept;
};
void to_json(json& j, const TopNRowNumberNode& p);
void from_json(const json& j, TopNRowNumberNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct UnnestNode : public PlanNode {
  std::shared_ptr<PlanNode> source = {};
  List<VariableReferenceExpression> replicateVariables = {};
  Map<VariableReferenceExpression, List<VariableReferenceExpression>>
      unnestVariables = {};
  std::shared_ptr<VariableReferenceExpression> ordinalityVariable = {};

  UnnestNode() noexcept;
};
void to_json(json& j, const UnnestNode& p);
void from_json(const json& j, UnnestNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct UpdateHandle : public ExecutionWriterTarget {
  TableHandle handle = {};
  SchemaTableName schemaTableName = {};

  UpdateHandle() noexcept;
};
void to_json(json& j, const UpdateHandle& p);
void from_json(const json& j, UpdateHandle& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct ValuesNode : public PlanNode {
  std::shared_ptr<SourceLocation> location = {};

  List<VariableReferenceExpression> outputVariables = {};
  List<List<std::shared_ptr<RowExpression>>> rows = {};
  std::shared_ptr<String> valuesNodeLabel = {};

  ValuesNode() noexcept;
};
void to_json(json& j, const ValuesNode& p);
void from_json(const json& j, ValuesNode& p);
} // namespace facebook::presto::protocol
namespace facebook::presto::protocol {
struct WindowNode : public PlanNode {
  std::shared_ptr<SourceLocation> sourceLocation = {};

  std::shared_ptr<PlanNode> source = {};
  DataOrganizationSpecification specification = {};
  Map<VariableReferenceExpression, Function> windowFunctions = {};
  std::shared_ptr<VariableReferenceExpression> hashVariable = {};
  List<VariableReferenceExpression> prePartitionedInputs = {};
  int preSortedOrderPrefix = {};

  WindowNode() noexcept;
};
void to_json(json& j, const WindowNode& p);
void from_json(const json& j, WindowNode& p);
} // namespace facebook::presto::protocol
