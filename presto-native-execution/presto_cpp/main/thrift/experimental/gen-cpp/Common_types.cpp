/**
 * Autogenerated by Thrift Compiler (0.21.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Common_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace protocol {

int _kThriftTaskStateValues[] = {
  ThriftTaskState::PLANNED,
  ThriftTaskState::RUNNING,
  ThriftTaskState::FINISHED,
  ThriftTaskState::CANCELED,
  ThriftTaskState::ABORTED,
  ThriftTaskState::FAILED
};
const char* _kThriftTaskStateNames[] = {
  "PLANNED",
  "RUNNING",
  "FINISHED",
  "CANCELED",
  "ABORTED",
  "FAILED"
};
const std::map<int, const char*> _ThriftTaskState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kThriftTaskStateValues, _kThriftTaskStateNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ThriftTaskState::type& val) {
  std::map<int, const char*>::const_iterator it = _ThriftTaskState_VALUES_TO_NAMES.find(val);
  if (it != _ThriftTaskState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ThriftTaskState::type& val) {
  std::map<int, const char*>::const_iterator it = _ThriftTaskState_VALUES_TO_NAMES.find(val);
  if (it != _ThriftTaskState_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kThriftErrorCauseValues[] = {
  ThriftErrorCause::UNKNOWN,
  ThriftErrorCause::LOW_PARTITION_COUNT,
  ThriftErrorCause::EXCEEDS_BROADCAST_MEMORY_LIMIT
};
const char* _kThriftErrorCauseNames[] = {
  "UNKNOWN",
  "LOW_PARTITION_COUNT",
  "EXCEEDS_BROADCAST_MEMORY_LIMIT"
};
const std::map<int, const char*> _ThriftErrorCause_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kThriftErrorCauseValues, _kThriftErrorCauseNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ThriftErrorCause::type& val) {
  std::map<int, const char*>::const_iterator it = _ThriftErrorCause_VALUES_TO_NAMES.find(val);
  if (it != _ThriftErrorCause_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ThriftErrorCause::type& val) {
  std::map<int, const char*>::const_iterator it = _ThriftErrorCause_VALUES_TO_NAMES.find(val);
  if (it != _ThriftErrorCause_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kThriftBufferTypeValues[] = {
  ThriftBufferType::BROADCAST,
  ThriftBufferType::PARTITIONED,
  ThriftBufferType::ARBITRARY
};
const char* _kThriftBufferTypeNames[] = {
  "BROADCAST",
  "PARTITIONED",
  "ARBITRARY"
};
const std::map<int, const char*> _ThriftBufferType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kThriftBufferTypeValues, _kThriftBufferTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ThriftBufferType::type& val) {
  std::map<int, const char*>::const_iterator it = _ThriftBufferType_VALUES_TO_NAMES.find(val);
  if (it != _ThriftBufferType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ThriftBufferType::type& val) {
  std::map<int, const char*>::const_iterator it = _ThriftBufferType_VALUES_TO_NAMES.find(val);
  if (it != _ThriftBufferType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kThriftErrorTypeValues[] = {
  ThriftErrorType::USER_ERROR,
  ThriftErrorType::INTERNAL_ERROR,
  ThriftErrorType::INSUFFICIENT_RESOURCES,
  ThriftErrorType::EXTERNAL
};
const char* _kThriftErrorTypeNames[] = {
  "USER_ERROR",
  "INTERNAL_ERROR",
  "INSUFFICIENT_RESOURCES",
  "EXTERNAL"
};
const std::map<int, const char*> _ThriftErrorType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kThriftErrorTypeValues, _kThriftErrorTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ThriftErrorType::type& val) {
  std::map<int, const char*>::const_iterator it = _ThriftErrorType_VALUES_TO_NAMES.find(val);
  if (it != _ThriftErrorType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ThriftErrorType::type& val) {
  std::map<int, const char*>::const_iterator it = _ThriftErrorType_VALUES_TO_NAMES.find(val);
  if (it != _ThriftErrorType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}

int _kThriftSelectedRoleTypeValues[] = {
  ThriftSelectedRoleType::ROLE,
  ThriftSelectedRoleType::ALL,
  ThriftSelectedRoleType::NONE
};
const char* _kThriftSelectedRoleTypeNames[] = {
  "ROLE",
  "ALL",
  "NONE"
};
const std::map<int, const char*> _ThriftSelectedRoleType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kThriftSelectedRoleTypeValues, _kThriftSelectedRoleTypeNames), ::apache::thrift::TEnumIterator(-1, nullptr, nullptr));

std::ostream& operator<<(std::ostream& out, const ThriftSelectedRoleType::type& val) {
  std::map<int, const char*>::const_iterator it = _ThriftSelectedRoleType_VALUES_TO_NAMES.find(val);
  if (it != _ThriftSelectedRoleType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

std::string to_string(const ThriftSelectedRoleType::type& val) {
  std::map<int, const char*>::const_iterator it = _ThriftSelectedRoleType_VALUES_TO_NAMES.find(val);
  if (it != _ThriftSelectedRoleType_VALUES_TO_NAMES.end()) {
    return std::string(it->second);
  } else {
    return std::to_string(static_cast<int>(val));
  }
}


ThriftSelectedRole::~ThriftSelectedRole() noexcept {
}

ThriftSelectedRole::ThriftSelectedRole() noexcept
   : type(static_cast<ThriftSelectedRoleType::type>(0)),
     role() {
}

void ThriftSelectedRole::__set_type(const ThriftSelectedRoleType::type val) {
  this->type = val;
}

void ThriftSelectedRole::__set_role(const std::string& val) {
  this->role = val;
__isset.role = true;
}
std::ostream& operator<<(std::ostream& out, const ThriftSelectedRole& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftSelectedRole::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->type = static_cast<ThriftSelectedRoleType::type>(ecast0);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->role);
          this->__isset.role = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftSelectedRole::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftSelectedRole");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  if (this->__isset.role) {
    xfer += oprot->writeFieldBegin("role", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->role);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftSelectedRole &a, ThriftSelectedRole &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.role, b.role);
  swap(a.__isset, b.__isset);
}

bool ThriftSelectedRole::operator==(const ThriftSelectedRole & rhs) const
{
  if (!(type == rhs.type))
    return false;
  if (__isset.role != rhs.__isset.role)
    return false;
  else if (__isset.role && !(role == rhs.role))
    return false;
  return true;
}

ThriftSelectedRole::ThriftSelectedRole(const ThriftSelectedRole& other1) {
  type = other1.type;
  role = other1.role;
  __isset = other1.__isset;
}
ThriftSelectedRole& ThriftSelectedRole::operator=(const ThriftSelectedRole& other2) {
  type = other2.type;
  role = other2.role;
  __isset = other2.__isset;
  return *this;
}
void ThriftSelectedRole::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftSelectedRole(";
  out << "type=" << to_string(type);
  out << ", " << "role="; (__isset.role ? (out << to_string(role)) : (out << "<null>"));
  out << ")";
}


ThriftOutputBufferId::~ThriftOutputBufferId() noexcept {
}

ThriftOutputBufferId::ThriftOutputBufferId() noexcept
   : id(0) {
}

void ThriftOutputBufferId::__set_id(const int32_t val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const ThriftOutputBufferId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftOutputBufferId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t ThriftOutputBufferId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftOutputBufferId");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftOutputBufferId &a, ThriftOutputBufferId &b) {
  using ::std::swap;
  swap(a.id, b.id);
}

bool ThriftOutputBufferId::operator==(const ThriftOutputBufferId & rhs) const
{
  if (!(id == rhs.id))
    return false;
  return true;
}

ThriftOutputBufferId::ThriftOutputBufferId(const ThriftOutputBufferId& other3) noexcept {
  id = other3.id;
}
ThriftOutputBufferId& ThriftOutputBufferId::operator=(const ThriftOutputBufferId& other4) noexcept {
  id = other4.id;
  return *this;
}
void ThriftOutputBufferId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftOutputBufferId(";
  out << "id=" << to_string(id);
  out << ")";
}


ThriftOutputBuffers::~ThriftOutputBuffers() noexcept {
}

ThriftOutputBuffers::ThriftOutputBuffers() noexcept
   : type(static_cast<ThriftBufferType::type>(0)),
     noMoreBufferIds(0),
     version(0),
     totalBufferCount(0),
     totalPartitionCount(0) {
}

void ThriftOutputBuffers::__set_type(const ThriftBufferType::type val) {
  this->type = val;
}

void ThriftOutputBuffers::__set_noMoreBufferIds(const bool val) {
  this->noMoreBufferIds = val;
}

void ThriftOutputBuffers::__set_version(const int64_t val) {
  this->version = val;
}

void ThriftOutputBuffers::__set_buffers(const std::map<ThriftOutputBufferId, std::string> & val) {
  this->buffers = val;
}

void ThriftOutputBuffers::__set_totalBufferCount(const int32_t val) {
  this->totalBufferCount = val;
__isset.totalBufferCount = true;
}

void ThriftOutputBuffers::__set_totalPartitionCount(const int32_t val) {
  this->totalPartitionCount = val;
__isset.totalPartitionCount = true;
}
std::ostream& operator<<(std::ostream& out, const ThriftOutputBuffers& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftOutputBuffers::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->type = static_cast<ThriftBufferType::type>(ecast5);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->noMoreBufferIds);
          this->__isset.noMoreBufferIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->buffers.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              ThriftOutputBufferId _key11;
              xfer += _key11.read(iprot);
              std::string& _val12 = this->buffers[_key11];
              xfer += iprot->readString(_val12);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.buffers = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalBufferCount);
          this->__isset.totalBufferCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalPartitionCount);
          this->__isset.totalPartitionCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftOutputBuffers::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftOutputBuffers");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noMoreBufferIds", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->noMoreBufferIds);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buffers", ::apache::thrift::protocol::T_MAP, 4);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRUCT, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->buffers.size()));
    std::map<ThriftOutputBufferId, std::string> ::const_iterator _iter13;
    for (_iter13 = this->buffers.begin(); _iter13 != this->buffers.end(); ++_iter13)
    {
      xfer += _iter13->first.write(oprot);
      xfer += oprot->writeString(_iter13->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.totalBufferCount) {
    xfer += oprot->writeFieldBegin("totalBufferCount", ::apache::thrift::protocol::T_I32, 5);
    xfer += oprot->writeI32(this->totalBufferCount);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.totalPartitionCount) {
    xfer += oprot->writeFieldBegin("totalPartitionCount", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->totalPartitionCount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftOutputBuffers &a, ThriftOutputBuffers &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.noMoreBufferIds, b.noMoreBufferIds);
  swap(a.version, b.version);
  swap(a.buffers, b.buffers);
  swap(a.totalBufferCount, b.totalBufferCount);
  swap(a.totalPartitionCount, b.totalPartitionCount);
  swap(a.__isset, b.__isset);
}

bool ThriftOutputBuffers::operator==(const ThriftOutputBuffers & rhs) const
{
  if (!(type == rhs.type))
    return false;
  if (!(noMoreBufferIds == rhs.noMoreBufferIds))
    return false;
  if (!(version == rhs.version))
    return false;
  if (!(buffers == rhs.buffers))
    return false;
  if (__isset.totalBufferCount != rhs.__isset.totalBufferCount)
    return false;
  else if (__isset.totalBufferCount && !(totalBufferCount == rhs.totalBufferCount))
    return false;
  if (__isset.totalPartitionCount != rhs.__isset.totalPartitionCount)
    return false;
  else if (__isset.totalPartitionCount && !(totalPartitionCount == rhs.totalPartitionCount))
    return false;
  return true;
}

ThriftOutputBuffers::ThriftOutputBuffers(const ThriftOutputBuffers& other14) {
  type = other14.type;
  noMoreBufferIds = other14.noMoreBufferIds;
  version = other14.version;
  buffers = other14.buffers;
  totalBufferCount = other14.totalBufferCount;
  totalPartitionCount = other14.totalPartitionCount;
  __isset = other14.__isset;
}
ThriftOutputBuffers& ThriftOutputBuffers::operator=(const ThriftOutputBuffers& other15) {
  type = other15.type;
  noMoreBufferIds = other15.noMoreBufferIds;
  version = other15.version;
  buffers = other15.buffers;
  totalBufferCount = other15.totalBufferCount;
  totalPartitionCount = other15.totalPartitionCount;
  __isset = other15.__isset;
  return *this;
}
void ThriftOutputBuffers::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftOutputBuffers(";
  out << "type=" << to_string(type);
  out << ", " << "noMoreBufferIds=" << to_string(noMoreBufferIds);
  out << ", " << "version=" << to_string(version);
  out << ", " << "buffers=" << to_string(buffers);
  out << ", " << "totalBufferCount="; (__isset.totalBufferCount ? (out << to_string(totalBufferCount)) : (out << "<null>"));
  out << ", " << "totalPartitionCount="; (__isset.totalPartitionCount ? (out << to_string(totalPartitionCount)) : (out << "<null>"));
  out << ")";
}


ThriftErrorCode::~ThriftErrorCode() noexcept {
}

ThriftErrorCode::ThriftErrorCode() noexcept
   : code(0),
     name(),
     type(static_cast<ThriftErrorType::type>(0)),
     retriable(0) {
}

void ThriftErrorCode::__set_code(const int32_t val) {
  this->code = val;
}

void ThriftErrorCode::__set_name(const std::string& val) {
  this->name = val;
}

void ThriftErrorCode::__set_type(const ThriftErrorType::type val) {
  this->type = val;
}

void ThriftErrorCode::__set_retriable(const bool val) {
  this->retriable = val;
}
std::ostream& operator<<(std::ostream& out, const ThriftErrorCode& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftErrorCode::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->code);
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast16;
          xfer += iprot->readI32(ecast16);
          this->type = static_cast<ThriftErrorType::type>(ecast16);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->retriable);
          this->__isset.retriable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftErrorCode::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftErrorCode");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(static_cast<int32_t>(this->type));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("retriable", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->retriable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftErrorCode &a, ThriftErrorCode &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.retriable, b.retriable);
  swap(a.__isset, b.__isset);
}

bool ThriftErrorCode::operator==(const ThriftErrorCode & rhs) const
{
  if (!(code == rhs.code))
    return false;
  if (!(name == rhs.name))
    return false;
  if (!(type == rhs.type))
    return false;
  if (!(retriable == rhs.retriable))
    return false;
  return true;
}

ThriftErrorCode::ThriftErrorCode(const ThriftErrorCode& other17) {
  code = other17.code;
  name = other17.name;
  type = other17.type;
  retriable = other17.retriable;
  __isset = other17.__isset;
}
ThriftErrorCode& ThriftErrorCode::operator=(const ThriftErrorCode& other18) {
  code = other18.code;
  name = other18.name;
  type = other18.type;
  retriable = other18.retriable;
  __isset = other18.__isset;
  return *this;
}
void ThriftErrorCode::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftErrorCode(";
  out << "code=" << to_string(code);
  out << ", " << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "retriable=" << to_string(retriable);
  out << ")";
}


ThriftErrorLocation::~ThriftErrorLocation() noexcept {
}

ThriftErrorLocation::ThriftErrorLocation() noexcept
   : lineNumber(0),
     columnNumber(0) {
}

void ThriftErrorLocation::__set_lineNumber(const int32_t val) {
  this->lineNumber = val;
}

void ThriftErrorLocation::__set_columnNumber(const int32_t val) {
  this->columnNumber = val;
}
std::ostream& operator<<(std::ostream& out, const ThriftErrorLocation& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftErrorLocation::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lineNumber);
          this->__isset.lineNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->columnNumber);
          this->__isset.columnNumber = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftErrorLocation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftErrorLocation");

  xfer += oprot->writeFieldBegin("lineNumber", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->lineNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("columnNumber", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->columnNumber);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftErrorLocation &a, ThriftErrorLocation &b) {
  using ::std::swap;
  swap(a.lineNumber, b.lineNumber);
  swap(a.columnNumber, b.columnNumber);
  swap(a.__isset, b.__isset);
}

bool ThriftErrorLocation::operator==(const ThriftErrorLocation & rhs) const
{
  if (!(lineNumber == rhs.lineNumber))
    return false;
  if (!(columnNumber == rhs.columnNumber))
    return false;
  return true;
}

ThriftErrorLocation::ThriftErrorLocation(const ThriftErrorLocation& other19) noexcept {
  lineNumber = other19.lineNumber;
  columnNumber = other19.columnNumber;
  __isset = other19.__isset;
}
ThriftErrorLocation& ThriftErrorLocation::operator=(const ThriftErrorLocation& other20) noexcept {
  lineNumber = other20.lineNumber;
  columnNumber = other20.columnNumber;
  __isset = other20.__isset;
  return *this;
}
void ThriftErrorLocation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftErrorLocation(";
  out << "lineNumber=" << to_string(lineNumber);
  out << ", " << "columnNumber=" << to_string(columnNumber);
  out << ")";
}


ThriftHostAddress::~ThriftHostAddress() noexcept {
}

ThriftHostAddress::ThriftHostAddress() noexcept
   : host(),
     port(0) {
}

void ThriftHostAddress::__set_host(const std::string& val) {
  this->host = val;
}

void ThriftHostAddress::__set_port(const int32_t val) {
  this->port = val;
}
std::ostream& operator<<(std::ostream& out, const ThriftHostAddress& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftHostAddress::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->host);
          this->__isset.host = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftHostAddress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftHostAddress");

  xfer += oprot->writeFieldBegin("host", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->host);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftHostAddress &a, ThriftHostAddress &b) {
  using ::std::swap;
  swap(a.host, b.host);
  swap(a.port, b.port);
  swap(a.__isset, b.__isset);
}

bool ThriftHostAddress::operator==(const ThriftHostAddress & rhs) const
{
  if (!(host == rhs.host))
    return false;
  if (!(port == rhs.port))
    return false;
  return true;
}

ThriftHostAddress::ThriftHostAddress(const ThriftHostAddress& other21) {
  host = other21.host;
  port = other21.port;
  __isset = other21.__isset;
}
ThriftHostAddress& ThriftHostAddress::operator=(const ThriftHostAddress& other22) {
  host = other22.host;
  port = other22.port;
  __isset = other22.__isset;
  return *this;
}
void ThriftHostAddress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftHostAddress(";
  out << "host=" << to_string(host);
  out << ", " << "port=" << to_string(port);
  out << ")";
}


ThriftExecutionFailureInfo::~ThriftExecutionFailureInfo() noexcept {
}

ThriftExecutionFailureInfo::ThriftExecutionFailureInfo() noexcept
   : type(),
     message(),
     errorCause(static_cast<ThriftErrorCause::type>(0)) {
}

void ThriftExecutionFailureInfo::__set_type(const std::string& val) {
  this->type = val;
}

void ThriftExecutionFailureInfo::__set_message(const std::string& val) {
  this->message = val;
}

void ThriftExecutionFailureInfo::__set_cause(const ThriftExecutionFailureInfo& val) {
  this->cause = val;
__isset.cause = true;
}

void ThriftExecutionFailureInfo::__set_suppressed(const std::vector<ThriftExecutionFailureInfo> & val) {
  this->suppressed = val;
}

void ThriftExecutionFailureInfo::__set_stack(const std::vector<std::string> & val) {
  this->stack = val;
}

void ThriftExecutionFailureInfo::__set_errorLocation(const ThriftErrorLocation& val) {
  this->errorLocation = val;
}

void ThriftExecutionFailureInfo::__set_errorCode(const ThriftErrorCode& val) {
  this->errorCode = val;
}

void ThriftExecutionFailureInfo::__set_remoteHost(const ThriftHostAddress& val) {
  this->remoteHost = val;
}

void ThriftExecutionFailureInfo::__set_errorCause(const ThriftErrorCause::type val) {
  this->errorCause = val;
}
std::ostream& operator<<(std::ostream& out, const ThriftExecutionFailureInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftExecutionFailureInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->cause.read(iprot);
          this->__isset.cause = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->suppressed.clear();
            uint32_t _size23;
            ::apache::thrift::protocol::TType _etype26;
            xfer += iprot->readListBegin(_etype26, _size23);
            this->suppressed.resize(_size23);
            uint32_t _i27;
            for (_i27 = 0; _i27 < _size23; ++_i27)
            {
              xfer += this->suppressed[_i27].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.suppressed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->stack.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->stack.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += iprot->readString(this->stack[_i32]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.stack = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->errorLocation.read(iprot);
          this->__isset.errorLocation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->errorCode.read(iprot);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->remoteHost.read(iprot);
          this->__isset.remoteHost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast33;
          xfer += iprot->readI32(ecast33);
          this->errorCause = static_cast<ThriftErrorCause::type>(ecast33);
          this->__isset.errorCause = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftExecutionFailureInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftExecutionFailureInfo");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.cause) {
    xfer += oprot->writeFieldBegin("cause", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->cause.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("suppressed", ::apache::thrift::protocol::T_LIST, 4);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->suppressed.size()));
    std::vector<ThriftExecutionFailureInfo> ::const_iterator _iter34;
    for (_iter34 = this->suppressed.begin(); _iter34 != this->suppressed.end(); ++_iter34)
    {
      xfer += (*_iter34).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("stack", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->stack.size()));
    std::vector<std::string> ::const_iterator _iter35;
    for (_iter35 = this->stack.begin(); _iter35 != this->stack.end(); ++_iter35)
    {
      xfer += oprot->writeString((*_iter35));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errorLocation", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->errorLocation.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->errorCode.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remoteHost", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->remoteHost.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("errorCause", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(static_cast<int32_t>(this->errorCause));
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftExecutionFailureInfo &a, ThriftExecutionFailureInfo &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.message, b.message);
  swap(a.cause, b.cause);
  swap(a.suppressed, b.suppressed);
  swap(a.stack, b.stack);
  swap(a.errorLocation, b.errorLocation);
  swap(a.errorCode, b.errorCode);
  swap(a.remoteHost, b.remoteHost);
  swap(a.errorCause, b.errorCause);
  swap(a.__isset, b.__isset);
}

bool ThriftExecutionFailureInfo::operator==(const ThriftExecutionFailureInfo & rhs) const
{
  if (!(type == rhs.type))
    return false;
  if (!(message == rhs.message))
    return false;
  if (__isset.cause != rhs.__isset.cause)
    return false;
  else if (__isset.cause && !(cause == rhs.cause))
    return false;
  if (!(suppressed == rhs.suppressed))
    return false;
  if (!(stack == rhs.stack))
    return false;
  if (!(errorLocation == rhs.errorLocation))
    return false;
  if (!(errorCode == rhs.errorCode))
    return false;
  if (!(remoteHost == rhs.remoteHost))
    return false;
  if (!(errorCause == rhs.errorCause))
    return false;
  return true;
}

ThriftExecutionFailureInfo::ThriftExecutionFailureInfo(const ThriftExecutionFailureInfo& other36) {
  type = other36.type;
  message = other36.message;
  cause = other36.cause;
  suppressed = other36.suppressed;
  stack = other36.stack;
  errorLocation = other36.errorLocation;
  errorCode = other36.errorCode;
  remoteHost = other36.remoteHost;
  errorCause = other36.errorCause;
  __isset = other36.__isset;
}
ThriftExecutionFailureInfo& ThriftExecutionFailureInfo::operator=(const ThriftExecutionFailureInfo& other37) {
  type = other37.type;
  message = other37.message;
  cause = other37.cause;
  suppressed = other37.suppressed;
  stack = other37.stack;
  errorLocation = other37.errorLocation;
  errorCode = other37.errorCode;
  remoteHost = other37.remoteHost;
  errorCause = other37.errorCause;
  __isset = other37.__isset;
  return *this;
}
void ThriftExecutionFailureInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftExecutionFailureInfo(";
  out << "type=" << to_string(type);
  out << ", " << "message=" << to_string(message);
  out << ", " << "cause="; (__isset.cause ? (out << to_string(cause)) : (out << "<null>"));
  out << ", " << "suppressed=" << to_string(suppressed);
  out << ", " << "stack=" << to_string(stack);
  out << ", " << "errorLocation=" << to_string(errorLocation);
  out << ", " << "errorCode=" << to_string(errorCode);
  out << ", " << "remoteHost=" << to_string(remoteHost);
  out << ", " << "errorCause=" << to_string(errorCause);
  out << ")";
}


ThriftPlanNodeId::~ThriftPlanNodeId() noexcept {
}

ThriftPlanNodeId::ThriftPlanNodeId() noexcept
   : id() {
}

void ThriftPlanNodeId::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const ThriftPlanNodeId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftPlanNodeId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftPlanNodeId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftPlanNodeId");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftPlanNodeId &a, ThriftPlanNodeId &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

bool ThriftPlanNodeId::operator==(const ThriftPlanNodeId & rhs) const
{
  if (!(id == rhs.id))
    return false;
  return true;
}

ThriftPlanNodeId::ThriftPlanNodeId(const ThriftPlanNodeId& other38) {
  id = other38.id;
  __isset = other38.__isset;
}
ThriftPlanNodeId& ThriftPlanNodeId::operator=(const ThriftPlanNodeId& other39) {
  id = other39.id;
  __isset = other39.__isset;
  return *this;
}
void ThriftPlanNodeId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftPlanNodeId(";
  out << "id=" << to_string(id);
  out << ")";
}


ThriftLifespan::~ThriftLifespan() noexcept {
}

ThriftLifespan::ThriftLifespan() noexcept
   : grouped(0),
     groupId(0) {
}

void ThriftLifespan::__set_grouped(const bool val) {
  this->grouped = val;
}

void ThriftLifespan::__set_groupId(const int32_t val) {
  this->groupId = val;
__isset.groupId = true;
}
std::ostream& operator<<(std::ostream& out, const ThriftLifespan& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftLifespan::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->grouped);
          this->__isset.grouped = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->groupId);
          this->__isset.groupId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftLifespan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftLifespan");

  xfer += oprot->writeFieldBegin("grouped", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->grouped);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.groupId) {
    xfer += oprot->writeFieldBegin("groupId", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->groupId);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftLifespan &a, ThriftLifespan &b) {
  using ::std::swap;
  swap(a.grouped, b.grouped);
  swap(a.groupId, b.groupId);
  swap(a.__isset, b.__isset);
}

bool ThriftLifespan::operator==(const ThriftLifespan & rhs) const
{
  if (!(grouped == rhs.grouped))
    return false;
  if (__isset.groupId != rhs.__isset.groupId)
    return false;
  else if (__isset.groupId && !(groupId == rhs.groupId))
    return false;
  return true;
}

ThriftLifespan::ThriftLifespan(const ThriftLifespan& other40) noexcept {
  grouped = other40.grouped;
  groupId = other40.groupId;
  __isset = other40.__isset;
}
ThriftLifespan& ThriftLifespan::operator=(const ThriftLifespan& other41) noexcept {
  grouped = other41.grouped;
  groupId = other41.groupId;
  __isset = other41.__isset;
  return *this;
}
void ThriftLifespan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftLifespan(";
  out << "grouped=" << to_string(grouped);
  out << ", " << "groupId="; (__isset.groupId ? (out << to_string(groupId)) : (out << "<null>"));
  out << ")";
}


ThriftScheduledSplit::~ThriftScheduledSplit() noexcept {
}

ThriftScheduledSplit::ThriftScheduledSplit() noexcept
   : sequenceId(0) {
}

void ThriftScheduledSplit::__set_sequenceId(const int64_t val) {
  this->sequenceId = val;
}

void ThriftScheduledSplit::__set_split(const ThriftSplit& val) {
  this->split = val;
}

void ThriftScheduledSplit::__set_lifespan(const ThriftLifespan& val) {
  this->lifespan = val;
}
std::ostream& operator<<(std::ostream& out, const ThriftScheduledSplit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftScheduledSplit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sequenceId);
          this->__isset.sequenceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->split.read(iprot);
          this->__isset.split = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->lifespan.read(iprot);
          this->__isset.lifespan = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftScheduledSplit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftScheduledSplit");

  xfer += oprot->writeFieldBegin("sequenceId", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->sequenceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("split", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->split.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lifespan", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->lifespan.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftScheduledSplit &a, ThriftScheduledSplit &b) {
  using ::std::swap;
  swap(a.sequenceId, b.sequenceId);
  swap(a.split, b.split);
  swap(a.lifespan, b.lifespan);
  swap(a.__isset, b.__isset);
}

bool ThriftScheduledSplit::operator==(const ThriftScheduledSplit & rhs) const
{
  if (!(sequenceId == rhs.sequenceId))
    return false;
  if (!(split == rhs.split))
    return false;
  if (!(lifespan == rhs.lifespan))
    return false;
  return true;
}

ThriftScheduledSplit::ThriftScheduledSplit(const ThriftScheduledSplit& other42) {
  sequenceId = other42.sequenceId;
  split = other42.split;
  lifespan = other42.lifespan;
  __isset = other42.__isset;
}
ThriftScheduledSplit& ThriftScheduledSplit::operator=(const ThriftScheduledSplit& other43) {
  sequenceId = other43.sequenceId;
  split = other43.split;
  lifespan = other43.lifespan;
  __isset = other43.__isset;
  return *this;
}
void ThriftScheduledSplit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftScheduledSplit(";
  out << "sequenceId=" << to_string(sequenceId);
  out << ", " << "split=" << to_string(split);
  out << ", " << "lifespan=" << to_string(lifespan);
  out << ")";
}


ThriftSplit::~ThriftSplit() noexcept {
}

ThriftSplit::ThriftSplit() noexcept
   : connectorId(),
     connectorSplit(),
     remoteSplit(0),
     splitWeight(0) {
}

void ThriftSplit::__set_connectorId(const std::string& val) {
  this->connectorId = val;
}

void ThriftSplit::__set_connectorSplit(const std::string& val) {
  this->connectorSplit = val;
}

void ThriftSplit::__set_remoteSplit(const bool val) {
  this->remoteSplit = val;
}

void ThriftSplit::__set_splitWeight(const double val) {
  this->splitWeight = val;
__isset.splitWeight = true;
}
std::ostream& operator<<(std::ostream& out, const ThriftSplit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftSplit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->connectorId);
          this->__isset.connectorId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->connectorSplit);
          this->__isset.connectorSplit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->remoteSplit);
          this->__isset.remoteSplit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->splitWeight);
          this->__isset.splitWeight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftSplit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftSplit");

  xfer += oprot->writeFieldBegin("connectorId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->connectorId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("connectorSplit", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeBinary(this->connectorSplit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("remoteSplit", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->remoteSplit);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.splitWeight) {
    xfer += oprot->writeFieldBegin("splitWeight", ::apache::thrift::protocol::T_DOUBLE, 4);
    xfer += oprot->writeDouble(this->splitWeight);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftSplit &a, ThriftSplit &b) {
  using ::std::swap;
  swap(a.connectorId, b.connectorId);
  swap(a.connectorSplit, b.connectorSplit);
  swap(a.remoteSplit, b.remoteSplit);
  swap(a.splitWeight, b.splitWeight);
  swap(a.__isset, b.__isset);
}

bool ThriftSplit::operator==(const ThriftSplit & rhs) const
{
  if (!(connectorId == rhs.connectorId))
    return false;
  if (!(connectorSplit == rhs.connectorSplit))
    return false;
  if (!(remoteSplit == rhs.remoteSplit))
    return false;
  if (__isset.splitWeight != rhs.__isset.splitWeight)
    return false;
  else if (__isset.splitWeight && !(splitWeight == rhs.splitWeight))
    return false;
  return true;
}

ThriftSplit::ThriftSplit(const ThriftSplit& other44) {
  connectorId = other44.connectorId;
  connectorSplit = other44.connectorSplit;
  remoteSplit = other44.remoteSplit;
  splitWeight = other44.splitWeight;
  __isset = other44.__isset;
}
ThriftSplit& ThriftSplit::operator=(const ThriftSplit& other45) {
  connectorId = other45.connectorId;
  connectorSplit = other45.connectorSplit;
  remoteSplit = other45.remoteSplit;
  splitWeight = other45.splitWeight;
  __isset = other45.__isset;
  return *this;
}
void ThriftSplit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftSplit(";
  out << "connectorId=" << to_string(connectorId);
  out << ", " << "connectorSplit=" << to_string(connectorSplit);
  out << ", " << "remoteSplit=" << to_string(remoteSplit);
  out << ", " << "splitWeight="; (__isset.splitWeight ? (out << to_string(splitWeight)) : (out << "<null>"));
  out << ")";
}


ThriftTaskSource::~ThriftTaskSource() noexcept {
}

ThriftTaskSource::ThriftTaskSource() noexcept
   : noMoreSplits(0) {
}

void ThriftTaskSource::__set_planNodeId(const ThriftPlanNodeId& val) {
  this->planNodeId = val;
}

void ThriftTaskSource::__set_splits(const std::vector<ThriftScheduledSplit> & val) {
  this->splits = val;
}

void ThriftTaskSource::__set_noMoreSplits(const bool val) {
  this->noMoreSplits = val;
}
std::ostream& operator<<(std::ostream& out, const ThriftTaskSource& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftTaskSource::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->planNodeId.read(iprot);
          this->__isset.planNodeId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->splits.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->splits.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              xfer += this->splits[_i50].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.splits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->noMoreSplits);
          this->__isset.noMoreSplits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftTaskSource::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTaskSource");

  xfer += oprot->writeFieldBegin("planNodeId", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->planNodeId.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("splits", ::apache::thrift::protocol::T_LIST, 2);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->splits.size()));
    std::vector<ThriftScheduledSplit> ::const_iterator _iter51;
    for (_iter51 = this->splits.begin(); _iter51 != this->splits.end(); ++_iter51)
    {
      xfer += (*_iter51).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noMoreSplits", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->noMoreSplits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftTaskSource &a, ThriftTaskSource &b) {
  using ::std::swap;
  swap(a.planNodeId, b.planNodeId);
  swap(a.splits, b.splits);
  swap(a.noMoreSplits, b.noMoreSplits);
  swap(a.__isset, b.__isset);
}

bool ThriftTaskSource::operator==(const ThriftTaskSource & rhs) const
{
  if (!(planNodeId == rhs.planNodeId))
    return false;
  if (!(splits == rhs.splits))
    return false;
  if (!(noMoreSplits == rhs.noMoreSplits))
    return false;
  return true;
}

ThriftTaskSource::ThriftTaskSource(const ThriftTaskSource& other52) {
  planNodeId = other52.planNodeId;
  splits = other52.splits;
  noMoreSplits = other52.noMoreSplits;
  __isset = other52.__isset;
}
ThriftTaskSource& ThriftTaskSource::operator=(const ThriftTaskSource& other53) {
  planNodeId = other53.planNodeId;
  splits = other53.splits;
  noMoreSplits = other53.noMoreSplits;
  __isset = other53.__isset;
  return *this;
}
void ThriftTaskSource::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftTaskSource(";
  out << "planNodeId=" << to_string(planNodeId);
  out << ", " << "splits=" << to_string(splits);
  out << ", " << "noMoreSplits=" << to_string(noMoreSplits);
  out << ")";
}


ThriftTableWriteInfo::~ThriftTableWriteInfo() noexcept {
}

ThriftTableWriteInfo::ThriftTableWriteInfo() noexcept
   : catalogName(),
     schemaName(),
     tableName(),
     writtenByQuery(0) {
}

void ThriftTableWriteInfo::__set_catalogName(const std::string& val) {
  this->catalogName = val;
}

void ThriftTableWriteInfo::__set_schemaName(const std::string& val) {
  this->schemaName = val;
}

void ThriftTableWriteInfo::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void ThriftTableWriteInfo::__set_writtenByQuery(const bool val) {
  this->writtenByQuery = val;
}
std::ostream& operator<<(std::ostream& out, const ThriftTableWriteInfo& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftTableWriteInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->catalogName);
          this->__isset.catalogName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          this->__isset.tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->writtenByQuery);
          this->__isset.writtenByQuery = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftTableWriteInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTableWriteInfo");

  xfer += oprot->writeFieldBegin("catalogName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->catalogName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->schemaName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("writtenByQuery", ::apache::thrift::protocol::T_BOOL, 4);
  xfer += oprot->writeBool(this->writtenByQuery);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftTableWriteInfo &a, ThriftTableWriteInfo &b) {
  using ::std::swap;
  swap(a.catalogName, b.catalogName);
  swap(a.schemaName, b.schemaName);
  swap(a.tableName, b.tableName);
  swap(a.writtenByQuery, b.writtenByQuery);
  swap(a.__isset, b.__isset);
}

bool ThriftTableWriteInfo::operator==(const ThriftTableWriteInfo & rhs) const
{
  if (!(catalogName == rhs.catalogName))
    return false;
  if (!(schemaName == rhs.schemaName))
    return false;
  if (!(tableName == rhs.tableName))
    return false;
  if (!(writtenByQuery == rhs.writtenByQuery))
    return false;
  return true;
}

ThriftTableWriteInfo::ThriftTableWriteInfo(const ThriftTableWriteInfo& other54) {
  catalogName = other54.catalogName;
  schemaName = other54.schemaName;
  tableName = other54.tableName;
  writtenByQuery = other54.writtenByQuery;
  __isset = other54.__isset;
}
ThriftTableWriteInfo& ThriftTableWriteInfo::operator=(const ThriftTableWriteInfo& other55) {
  catalogName = other55.catalogName;
  schemaName = other55.schemaName;
  tableName = other55.tableName;
  writtenByQuery = other55.writtenByQuery;
  __isset = other55.__isset;
  return *this;
}
void ThriftTableWriteInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftTableWriteInfo(";
  out << "catalogName=" << to_string(catalogName);
  out << ", " << "schemaName=" << to_string(schemaName);
  out << ", " << "tableName=" << to_string(tableName);
  out << ", " << "writtenByQuery=" << to_string(writtenByQuery);
  out << ")";
}


ThriftResourceEstimates::~ThriftResourceEstimates() noexcept {
}

ThriftResourceEstimates::ThriftResourceEstimates() noexcept
   : executionTimeInMillis(0),
     cpuTimeInNanos(0),
     peakMemoryInBytes(0),
     peakTaskMemoryInBytes(0) {
}

void ThriftResourceEstimates::__set_executionTimeInMillis(const int64_t val) {
  this->executionTimeInMillis = val;
__isset.executionTimeInMillis = true;
}

void ThriftResourceEstimates::__set_cpuTimeInNanos(const int64_t val) {
  this->cpuTimeInNanos = val;
__isset.cpuTimeInNanos = true;
}

void ThriftResourceEstimates::__set_peakMemoryInBytes(const int64_t val) {
  this->peakMemoryInBytes = val;
__isset.peakMemoryInBytes = true;
}

void ThriftResourceEstimates::__set_peakTaskMemoryInBytes(const int64_t val) {
  this->peakTaskMemoryInBytes = val;
__isset.peakTaskMemoryInBytes = true;
}
std::ostream& operator<<(std::ostream& out, const ThriftResourceEstimates& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftResourceEstimates::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->executionTimeInMillis);
          this->__isset.executionTimeInMillis = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->cpuTimeInNanos);
          this->__isset.cpuTimeInNanos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->peakMemoryInBytes);
          this->__isset.peakMemoryInBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->peakTaskMemoryInBytes);
          this->__isset.peakTaskMemoryInBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftResourceEstimates::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftResourceEstimates");

  if (this->__isset.executionTimeInMillis) {
    xfer += oprot->writeFieldBegin("executionTimeInMillis", ::apache::thrift::protocol::T_I64, 1);
    xfer += oprot->writeI64(this->executionTimeInMillis);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.cpuTimeInNanos) {
    xfer += oprot->writeFieldBegin("cpuTimeInNanos", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->cpuTimeInNanos);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.peakMemoryInBytes) {
    xfer += oprot->writeFieldBegin("peakMemoryInBytes", ::apache::thrift::protocol::T_I64, 3);
    xfer += oprot->writeI64(this->peakMemoryInBytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.peakTaskMemoryInBytes) {
    xfer += oprot->writeFieldBegin("peakTaskMemoryInBytes", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->peakTaskMemoryInBytes);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftResourceEstimates &a, ThriftResourceEstimates &b) {
  using ::std::swap;
  swap(a.executionTimeInMillis, b.executionTimeInMillis);
  swap(a.cpuTimeInNanos, b.cpuTimeInNanos);
  swap(a.peakMemoryInBytes, b.peakMemoryInBytes);
  swap(a.peakTaskMemoryInBytes, b.peakTaskMemoryInBytes);
  swap(a.__isset, b.__isset);
}

bool ThriftResourceEstimates::operator==(const ThriftResourceEstimates & rhs) const
{
  if (__isset.executionTimeInMillis != rhs.__isset.executionTimeInMillis)
    return false;
  else if (__isset.executionTimeInMillis && !(executionTimeInMillis == rhs.executionTimeInMillis))
    return false;
  if (__isset.cpuTimeInNanos != rhs.__isset.cpuTimeInNanos)
    return false;
  else if (__isset.cpuTimeInNanos && !(cpuTimeInNanos == rhs.cpuTimeInNanos))
    return false;
  if (__isset.peakMemoryInBytes != rhs.__isset.peakMemoryInBytes)
    return false;
  else if (__isset.peakMemoryInBytes && !(peakMemoryInBytes == rhs.peakMemoryInBytes))
    return false;
  if (__isset.peakTaskMemoryInBytes != rhs.__isset.peakTaskMemoryInBytes)
    return false;
  else if (__isset.peakTaskMemoryInBytes && !(peakTaskMemoryInBytes == rhs.peakTaskMemoryInBytes))
    return false;
  return true;
}

ThriftResourceEstimates::ThriftResourceEstimates(const ThriftResourceEstimates& other56) noexcept {
  executionTimeInMillis = other56.executionTimeInMillis;
  cpuTimeInNanos = other56.cpuTimeInNanos;
  peakMemoryInBytes = other56.peakMemoryInBytes;
  peakTaskMemoryInBytes = other56.peakTaskMemoryInBytes;
  __isset = other56.__isset;
}
ThriftResourceEstimates& ThriftResourceEstimates::operator=(const ThriftResourceEstimates& other57) noexcept {
  executionTimeInMillis = other57.executionTimeInMillis;
  cpuTimeInNanos = other57.cpuTimeInNanos;
  peakMemoryInBytes = other57.peakMemoryInBytes;
  peakTaskMemoryInBytes = other57.peakTaskMemoryInBytes;
  __isset = other57.__isset;
  return *this;
}
void ThriftResourceEstimates::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftResourceEstimates(";
  out << "executionTimeInMillis="; (__isset.executionTimeInMillis ? (out << to_string(executionTimeInMillis)) : (out << "<null>"));
  out << ", " << "cpuTimeInNanos="; (__isset.cpuTimeInNanos ? (out << to_string(cpuTimeInNanos)) : (out << "<null>"));
  out << ", " << "peakMemoryInBytes="; (__isset.peakMemoryInBytes ? (out << to_string(peakMemoryInBytes)) : (out << "<null>"));
  out << ", " << "peakTaskMemoryInBytes="; (__isset.peakTaskMemoryInBytes ? (out << to_string(peakTaskMemoryInBytes)) : (out << "<null>"));
  out << ")";
}


ThriftTransactionId::~ThriftTransactionId() noexcept {
}

ThriftTransactionId::ThriftTransactionId() noexcept
   : mostSignificantBits(0),
     leastSignificantBits(0),
     stringRepresentation() {
}

void ThriftTransactionId::__set_mostSignificantBits(const int64_t val) {
  this->mostSignificantBits = val;
}

void ThriftTransactionId::__set_leastSignificantBits(const int64_t val) {
  this->leastSignificantBits = val;
}

void ThriftTransactionId::__set_stringRepresentation(const std::string& val) {
  this->stringRepresentation = val;
__isset.stringRepresentation = true;
}
std::ostream& operator<<(std::ostream& out, const ThriftTransactionId& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftTransactionId::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->mostSignificantBits);
          this->__isset.mostSignificantBits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->leastSignificantBits);
          this->__isset.leastSignificantBits = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->stringRepresentation);
          this->__isset.stringRepresentation = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftTransactionId::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTransactionId");

  xfer += oprot->writeFieldBegin("mostSignificantBits", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->mostSignificantBits);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leastSignificantBits", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->leastSignificantBits);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.stringRepresentation) {
    xfer += oprot->writeFieldBegin("stringRepresentation", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->stringRepresentation);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftTransactionId &a, ThriftTransactionId &b) {
  using ::std::swap;
  swap(a.mostSignificantBits, b.mostSignificantBits);
  swap(a.leastSignificantBits, b.leastSignificantBits);
  swap(a.stringRepresentation, b.stringRepresentation);
  swap(a.__isset, b.__isset);
}

bool ThriftTransactionId::operator==(const ThriftTransactionId & rhs) const
{
  if (!(mostSignificantBits == rhs.mostSignificantBits))
    return false;
  if (!(leastSignificantBits == rhs.leastSignificantBits))
    return false;
  if (__isset.stringRepresentation != rhs.__isset.stringRepresentation)
    return false;
  else if (__isset.stringRepresentation && !(stringRepresentation == rhs.stringRepresentation))
    return false;
  return true;
}

ThriftTransactionId::ThriftTransactionId(const ThriftTransactionId& other58) {
  mostSignificantBits = other58.mostSignificantBits;
  leastSignificantBits = other58.leastSignificantBits;
  stringRepresentation = other58.stringRepresentation;
  __isset = other58.__isset;
}
ThriftTransactionId& ThriftTransactionId::operator=(const ThriftTransactionId& other59) {
  mostSignificantBits = other59.mostSignificantBits;
  leastSignificantBits = other59.leastSignificantBits;
  stringRepresentation = other59.stringRepresentation;
  __isset = other59.__isset;
  return *this;
}
void ThriftTransactionId::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftTransactionId(";
  out << "mostSignificantBits=" << to_string(mostSignificantBits);
  out << ", " << "leastSignificantBits=" << to_string(leastSignificantBits);
  out << ", " << "stringRepresentation="; (__isset.stringRepresentation ? (out << to_string(stringRepresentation)) : (out << "<null>"));
  out << ")";
}


ThriftTimeZoneKey::~ThriftTimeZoneKey() noexcept {
}

ThriftTimeZoneKey::ThriftTimeZoneKey() noexcept
   : key(0),
     id() {
}

void ThriftTimeZoneKey::__set_key(const int16_t val) {
  this->key = val;
}

void ThriftTimeZoneKey::__set_id(const std::string& val) {
  this->id = val;
}
std::ostream& operator<<(std::ostream& out, const ThriftTimeZoneKey& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t ThriftTimeZoneKey::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->key);
          this->__isset.key = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ThriftTimeZoneKey::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ThriftTimeZoneKey");

  xfer += oprot->writeFieldBegin("key", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->key);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ThriftTimeZoneKey &a, ThriftTimeZoneKey &b) {
  using ::std::swap;
  swap(a.key, b.key);
  swap(a.id, b.id);
  swap(a.__isset, b.__isset);
}

bool ThriftTimeZoneKey::operator==(const ThriftTimeZoneKey & rhs) const
{
  if (!(key == rhs.key))
    return false;
  if (!(id == rhs.id))
    return false;
  return true;
}

ThriftTimeZoneKey::ThriftTimeZoneKey(const ThriftTimeZoneKey& other60) {
  key = other60.key;
  id = other60.id;
  __isset = other60.__isset;
}
ThriftTimeZoneKey& ThriftTimeZoneKey::operator=(const ThriftTimeZoneKey& other61) {
  key = other61.key;
  id = other61.id;
  __isset = other61.__isset;
  return *this;
}
void ThriftTimeZoneKey::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ThriftTimeZoneKey(";
  out << "key=" << to_string(key);
  out << ", " << "id=" << to_string(id);
  out << ")";
}

} // namespace
