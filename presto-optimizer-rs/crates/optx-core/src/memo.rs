//! # Memo Table
//!
//! The memo table is the central data structure of a Cascades optimizer. It compactly
//! represents the entire search space of equivalent query plans using two key concepts:
//!
//! ## Groups
//! A **group** is a set of logically equivalent expressions. For example, the expressions
//! `A JOIN B` and `B JOIN A` produce the same result set, so they belong to the same group.
//! Each group tracks:
//! - All logical expressions (alternatives generated by transformation rules)
//! - All physical expressions (alternatives generated by implementation rules)
//! - The best physical plan found so far for each set of required physical properties
//!   (e.g., "output must be sorted by column X")
//!
//! ## Expressions
//! A **memo expression** stores an operator (e.g., HashJoin, SeqScan) and references
//! its children by **group ID** rather than by expression ID. This is the key insight:
//! by pointing to groups instead of specific expressions, a single memo expression
//! implicitly represents all combinations of its children's alternatives.
//!
//! For example, if group G1 has expressions {A, B} and group G2 has {C, D}, then
//! a single Join(G1, G2) expression implicitly represents four plans:
//! Join(A,C), Join(A,D), Join(B,C), Join(B,D).
//!
//! ## Deduplication
//! The memo uses fingerprinting (operator + child group IDs) to detect and avoid
//! inserting duplicate expressions, keeping the search space compact.

use crate::cost::Cost;
use crate::expr::Operator;
use crate::properties::{LogicalProperties, PhysicalPropertySet};
use crate::stats::Statistics;
use std::collections::HashMap;

pub type GroupId = u32;
pub type ExprId = u32;

/// A group represents a set of logically equivalent expressions.
///
/// All expressions in a group produce the same logical result (same rows, same columns),
/// but may differ in:
/// - Join ordering (e.g., `A JOIN B` vs `B JOIN A`)
/// - Physical algorithm (e.g., HashJoin vs MergeJoin)
/// - Required properties (e.g., sorted vs unsorted output)
///
/// The `best_plan` map stores the optimal physical plan for each set of required
/// physical properties. This is how the optimizer handles "interesting orders" —
/// a plan that produces sorted output might be preferred even if it's slightly
/// more expensive, because it avoids a separate sort step upstream.
#[derive(Debug)]
pub struct Group {
    pub id: GroupId,
    /// Logically equivalent expressions (generated by transformation rules).
    pub logical_exprs: Vec<ExprId>,
    /// Physical implementation alternatives (generated by implementation rules).
    pub physical_exprs: Vec<ExprId>,
    /// Properties derived from the logical content (output columns, etc.).
    pub logical_props: LogicalProperties,
    /// Best physical plan found for each set of required physical properties.
    /// Key: required properties (e.g., "must be sorted by col X").
    /// Value: the winning expression and its total cost.
    pub best_plan: HashMap<PhysicalPropertySet, Winner>,
    /// Whether this group has been fully explored by transformation rules.
    /// Once explored, we won't re-apply transformation rules to existing expressions.
    pub explored: bool,
    /// Cached statistics for this group (row count, column NDVs, etc.).
    pub stats: Option<Statistics>,
}

/// A winner is the best plan for a given set of required properties.
#[derive(Debug, Clone)]
pub struct Winner {
    pub expr_id: ExprId,
    pub cost: Cost,
}

/// An expression stored in the memo.
///
/// Key design: children are **group IDs**, not expression IDs. This means the
/// expression implicitly references all equivalent alternatives in each child group.
/// When we later extract the best plan, we pick the cheapest expression from each
/// child group.
#[derive(Debug)]
pub struct MemoExpr {
    pub id: ExprId,
    /// Which group this expression belongs to.
    pub group_id: GroupId,
    /// The operator (logical or physical).
    pub op: Operator,
    /// Child groups (NOT child expressions). This is what makes the memo compact.
    pub children: Vec<GroupId>,
    /// Rule fingerprints already applied to this expression (to avoid redundant work).
    pub applied_rules: Vec<u64>,
}

/// Fingerprint for deduplication: two expressions are considered identical
/// if they have the same operator and the same child groups.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
struct ExprFingerprint {
    op: Operator,
    children: Vec<GroupId>,
}

/// The Memo stores all groups and expressions in the optimizer's search space.
///
/// The memo grows during optimization as rules generate new expressions and groups.
/// It provides O(1) lookup by group ID and expression ID, and uses fingerprinting
/// for O(1) deduplication of expressions.
#[derive(Debug)]
pub struct Memo {
    groups: Vec<Group>,
    exprs: Vec<MemoExpr>,
    /// Index from expression fingerprint to expression ID, used for deduplication.
    expr_index: HashMap<ExprFingerprint, ExprId>,
}

impl Memo {
    pub fn new() -> Self {
        Self {
            groups: Vec::new(),
            exprs: Vec::new(),
            expr_index: HashMap::new(),
        }
    }

    /// Insert a new expression into the memo, creating a new group for it.
    ///
    /// If an expression with the same operator and child groups already exists
    /// (deduplication), returns the existing group and expression IDs instead.
    ///
    /// This is the primary way to build the initial logical plan in the memo:
    /// create leaf scans, then create joins/filters referencing the leaf groups.
    pub fn add_expr(&mut self, op: Operator, children: Vec<GroupId>) -> (GroupId, ExprId) {
        let fingerprint = ExprFingerprint {
            op: op.clone(),
            children: children.clone(),
        };

        // Dedup: if we've seen this exact (operator, children) combination before,
        // return the existing expression rather than creating a duplicate.
        if let Some(&existing_id) = self.expr_index.get(&fingerprint) {
            let group_id = self.exprs[existing_id as usize].group_id;
            return (group_id, existing_id);
        }

        let expr_id = self.exprs.len() as ExprId;
        let group_id = self.groups.len() as GroupId;

        let group = Group {
            id: group_id,
            logical_exprs: if op.is_logical() {
                vec![expr_id]
            } else {
                vec![]
            },
            physical_exprs: if op.is_physical() {
                vec![expr_id]
            } else {
                vec![]
            },
            logical_props: LogicalProperties::default(),
            best_plan: HashMap::new(),
            explored: false,
            stats: None,
        };

        let memo_expr = MemoExpr {
            id: expr_id,
            group_id,
            op,
            children,
            applied_rules: Vec::new(),
        };

        self.groups.push(group);
        self.exprs.push(memo_expr);
        self.expr_index.insert(fingerprint, expr_id);

        (group_id, expr_id)
    }

    /// Add a new expression to an existing group.
    ///
    /// This is used during optimization when a rule produces a new equivalent
    /// expression. For example, the join commutativity rule transforms
    /// `A JOIN B` → `B JOIN A`, and the new expression is added to the same group.
    ///
    /// Similarly, implementation rules add physical expressions (e.g., HashJoin)
    /// to the same group as the logical expression (e.g., logical Join).
    pub fn add_expr_to_group(&mut self, group_id: GroupId, op: Operator, children: Vec<GroupId>) -> ExprId {
        let fingerprint = ExprFingerprint {
            op: op.clone(),
            children: children.clone(),
        };

        // Dedup: avoid inserting the same expression twice
        if let Some(&existing_id) = self.expr_index.get(&fingerprint) {
            return existing_id;
        }

        let expr_id = self.exprs.len() as ExprId;
        let memo_expr = MemoExpr {
            id: expr_id,
            group_id,
            op: op.clone(),
            children,
            applied_rules: Vec::new(),
        };

        self.exprs.push(memo_expr);
        self.expr_index.insert(fingerprint, expr_id);

        // Add to the appropriate list in the group
        let group = &mut self.groups[group_id as usize];
        if op.is_logical() {
            group.logical_exprs.push(expr_id);
        } else {
            group.physical_exprs.push(expr_id);
        }

        expr_id
    }

    pub fn group(&self, id: GroupId) -> &Group {
        &self.groups[id as usize]
    }

    pub fn group_mut(&mut self, id: GroupId) -> &mut Group {
        &mut self.groups[id as usize]
    }

    pub fn expr(&self, id: ExprId) -> &MemoExpr {
        &self.exprs[id as usize]
    }

    pub fn expr_mut(&mut self, id: ExprId) -> &mut MemoExpr {
        &mut self.exprs[id as usize]
    }

    pub fn num_groups(&self) -> usize {
        self.groups.len()
    }

    pub fn num_exprs(&self) -> usize {
        self.exprs.len()
    }

    /// Record that a rule has been applied to an expression, preventing re-application.
    /// This is an important optimization: without it, the optimizer would loop infinitely
    /// applying the same rules to the same expressions (e.g., commutativity: A⋈B → B⋈A → A⋈B...).
    pub fn mark_rule_applied(&mut self, expr_id: ExprId, rule_hash: u64) {
        self.exprs[expr_id as usize].applied_rules.push(rule_hash);
    }

    /// Check if a rule has already been applied to an expression.
    pub fn rule_applied(&self, expr_id: ExprId, rule_hash: u64) -> bool {
        self.exprs[expr_id as usize]
            .applied_rules
            .contains(&rule_hash)
    }

    /// Extract the best physical plan tree from the memo.
    ///
    /// Starting from the given root group with the given required properties,
    /// recursively follows the winner chain to build a complete plan tree.
    /// Each group's winner points to the best physical expression, and each
    /// child group is recursively resolved.
    pub fn extract_best_plan(&self, group_id: GroupId, required: &PhysicalPropertySet) -> Option<PlanNode> {
        let group = self.group(group_id);
        let winner = group.best_plan.get(required)?;
        let expr = self.expr(winner.expr_id);

        let children: Vec<PlanNode> = expr
            .children
            .iter()
            .map(|&child_gid| {
                // Each child is resolved with "any" properties — the parent physical
                // operator already encoded its requirements (e.g., MergeJoin requires
                // sorted children) when it was selected as the winner.
                self.extract_best_plan(child_gid, &PhysicalPropertySet::any())
            })
            .collect::<Option<Vec<_>>>()?;

        Some(PlanNode {
            op: expr.op.clone(),
            children,
            cost: winner.cost,
            group_id,
        })
    }
}

/// A tree-structured plan extracted from the memo.
///
/// While the memo stores plans as a DAG (shared groups), extraction produces
/// a traditional tree for consumption by the query engine.
#[derive(Debug, Clone)]
pub struct PlanNode {
    pub op: Operator,
    pub children: Vec<PlanNode>,
    pub cost: Cost,
    pub group_id: GroupId,
}

impl PlanNode {
    /// Pretty-print the plan tree with indentation showing the hierarchy.
    pub fn display(&self, indent: usize) -> String {
        let mut s = String::new();
        let prefix = "  ".repeat(indent);
        s.push_str(&format!("{}[cost={:.1}] {:?}\n", prefix, self.cost.total, self.op));
        for child in &self.children {
            s.push_str(&child.display(indent + 1));
        }
        s
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::expr::*;

    #[test]
    fn test_memo_add_expr() {
        let mut memo = Memo::new();

        let scan_op = Operator::Logical(LogicalOp::Scan {
            table: TableRef {
                schema: "tpch".into(),
                name: "orders".into(),
            },
            columns: vec![],
            predicate: None,
        });

        let (gid1, eid1) = memo.add_expr(scan_op.clone(), vec![]);
        assert_eq!(gid1, 0);
        assert_eq!(eid1, 0);

        // Same expression deduplicates
        let (gid2, eid2) = memo.add_expr(scan_op, vec![]);
        assert_eq!(gid1, gid2);
        assert_eq!(eid1, eid2);

        assert_eq!(memo.num_groups(), 1);
        assert_eq!(memo.num_exprs(), 1);
    }

    #[test]
    fn test_memo_add_expr_to_group() {
        let mut memo = Memo::new();

        let scan = Operator::Logical(LogicalOp::Scan {
            table: TableRef {
                schema: "tpch".into(),
                name: "orders".into(),
            },
            columns: vec![],
            predicate: None,
        });
        let (gid, _) = memo.add_expr(scan, vec![]);

        // Add physical alternative to same group
        let seq_scan = Operator::Physical(PhysicalOp::SeqScan {
            table: TableRef {
                schema: "tpch".into(),
                name: "orders".into(),
            },
            columns: vec![],
            predicate: None,
        });
        let eid2 = memo.add_expr_to_group(gid, seq_scan, vec![]);

        let group = memo.group(gid);
        assert_eq!(group.logical_exprs.len(), 1);
        assert_eq!(group.physical_exprs.len(), 1);
        assert_eq!(group.physical_exprs[0], eid2);
    }
}
