/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.facebook.presto.execution.scheduler.nodeSelection;

import com.facebook.presto.execution.scheduler.ResettableRandomizedIterator;
import com.facebook.presto.metadata.InternalNode;
import it.unimi.dsi.fastutil.longs.LongComparator;

import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.LongStream;

import static com.google.common.collect.ImmutableList.toImmutableList;
import static java.util.Objects.requireNonNull;

/**
 * Performs Node selection using Power of two choice paradigm. This method performs
 * better than ScoreBasedNodeSelection since it doesn't need to sort the candidate
 * nodes. Rather the algorithm uniformly samples nodes and selects node with highest
 * score.
 */
public class PowerOfTwoChoiceNodeSelectionStrategy
        implements NodeSelectionStrategy
{
    private final Comparator<InternalNode> comparator;

    /**
     * Creates instance of PowerOfTwoChoiceNodeSelector
     *
     * @param nodeScorer Instance of NodeScorer. The parameter is used to score
     * individual nodes and helps makes decision on which nodes to select
     * @param scoreComparator LongComparator instance used to compare the scores
     * generated by NodeScorer. The comparator is used to make decision on which
     * nodes to select. Nodes with the highest score based on the comparator are
     * selected and returned from the node selector.
     */
    public PowerOfTwoChoiceNodeSelectionStrategy(NodeScorer nodeScorer, LongComparator scoreComparator)
    {
        NodeScorer scorer = requireNonNull(nodeScorer, "NodeScorer cannot be null");
        LongComparator scoreComp = requireNonNull(scoreComparator, "Comparator cannot be null");
        this.comparator = Comparator.comparing(scorer::score, scoreComp);
    }

    @Override
    public List<InternalNode> select(List<InternalNode> candidates, NodeSelectionHint hint)
    {
        long count = hint.getLimit().orElse(candidates.size());
        List<InternalNode> candidateNodes = candidates.stream()
                .filter(node -> hint.canIncludeCoordinator() || !node.isCoordinator())
                .filter(node -> !hint.hasExclusionSet() || !hint.getExclusionSet().contains(node))
                .collect(Collectors.toList());

        if (candidateNodes.size() < 2 || candidateNodes.size() < count) {
            return candidateNodes;
        }

        ResettableRandomizedIterator<InternalNode> iter = new ResettableRandomizedIterator<>(candidateNodes);

        return LongStream.range(0, count)
                .mapToObj(a -> {
                    iter.reset();
                    InternalNode node1 = iter.next();
                    InternalNode node2 = iter.next();
                    if (this.comparator.compare(node1, node2) > 0) {
                        return node1;
                    }
                    else {
                        return node2;
                    }
                })
                .collect(toImmutableList());
    }
}
